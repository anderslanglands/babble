cmake_minimum_required(VERSION 3.15)
project(bbl-usd VERSION 0.1)

find_package(pxr REQUIRED)

# The bindfile contains all our binding definitions
set(BINDFILE bind.cpp)

# These files will be generated by bbl-translate
set(SOURCE usd-c.cpp)
set(HEADER usd-c.h)

# Create the C API library
add_library(usd-c STATIC ${SOURCE})
target_link_libraries(usd-c PUBLIC usd)
add_compile_definitions(usd-c PRIVATE NOMINMAX BOOST_ALL_NO_LIB __TBB_show_deprecation_message_task_H)

# Invoke bbl-translate to generate the C API source from the bindfile
# In a real project you would bring bbl-translate in with add_subdirectory or FetchContent
get_filename_component(bind_abs bind.cpp REALPATH BASEDIR ${CMAKE_CURRENT_BINARY_DIR})
add_custom_command(
    OUTPUT ${SOURCE}
    DEPENDS ${bind_abs}
    COMMAND 
        bbl-translate 
            ${bind_abs} 
            -- 
            -std=c++17
            "-I$<JOIN:$<TARGET_PROPERTY:babble::bbl,INCLUDE_DIRECTORIES>,;-I>" 
            "-I$<JOIN:$<TARGET_PROPERTY:usd-c,INCLUDE_DIRECTORIES>,;-I>" 
            -Wno-deprecated-builtins -DNOMINMAX -D_MT -DBOOST_ALL_NO_LIB -D__TBB_show_deprecation_message_task_H 
            -- 
            ${SOURCE} ${HEADER}
    COMMAND_EXPAND_LISTS
)

# Compile a simple test program to exercise the generated library
add_executable(usd-c-test01 usd-c-test01.cpp)
target_link_libraries(usd-c-test01 PUBLIC usd-c)
target_include_directories(usd-c-test01 PRIVATE ${CMAKE_CURRENT_BINARY_DIR})

# This is just here to trigger generation of compile commands for the bind file so we get LSP functionality in the bind file
add_library(bind-dummy bind.cpp)
target_link_libraries(bind-dummy usd babble::bbl)
