#ifndef __USD_C_H__
#define __USD_C_H__

#if defined(__GNUC__) || defined(__clang__)
#  define BBL_ALIGN(x) __attribute__ ((aligned(x)))
#elif defined(_MSC_VER)
#  define BBL_ALIGN(x) __declspec(align(x))
#else
#  error "Unknown compiler; can't define ALIGN"
#endif

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/** enums */

/// Projection type.
enum gf_CameraProjection {
    gf_CameraProjection_Perspective = 0,
    gf_CameraProjection_Orthographic = 1,
};

/// Direction used for Field of View or orthographic size
enum gf_CameraFOVDirection {
    gf_CameraFOVDirection_FOVHorizontal = 0,
    gf_CameraFOVDirection_FOVVertical = 1,
};

/// This enum is used to determine the type of projection represented by a
/// frustum.
enum gf_FrustumProjectionType {
    gf_FrustumProjectionType_Orthographic = 0,
    gf_FrustumProjectionType_Perspective = 1,
};

/// \enum PcpArcType
/// 
/// Describes the type of arc connecting two nodes in the prim index.
enum pcp_ArcType {
    pcp_ArcType_PcpArcTypeRoot = 0,
    pcp_ArcType_PcpArcTypeInherit = 1,
    pcp_ArcType_PcpArcTypeVariant = 2,
    pcp_ArcType_PcpArcTypeRelocate = 3,
    pcp_ArcType_PcpArcTypeReference = 4,
    pcp_ArcType_PcpArcTypePayload = 5,
    pcp_ArcType_PcpArcTypeSpecialize = 6,
    pcp_ArcType_PcpNumArcTypes = 7,
};

enum sdf_ChangleListSubLayerChangeType {
    sdf_ChangleListSubLayerChangeType_SubLayerAdded = 0,
    sdf_ChangleListSubLayerChangeType_SubLayerRemoved = 1,
    sdf_ChangleListSubLayerChangeType_SubLayerOffset = 2,
};

/// Validity of an edit.
enum sdf_NamespaceEditDetailResult {
    sdf_NamespaceEditDetailResult_Error = 0,
    sdf_NamespaceEditDetailResult_Unbatched = 1,
    sdf_NamespaceEditDetailResult_Okay = 2,
};

/// An enum that defines permission levels.
/// 
/// Permissions control which layers may refer to or express
/// opinions about a prim.  Opinions expressed about a prim, or
/// relationships to that prim, by layers that are not allowed
/// permission to access the prim will be ignored.
/// 
/// <b>SdfPermission:</b>
/// <ul>
/// <li><b>SdfPermissionPublic.</b> Public prims can be referred to by
///     anything. (Available to any client.)
/// <li><b>SdfPermissionPrivate.</b> Private prims can be referred to
///     only within the local layer stack, and not across references
///     or inherits. (Not available to clients.)
/// <li><b>SdfNumPermission.</b> Internal sentinel value.
/// </ul>
enum sdf_Permission {
    sdf_Permission_SdfPermissionPublic = 0,
    sdf_Permission_SdfPermissionPrivate = 1,
    sdf_Permission_SdfNumPermissions = 2,
};

/// An enum that identifies the possible specifiers for an
/// SdfPrimSpec. The SdfSpecifier enum is registered as a TfEnum
/// for converting to and from <c>std::string</c>.
/// 
/// <b>SdfSpecifier:</b>
/// <ul>
/// <li><b>SdfSpecifierDef.</b> Defines a concrete prim.
/// <li><b>SdfSpecifierOver.</b> Overrides an existing prim.
/// <li><b>SdfSpecifierClass.</b> Defines an abstract prim.
/// <li><b>SdfNumSpecifiers.</b> The number of specifiers.
/// </ul>
enum sdf_Specifier {
    sdf_Specifier_SdfSpecifierDef = 0,
    sdf_Specifier_SdfSpecifierOver = 1,
    sdf_Specifier_SdfSpecifierClass = 2,
    sdf_Specifier_SdfNumSpecifiers = 3,
};

/// An enum that specifies the type of an object. Objects
/// are entities that have fields and are addressable by path.
enum sdf_SpecType {
    sdf_SpecType_SdfSpecTypeUnknown = 0,
    sdf_SpecType_SdfSpecTypeAttribute = 1,
    sdf_SpecType_SdfSpecTypeConnection = 2,
    sdf_SpecType_SdfSpecTypeExpression = 3,
    sdf_SpecType_SdfSpecTypeMapper = 4,
    sdf_SpecType_SdfSpecTypeMapperArg = 5,
    sdf_SpecType_SdfSpecTypePrim = 6,
    sdf_SpecType_SdfSpecTypePseudoRoot = 7,
    sdf_SpecType_SdfSpecTypeRelationship = 8,
    sdf_SpecType_SdfSpecTypeRelationshipTarget = 9,
    sdf_SpecType_SdfSpecTypeVariant = 10,
    sdf_SpecType_SdfSpecTypeVariantSet = 11,
    sdf_SpecType_SdfNumSpecTypes = 12,
};

/// An enum that identifies variability types for attributes.
/// Variability indicates whether the attribute may vary over time and
/// value coordinates, and if its value comes through authoring or
/// or from its owner.
/// 
/// <b>SdfVariability:</b>
/// <ul>
///     <li><b>SdfVariabilityVarying.</b> Varying attributes may be directly 
///            authored, animated and affected on by Actions.  They are the 
///            most flexible.
///     <li><b>SdfVariabilityUniform.</b> Uniform attributes may be authored 
///            only with non-animated values (default values).  They cannot 
///            be affected by Actions, but they can be connected to other 
///            Uniform attributes.
///     <li><b>SdNumVariabilities.</b> Internal sentinel value.
/// </ul>
enum sdf_Variability {
    sdf_Variability_SdfVariabilityVarying = 0,
    sdf_Variability_SdfVariabilityUniform = 1,
    sdf_Variability_SdfNumVariabilities = 2,
};

/// \enum ProtoXformInclusion
/// 
/// Encodes whether to include each prototype's root prim's transformation
/// as the most-local component of computed instance transforms.
enum usdGeom_ProtoXformInclusion {
    usdGeom_ProtoXformInclusion_IncludeProtoXform = 0,
    usdGeom_ProtoXformInclusion_ExcludeProtoXform = 1,
};

/// \enum MaskApplication
/// 
/// Encodes whether to evaluate and apply the PointInstancer's
/// mask to computed results.
/// \sa ComputeMaskAtTime()
enum usdGeom_MaskApplication {
    usdGeom_MaskApplication_ApplyMask = 0,
    usdGeom_MaskApplication_IgnoreMask = 1,
};

/// Enumerates the rotation order of the 3-angle Euler rotation.
enum usdGeom_XformCommonAPIRotationOrder {
    usdGeom_XformCommonAPIRotationOrder_RotationOrderXYZ = 0,
    usdGeom_XformCommonAPIRotationOrder_RotationOrderXZY = 1,
    usdGeom_XformCommonAPIRotationOrder_RotationOrderYXZ = 2,
    usdGeom_XformCommonAPIRotationOrder_RotationOrderYZX = 3,
    usdGeom_XformCommonAPIRotationOrder_RotationOrderZXY = 4,
    usdGeom_XformCommonAPIRotationOrder_RotationOrderZYX = 5,
};

/// Enumerates the categories of ops that can be handled by XformCommonAPI.
/// For use with CreateXformOps().
enum usdGeom_XformCommonAPIOpFlags {
    usdGeom_XformCommonAPIOpFlags_OpNone = 0,
    usdGeom_XformCommonAPIOpFlags_OpTranslate = 1,
    usdGeom_XformCommonAPIOpFlags_OpPivot = 2,
    usdGeom_XformCommonAPIOpFlags_OpRotate = 4,
    usdGeom_XformCommonAPIOpFlags_OpScale = 8,
};

/// Enumerates the set of all transformation operation types.
enum usdGeom_XformOpType {
    usdGeom_XformOpType_TypeInvalid = 0,
    usdGeom_XformOpType_TypeTranslate = 1,
    usdGeom_XformOpType_TypeScale = 2,
    usdGeom_XformOpType_TypeRotateX = 3,
    usdGeom_XformOpType_TypeRotateY = 4,
    usdGeom_XformOpType_TypeRotateZ = 5,
    usdGeom_XformOpType_TypeRotateXYZ = 6,
    usdGeom_XformOpType_TypeRotateXZY = 7,
    usdGeom_XformOpType_TypeRotateYXZ = 8,
    usdGeom_XformOpType_TypeRotateYZX = 9,
    usdGeom_XformOpType_TypeRotateZXY = 10,
    usdGeom_XformOpType_TypeRotateZYX = 11,
    usdGeom_XformOpType_TypeOrient = 12,
    usdGeom_XformOpType_TypeTransform = 13,
};

/// Precision with which the value of the tranformation operation is encoded.
enum usdGeom_XformOpPrecision {
    usdGeom_XformOpPrecision_PrecisionDouble = 0,
    usdGeom_XformOpPrecision_PrecisionFloat = 1,
    usdGeom_XformOpPrecision_PrecisionHalf = 2,
};

/// Choices for filtering composition arcs based on arc type
enum usd_PrimCompositionQueryArcTypeFilter {
    usd_PrimCompositionQueryArcTypeFilter_All = 0,
    usd_PrimCompositionQueryArcTypeFilter_Reference = 1,
    usd_PrimCompositionQueryArcTypeFilter_Payload = 2,
    usd_PrimCompositionQueryArcTypeFilter_Inherit = 3,
    usd_PrimCompositionQueryArcTypeFilter_Specialize = 4,
    usd_PrimCompositionQueryArcTypeFilter_Variant = 5,
    usd_PrimCompositionQueryArcTypeFilter_ReferenceOrPayload = 6,
    usd_PrimCompositionQueryArcTypeFilter_InheritOrSpecialize = 7,
    usd_PrimCompositionQueryArcTypeFilter_NotReferenceOrPayload = 8,
    usd_PrimCompositionQueryArcTypeFilter_NotInheritOrSpecialize = 9,
    usd_PrimCompositionQueryArcTypeFilter_NotVariant = 10,
};

/// Choices for filtering composition arcs based on where the arc is 
/// introduced. 
enum usd_PrimCompositionQueryArcIntroducedFilter {
    usd_PrimCompositionQueryArcIntroducedFilter_All = 0,
    usd_PrimCompositionQueryArcIntroducedFilter_IntroducedInRootLayerStack = 1,
    usd_PrimCompositionQueryArcIntroducedFilter_IntroducedInRootLayerPrimSpec = 2,
};

/// Choices for filtering composition arcs on dependency type. This can
/// be direct (arc introduced at the prim's level in namespace) or ancestral
/// (arc introduced by a namespace parent of the prim).
enum usd_PrimCompositionQueryDependencyTypeFilter {
    usd_PrimCompositionQueryDependencyTypeFilter_All = 0,
    usd_PrimCompositionQueryDependencyTypeFilter_Direct = 1,
    usd_PrimCompositionQueryDependencyTypeFilter_Ancestral = 2,
};

/// Choices for filtering composition arcs on whether the node contributes
/// specs to the prim.
enum usd_PrimCompositionQueryHasSpecsFilter {
    usd_PrimCompositionQueryHasSpecsFilter_All = 0,
    usd_PrimCompositionQueryHasSpecsFilter_HasSpecs = 1,
    usd_PrimCompositionQueryHasSpecsFilter_HasNoSpecs = 2,
};

/// \enum KindValidation
/// 
/// Option for validating queries to a prim's kind metadata.
/// \sa IsKind()
enum usd_ModelAPIKindValidation {
    usd_ModelAPIKindValidation_KindValidationNone = 0,
    usd_ModelAPIKindValidation_KindValidationModelHierarchy = 1,
};

/// \enum UsdInterpolationType
/// 
/// Attribute value interpolation options. 
/// 
/// See \ref Usd_AttributeInterpolation for more details.
enum usd_InterpolationType {
    usd_InterpolationType_UsdInterpolationTypeHeld = 0,
    usd_InterpolationType_UsdInterpolationTypeLinear = 1,
};

/// \enum UsdListPosition
/// 
/// Specifies a position to add items to lists.  Used by some Add()
/// methods in the USD API that manipulate lists, such as AddReference().
enum usd_ListPosition {
    usd_ListPosition_UsdListPositionFrontOfPrependList = 0,
    usd_ListPosition_UsdListPositionBackOfPrependList = 1,
    usd_ListPosition_UsdListPositionFrontOfAppendList = 2,
    usd_ListPosition_UsdListPositionBackOfAppendList = 3,
};

/// \enum UsdLoadPolicy
/// 
/// Controls UsdStage::Load() and UsdPrim::Load() behavior regarding whether or
/// not descendant prims are loaded.
enum usd_LoadPolicy {
    usd_LoadPolicy_UsdLoadWithDescendants = 0,
    usd_LoadPolicy_UsdLoadWithoutDescendants = 1,
};

/// \enum UsdResolveInfoSource
/// 
/// Describes the various sources of attribute values.
/// 
/// For more details, see \ref Usd_ValueResolution.
enum usd_ResolveInfoSource {
    usd_ResolveInfoSource_UsdResolveInfoSourceNone = 0,
    usd_ResolveInfoSource_UsdResolveInfoSourceFallback = 1,
    usd_ResolveInfoSource_UsdResolveInfoSourceDefault = 2,
    usd_ResolveInfoSource_UsdResolveInfoSourceTimeSamples = 3,
    usd_ResolveInfoSource_UsdResolveInfoSourceValueClips = 4,
};

/// A policy for filtering by schema version when querying for schemas in a
/// particular schema family.
enum usd_SchemaRegistryVersionPolicy {
    usd_SchemaRegistryVersionPolicy_All = 0,
    usd_SchemaRegistryVersionPolicy_GreaterThan = 1,
    usd_SchemaRegistryVersionPolicy_GreaterThanOrEqual = 2,
    usd_SchemaRegistryVersionPolicy_LessThan = 3,
    usd_SchemaRegistryVersionPolicy_LessThanOrEqual = 4,
};

/// \enum UsdSchemaKind
/// 
/// An enum representing which kind of schema a given schema class belongs to
enum usd_SchemaKind {
    usd_SchemaKind_Invalid = 0,
    usd_SchemaKind_AbstractBase = 1,
    usd_SchemaKind_AbstractTyped = 2,
    usd_SchemaKind_ConcreteTyped = 3,
    usd_SchemaKind_NonAppliedAPI = 4,
    usd_SchemaKind_SingleApplyAPI = 5,
    usd_SchemaKind_MultipleApplyAPI = 6,
};

/// \enum InitialLoadSet
/// 
/// Specifies the initial set of prims to load when opening a UsdStage.
enum usd_StageInitialLoadSet {
    usd_StageInitialLoadSet_LoadAll = 0,
    usd_StageInitialLoadSet_LoadNone = 1,
};

/// \enum Rule
/// 
/// These values are paired with paths to govern payload inclusion on
/// UsdStages.
enum usd_StageLoadRulesRule {
    usd_StageLoadRulesRule_AllRule = 0,
    usd_StageLoadRulesRule_OnlyRule = 1,
    usd_StageLoadRulesRule_NoneRule = 2,
};


/** structs */

/// \class ArResolverContext
/// 
/// An asset resolver context allows clients to provide additional data
/// to the resolver for use during resolution. Clients may provide this
/// data via context objects of their own (subject to restrictions below).
/// An ArResolverContext is simply a wrapper around these objects that
/// allows it to be treated as a single type. Note that an ArResolverContext
/// may not hold multiple context objects with the same type.
/// 
/// A client-defined context object must provide the following:
///   - Default and copy constructors
///   - operator<
///   - operator==
///   - An overload for size_t hash_value(const T&)
/// 
/// Note that the user may define a free function:
/// 
/// std::string ArGetDebugString(const Context& ctx);
/// (Where Context is the type of the user's path resolver context.)
/// 
/// This is optional; a default generic implementation has been predefined.
/// This function should return a string representation of the context
/// to be utilized for debugging purposes(such as in TF_DEBUG statements).
/// 
/// The ArIsContextObject template must also be specialized for this
/// object to declare that it can be used as a context object. This is to 
/// avoid accidental use of an unexpected object as a context object.
/// The AR_DECLARE_RESOLVER_CONTEXT macro can be used to do this
/// as a convenience.
/// 
/// \sa AR_DECLARE_RESOLVER_CONTEXT
/// \sa ArResolver::BindContext
/// \sa ArResolver::UnbindContext
/// \sa ArResolverContextBinder
typedef struct ar_ResolverContext_t ar_ResolverContext_t;
/// \class GfVec2f
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 2 float components.
/// 
/// Represents a vector of 2 components of type \c float.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(4) gf_Vec2f_t {
    float x;
    float y;
} gf_Vec2f_t;

typedef struct gf_Vec2fArray_t gf_Vec2fArray_t;
/// \class GfVec3f
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 3 float components.
/// 
/// Represents a vector of 3 components of type \c float.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(4) gf_Vec3f_t {
    float x;
    float y;
    float z;
} gf_Vec3f_t;

typedef struct gf_Vec3fArray_t gf_Vec3fArray_t;
typedef struct gf_Vec3fArrayVector_t gf_Vec3fArrayVector_t;
/// \class GfVec4f
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 4 float components.
/// 
/// Represents a vector of 4 components of type \c float.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(4) gf_Vec4f_t {
    float x;
    float y;
    float z;
    float w;
} gf_Vec4f_t;

typedef struct gf_Vec4fArray_t gf_Vec4fArray_t;
typedef struct gf_Vec4fVector_t gf_Vec4fVector_t;
/// \class GfVec2h
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 2 GfHalf components.
/// 
/// Represents a vector of 2 components of type \c GfHalf.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(2) gf_Vec2h_t {
    short x;
    short y;
} gf_Vec2h_t;

typedef struct gf_Vec2hArray_t gf_Vec2hArray_t;
/// \class GfVec3h
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 3 GfHalf components.
/// 
/// Represents a vector of 3 components of type \c GfHalf.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(2) gf_Vec3h_t {
    short x;
    short y;
    short z;
} gf_Vec3h_t;

typedef struct gf_Vec3hArray_t gf_Vec3hArray_t;
/// \class GfVec4h
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 4 GfHalf components.
/// 
/// Represents a vector of 4 components of type \c GfHalf.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(2) gf_Vec4h_t {
    short x;
    short y;
    short z;
    short w;
} gf_Vec4h_t;

typedef struct gf_Vec4hArray_t gf_Vec4hArray_t;
/// \class GfVec2d
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 2 double components.
/// 
/// Represents a vector of 2 components of type \c double.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(8) gf_Vec2d_t {
    double x;
    double y;
} gf_Vec2d_t;

typedef struct gf_Vec2dArray_t gf_Vec2dArray_t;
/// \class GfVec3d
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 3 double components.
/// 
/// Represents a vector of 3 components of type \c double.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(8) gf_Vec3d_t {
    double x;
    double y;
    double z;
} gf_Vec3d_t;

typedef struct gf_Vec3dVector_t gf_Vec3dVector_t;
typedef struct gf_Vec3dArray_t gf_Vec3dArray_t;
/// \class GfVec4d
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 4 double components.
/// 
/// Represents a vector of 4 components of type \c double.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(8) gf_Vec4d_t {
    double x;
    double y;
    double z;
    double w;
} gf_Vec4d_t;

typedef struct gf_Vec4dArray_t gf_Vec4dArray_t;
/// \class GfVec2i
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 2 int components.
/// 
/// Represents a vector of 2 components of type \c int.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(4) gf_Vec2i_t {
    int x;
    int y;
} gf_Vec2i_t;

typedef struct gf_Vec2iArray_t gf_Vec2iArray_t;
/// \class GfVec3i
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 3 int components.
/// 
/// Represents a vector of 3 components of type \c int.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(4) gf_Vec3i_t {
    int x;
    int y;
    int z;
} gf_Vec3i_t;

typedef struct gf_Vec3iArray_t gf_Vec3iArray_t;
/// \class GfVec4i
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type for a vector of 4 int components.
/// 
/// Represents a vector of 4 components of type \c int.
/// It is intended to be fast and simple.
typedef struct BBL_ALIGN(4) gf_Vec4i_t {
    int x;
    int y;
    int z;
    int w;
} gf_Vec4i_t;

typedef struct gf_Vec4iArray_t gf_Vec4iArray_t;
/// \class GfMatrix2d
/// \ingroup group_gf_LinearAlgebra
/// 
/// Stores a 2x2 matrix of \c double elements. A basic type.
/// 
/// Matrices are defined to be in row-major order, so <c>matrix[i][j]</c>
/// indexes the element in the \e i th row and the \e j th column.
typedef struct BBL_ALIGN(8) gf_Matrix2d_t {
    double m[4];
} gf_Matrix2d_t;

typedef struct gf_Matrix2dArray_t gf_Matrix2dArray_t;
/// \class GfMatrix3d
/// \ingroup group_gf_LinearAlgebra
/// 
/// Stores a 3x3 matrix of \c double elements. A basic type.
/// 
/// Matrices are defined to be in row-major order, so <c>matrix[i][j]</c>
/// indexes the element in the \e i th row and the \e j th column.
/// 
/// <h3>3D Transformations</h3>
/// 
/// Three methods, SetRotate(), SetScale(), and ExtractRotation(), interpret
/// a GfMatrix3d as a 3D transformation. By convention, vectors are treated
/// primarily as row vectors, implying the following:
/// 
/// \li Transformation matrices are organized to deal with row
///        vectors, not column vectors.
/// \li Each of the Set() methods in this class completely rewrites the
///        matrix; for example, SetRotate() yields a matrix
///        which does nothing but rotate.
/// \li When multiplying two transformation matrices, the matrix
///        on the left applies a more local transformation to a row
///        vector. For example, if R represents a rotation
///        matrix and S represents a scale matrix, the
///        product R*S  will rotate a row vector, then scale
///        it.
typedef struct BBL_ALIGN(8) gf_Matrix3d_t {
    double m[9];
} gf_Matrix3d_t;

typedef struct gf_Matrix3dArray_t gf_Matrix3dArray_t;
/// \class GfMatrix4d
/// \ingroup group_gf_LinearAlgebra
/// 
/// Stores a 4x4 matrix of \c double elements. A basic type.
/// 
/// Matrices are defined to be in row-major order, so <c>matrix[i][j]</c>
/// indexes the element in the \e i th row and the \e j th column.
/// 
/// <h3>3D Transformations</h3>
/// 
/// The following methods interpret a GfMatrix4d as a 3D
/// transformation: SetRotate(), SetScale(), SetTranslate(), SetLookAt(),
/// Factor(), ExtractTranslation(), ExtractRotation(), Transform(), TransformDir().
/// By convention, vectors are treated primarily as row vectors,
/// implying the following:
/// \li Transformation matrices are organized to deal with row
///        vectors, not column vectors. For example, the last row of a matrix
///        contains the translation amounts.
/// \li Each of the Set() methods below completely rewrites the
///        matrix; for example, SetTranslate() yields a matrix
///        which does nothing but translate.
/// \li When multiplying two transformation matrices, the matrix
///        on the left applies a more local transformation to a row
///        vector. For example, if R represents a rotation
///        matrix and T represents a translation matrix, the
///        product R*T will rotate a row vector, then translate
///        it.
typedef struct BBL_ALIGN(8) gf_Matrix4d_t {
    double m[16];
} gf_Matrix4d_t;

typedef struct gf_Matrix4dArray_t gf_Matrix4dArray_t;
typedef struct gf_Matrix4dArrayVector_t gf_Matrix4dArrayVector_t;
/// \class GfMatrix2f
/// \ingroup group_gf_LinearAlgebra
/// 
/// Stores a 2x2 matrix of \c float elements. A basic type.
/// 
/// Matrices are defined to be in row-major order, so <c>matrix[i][j]</c>
/// indexes the element in the \e i th row and the \e j th column.
typedef struct BBL_ALIGN(4) gf_Matrix2f_t {
    float m[4];
} gf_Matrix2f_t;

typedef struct gf_Matrix2fArray_t gf_Matrix2fArray_t;
/// \class GfMatrix3f
/// \ingroup group_gf_LinearAlgebra
/// 
/// Stores a 3x3 matrix of \c float elements. A basic type.
/// 
/// Matrices are defined to be in row-major order, so <c>matrix[i][j]</c>
/// indexes the element in the \e i th row and the \e j th column.
/// 
/// <h3>3D Transformations</h3>
/// 
/// Three methods, SetRotate(), SetScale(), and ExtractRotation(), interpret
/// a GfMatrix3f as a 3D transformation. By convention, vectors are treated
/// primarily as row vectors, implying the following:
/// 
/// \li Transformation matrices are organized to deal with row
///        vectors, not column vectors.
/// \li Each of the Set() methods in this class completely rewrites the
///        matrix; for example, SetRotate() yields a matrix
///        which does nothing but rotate.
/// \li When multiplying two transformation matrices, the matrix
///        on the left applies a more local transformation to a row
///        vector. For example, if R represents a rotation
///        matrix and S represents a scale matrix, the
///        product R*S  will rotate a row vector, then scale
///        it.
typedef struct BBL_ALIGN(4) gf_Matrix3f_t {
    float m[9];
} gf_Matrix3f_t;

typedef struct gf_Matrix3fArray_t gf_Matrix3fArray_t;
/// \class GfMatrix4f
/// \ingroup group_gf_LinearAlgebra
/// 
/// Stores a 4x4 matrix of \c float elements. A basic type.
/// 
/// Matrices are defined to be in row-major order, so <c>matrix[i][j]</c>
/// indexes the element in the \e i th row and the \e j th column.
/// 
/// <h3>3D Transformations</h3>
/// 
/// The following methods interpret a GfMatrix4f as a 3D
/// transformation: SetRotate(), SetScale(), SetTranslate(), SetLookAt(),
/// Factor(), ExtractTranslation(), ExtractRotation(), Transform(), TransformDir().
/// By convention, vectors are treated primarily as row vectors,
/// implying the following:
/// \li Transformation matrices are organized to deal with row
///        vectors, not column vectors. For example, the last row of a matrix
///        contains the translation amounts.
/// \li Each of the Set() methods below completely rewrites the
///        matrix; for example, SetTranslate() yields a matrix
///        which does nothing but translate.
/// \li When multiplying two transformation matrices, the matrix
///        on the left applies a more local transformation to a row
///        vector. For example, if R represents a rotation
///        matrix and T represents a translation matrix, the
///        product R*T will rotate a row vector, then translate
///        it.
typedef struct BBL_ALIGN(4) gf_Matrix4f_t {
    float m[16];
} gf_Matrix4f_t;

typedef struct gf_Matrix4fArray_t gf_Matrix4fArray_t;
/// \class GfQuatd
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type: a quaternion, a complex number with a real coefficient and
/// three imaginary coefficients, stored as a 3-vector.
typedef struct BBL_ALIGN(8) gf_Quatd_t {
    double x;
    double y;
    double z;
    double w;
} gf_Quatd_t;

typedef struct gf_QuatdArray_t gf_QuatdArray_t;
/// \class GfQuatf
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type: a quaternion, a complex number with a real coefficient and
/// three imaginary coefficients, stored as a 3-vector.
typedef struct BBL_ALIGN(4) gf_Quatf_t {
    float x;
    float y;
    float z;
    float w;
} gf_Quatf_t;

typedef struct gf_QuatfArray_t gf_QuatfArray_t;
/// \class GfQuath
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type: a quaternion, a complex number with a real coefficient and
/// three imaginary coefficients, stored as a 3-vector.
typedef struct BBL_ALIGN(2) gf_Quath_t {
    short x;
    short y;
    short z;
    short w;
} gf_Quath_t;

typedef struct gf_QuathArray_t gf_QuathArray_t;
/// \class GfInterval
/// \ingroup group_gf_BasicMath
/// 
/// A basic mathematical interval class.
/// 
/// Can represent intervals with either open or closed boundary
/// conditions.
typedef struct BBL_ALIGN(8) gf_Interval_t {
    char _bbl_opaque[32];
} gf_Interval_t;

/// \class GfBBox3d
/// \ingroup group_gf_BasicGeometry
/// Basic type: arbitrarily oriented 3D bounding box.
/// 
/// This class represents a three-dimensional bounding box as an
/// axis-aligned box (\c GfRange3d) and a matrix (\c GfMatrix4d) to
/// transform it into the correct space.
/// 
/// A \c GfBBox3d is more useful than using just \c GfRange3d instances
/// (which are always axis-aligned) for these reasons:
/// 
/// \li When an axis-aligned bounding box is transformed several times,
/// each transformation can result in inordinate growth of the bounding
/// box. By storing the transformation separately, it can be applied once
/// at the end, resulting in a much better fit.  For example, if the
/// bounding box at the leaf of a scene graph is transformed through
/// several levels of the graph hierarchy to the coordinate space at the
/// root, a \c GfBBox3d is generally much smaller than the \c GfRange3d
/// computed by transforming the box at each level.
/// 
/// \li When two or more such bounding boxes are combined, having the
/// transformations stored separately means that there is a better
/// opportunity to choose a better coordinate space in which to combine
/// the boxes.
/// 
/// \anchor bbox3d_zeroAreaFlag
/// <b> The Zero-area Primitives Flag </b>
/// 
/// When bounding boxes are used in intersection test culling, it is
/// sometimes useful to extend them a little bit to allow
/// lower-dimensional objects with zero area, such as lines and points,
/// to be intersected. For example, consider a cube constructed of line
/// segments. The bounding box for this shape fits the cube exactly. If
/// an application wants to allow a near-miss of the silhouette edges of
/// the cube to be considered an intersection, it has to loosen the bbox
/// culling test a little bit.
/// 
/// To distinguish when this loosening is necessary, each \c GfBBox3d
/// instance maintains a flag indicating whether any zero-area primitives
/// are contained within it. The application is responsible for setting
/// this flag correctly by calling \c SetHasZeroAreaPrimitives(). The
/// flag can be accessed during intersection tests by calling \c
/// HasZeroAreaPrimitives(). This flag is set by default in all
/// constructors to \c false.
typedef struct gf_BBox3d_t gf_BBox3d_t;
/// \class GfRange1d
/// \ingroup group_gf_BasicGeometry
/// 
/// Basic type: 1-dimensional floating point range.
/// 
/// This class represents a 1-dimensional range (or interval) All
/// operations are component-wise and conform to interval mathematics. An
/// empty range is one where max < min.
/// The default empty is [FLT_MAX,-FLT_MAX]
typedef struct BBL_ALIGN(8) gf_Range1d_t {
    double mn;
    double mx;
} gf_Range1d_t;

/// \class GfRange1f
/// \ingroup group_gf_BasicGeometry
/// 
/// Basic type: 1-dimensional floating point range.
/// 
/// This class represents a 1-dimensional range (or interval) All
/// operations are component-wise and conform to interval mathematics. An
/// empty range is one where max < min.
/// The default empty is [FLT_MAX,-FLT_MAX]
typedef struct BBL_ALIGN(4) gf_Range1f_t {
    float mn;
    float mx;
} gf_Range1f_t;

/// \class GfRange2d
/// \ingroup group_gf_BasicGeometry
/// 
/// Basic type: 2-dimensional floating point range.
/// 
/// This class represents a 2-dimensional range (or interval) All
/// operations are component-wise and conform to interval mathematics. An
/// empty range is one where max < min.
/// The default empty is [FLT_MAX,-FLT_MAX]
typedef struct BBL_ALIGN(8) gf_Range2d_t {
    gf_Vec2d_t mn;
    gf_Vec2d_t mx;
} gf_Range2d_t;

/// \class GfRange2f
/// \ingroup group_gf_BasicGeometry
/// 
/// Basic type: 2-dimensional floating point range.
/// 
/// This class represents a 2-dimensional range (or interval) All
/// operations are component-wise and conform to interval mathematics. An
/// empty range is one where max < min.
/// The default empty is [FLT_MAX,-FLT_MAX]
typedef struct BBL_ALIGN(4) gf_Range2f_t {
    gf_Vec2f_t mn;
    gf_Vec2f_t mx;
} gf_Range2f_t;

/// \class GfRange3d
/// \ingroup group_gf_BasicGeometry
/// 
/// Basic type: 3-dimensional floating point range.
/// 
/// This class represents a 3-dimensional range (or interval) All
/// operations are component-wise and conform to interval mathematics. An
/// empty range is one where max < min.
/// The default empty is [FLT_MAX,-FLT_MAX]
typedef struct BBL_ALIGN(8) gf_Range3d_t {
    gf_Vec3d_t mn;
    gf_Vec3d_t mx;
} gf_Range3d_t;

/// \class GfRange3f
/// \ingroup group_gf_BasicGeometry
/// 
/// Basic type: 3-dimensional floating point range.
/// 
/// This class represents a 3-dimensional range (or interval) All
/// operations are component-wise and conform to interval mathematics. An
/// empty range is one where max < min.
/// The default empty is [FLT_MAX,-FLT_MAX]
typedef struct BBL_ALIGN(4) gf_Range3f_t {
    gf_Vec3f_t mn;
    gf_Vec3f_t mx;
} gf_Range3f_t;

/// \class GfCamera
/// \ingroup group_gf_BasicGeometry
/// \brief Object-based representation of a camera.
/// 
/// This class provides a thin wrapper on the camera data model,
/// with a small number of computations.
typedef struct gf_Camera_t gf_Camera_t;
/// \class GfFrustum
/// \ingroup group_gf_BasicGeometry
/// 
/// Basic type: View frustum.
/// 
/// This class represents a viewing frustum in three dimensional eye space. It
/// may represent either a parallel (orthographic) or perspective projection.
/// One can think of the frustum as being defined by 6 boundary planes.
/// 
/// The frustum is specified using these parameters:
///  \li The \em position of the viewpoint.
///  \li The \em rotation applied to the default view frame, which is
///      looking along the -z axis with the +y axis as the "up"
///      direction.
///  \li The 2D \em window on the reference plane that defines the left,
///      right, top, and bottom planes of the viewing frustum, as
///      described below.
///  \li The distances to the \em near and \em far planes.
///  \li The \em projection \em type
///  \li The view distance.
/// 
/// The window and near/far parameters combine to define the view frustum as
/// follows. Transform the -z axis and the +y axis by the frustum rotation to
/// get the world-space \em view \em direction and \em up \em direction. Now
/// consider the \em reference \em plane that is perpendicular to the view
/// direction, a distance of referencePlaneDepth from the viewpoint, and whose
/// y axis corresponds to the up direction.  The window rectangle is specified
/// in a 2D coordinate system embedded in this plane. The origin of the
/// coordinate system is the point at which the view direction vector
/// intersects the plane. Therefore, the point (0,1) in this plane is found by
/// moving 1 unit along the up direction vector in this plane. The vector from
/// the viewpoint to the resulting point will form a 45-degree angle with the
/// view direction.
/// 
/// The view distance is only useful for interactive applications. It can be
/// used to compute a look at point which is useful when rotating around an
/// object of interest.
typedef struct gf_Frustum_t gf_Frustum_t;
/// \class GfRay
/// \ingroup group_gf_BasicGeometry
/// 
/// Basic type: Ray used for intersection testing
/// 
/// This class represents a three-dimensional ray in space, typically
/// used for intersection testing. It consists of an origin and a
/// direction.
/// 
/// Note that by default a \c GfRay does not normalize its direction
/// vector to unit length.
/// 
/// Note for ray intersections, the start point is included in the computations, 
/// i.e., a distance of zero is defined to be intersecting.
typedef struct BBL_ALIGN(8) gf_Ray_t {
    gf_Vec3d_t startPoint;
    gf_Vec3d_t direction;
} gf_Ray_t;

/// \class GfRotation
/// \ingroup group_gf_LinearAlgebra
/// 
/// Basic type: 3-space rotation specification.
/// 
/// This class represents a rotation in 3-space. This stores an axis as a
/// normalized vector of 3 \c doubles and an angle in degrees (as a double).
/// Rotations follow the right-hand rule: a positive rotation about an axis
/// vector appears counter-clockwise when looking from the end of the vector
/// toward the origin.
typedef struct BBL_ALIGN(8) gf_Rotation_t {
    gf_Vec3d_t axis;
    double angle;
} gf_Rotation_t;

typedef struct js_Array_t js_Array_t;
typedef struct js_Object_t js_Object_t;
/// \class JsValue
/// 
/// A discriminated union type for JSON values. A JsValue may contain one of
/// the following types:
/// 
/// \li JsObject, a dictionary type
/// \li JsArray, a vector type
/// \li std::string
/// \li bool
/// \li int64_t
/// \li uint64_t
/// \li double
/// \li null
typedef struct js_Value_t js_Value_t;
/// \class PcpMapFunction
/// 
/// A function that maps values from one namespace (and time domain) to
/// another. It represents the transformation that an arc such as a reference
/// arc applies as it incorporates values across the arc.
/// 
/// Take the example of a reference arc, where a source path
/// \</Model\> is referenced as a target path, \</Model_1\>.
/// The source path \</Model\> is the source of the opinions;
/// the target path \</Model_1\> is where they are incorporated in the scene.
/// Values in the model that refer to paths relative to \</Model\> must be
/// transformed to be relative to \</Model_1\> instead.
/// The PcpMapFunction for the arc provides this service.
/// 
/// Map functions have a specific \em domain, or set of values they can
/// operate on.  Any values outside the domain cannot be mapped.
/// The domain precisely tracks what areas of namespace can be
/// referred to across various forms of arcs.
/// 
/// Map functions can be chained to represent a series of map
/// operations applied in sequence.  The map function represent the
/// cumulative effect as efficiently as possible.  For example, in
/// the case of a chained reference from \</Model\> to \</Model\>
/// to \</Model\> to \</Model_1\>, this is effectively the same as
/// a mapping directly from \</Model\> to \</Model_1\>.  Representing
/// the cumulative effect of arcs in this way is important for
/// handling larger scenes efficiently.
/// 
/// Map functions can be \em inverted. Formally, map functions are
/// bijections (one-to-one and onto), which ensures that they can
/// be inverted.  Put differently, no information is lost by applying
/// a map function to set of values within its domain; they retain
/// their distinct identities and can always be mapped back.
/// 
/// One analogy that may or may not be helpful:
/// In the same way a geometric transform maps a model's points in its
/// rest space into the world coordinates for a particular instance,
/// a PcpMapFunction maps values about a referenced model into the
/// composed scene for a particular instance of that model. But rather
/// than translating and rotating points, the map function shifts the
/// values in namespace (and time).
typedef struct pcp_MapFunction_t pcp_MapFunction_t;
/// \class PcpNodeRef
/// 
/// PcpNode represents a node in an expression tree for compositing
/// scene description.
/// 
/// A node represents the opinions from a particular site.  In addition,
/// it may have child nodes, representing nested expressions that are
/// composited over/under this node.
/// 
/// Child nodes are stored and composited in strength order.
/// 
/// Each node holds information about the arc to its parent.
/// This captures both the relative strength of the sub-expression
/// as well as any value-mapping needed, such as to rename opinions
/// from a model to use in a particular instance.
typedef struct pcp_NodeRef_t pcp_NodeRef_t;
typedef struct pcp_MapFunctionPathMap_t pcp_MapFunctionPathMap_t;
/// \class PcpPrimIndex
/// 
/// PcpPrimIndex is an index of the all sites of scene description that
/// contribute opinions to a specific prim, under composition
/// semantics.
/// 
/// PcpComputePrimIndex() builds an index ("indexes") the given prim site.
/// At any site there may be scene description values expressing arcs
/// that represent instructions to pull in further scene description.
/// PcpComputePrimIndex() recursively follows these arcs, building and
/// ordering the results.
typedef struct pcp_PrimIndex_t pcp_PrimIndex_t;
typedef struct pcp_VariantFallbackMap_t pcp_VariantFallbackMap_t;
/// \class SdfAllowed
/// 
/// Indicates if an operation is allowed and, if not, why not.
/// 
/// A \c SdfAllowed either evaluates to \c true in a boolean context
/// or evaluates to \c false and has a string annotation.
typedef struct sdf_Allowed_t sdf_Allowed_t;
/// \class SdfAssetPath
/// 
/// Contains an asset path and an optional resolved path.  Asset paths may
/// contain non-control UTF-8 encoded characters.  Specifically, U+0000..U+001F
/// (C0 controls), U+007F (delete), and U+0080..U+009F (C1 controls) are
/// disallowed.  Attempts to construct asset paths with such characters will
/// issue a TfError and produce the default-constructed empty asset path.
typedef struct sdf_AssetPath_t sdf_AssetPath_t;
typedef struct sdf_AssetPathArray_t sdf_AssetPathArray_t;
/// \class SdfAttributeSpec
/// 
/// A subclass of SdfPropertySpec that holds typed data.
/// 
/// Attributes are typed data containers that can optionally hold any
/// and all of the following:
/// \li A single default value.
/// \li An array of knot values describing how the value varies over time.
/// \li A dictionary of posed values, indexed by name.
/// 
/// The values contained in an attribute must all be of the same type.  In the
/// Python API the \c typeName property holds the attribute type.  In the C++
/// API, you can get the attribute type using the GetTypeName() method.  In
/// addition, all values, including all knot values, must be the same shape.
/// For information on shapes, see the VtShape class reference in the C++
/// documentation.
typedef struct sdf_AttributeSpec_t sdf_AttributeSpec_t;
typedef struct sdf_AttributeSpecHandle_t sdf_AttributeSpecHandle_t;
typedef struct sdf_AttributeSpecHandleVector_t sdf_AttributeSpecHandleVector_t;
typedef struct sdf_AttributeSpecView_t sdf_AttributeSpecView_t;
/// \class SdfBatchNamespaceEdit
/// 
/// A description of an arbitrarily complex namespace edit.
/// 
/// A \c SdfBatchNamespaceEdit object describes zero or more namespace edits.
/// Various types providing a namespace will allow the edits to be applied
/// in a single operation and also allow testing if this will work.
/// 
/// Clients are encouraged to group several edits into one object because
/// that may allow more efficient processing of the edits.  If, for example,
/// you need to reparent several prims it may be faster to add all of the
/// reparents to a single \c SdfBatchNamespaceEdit and apply them at once
/// than to apply each separately.
/// 
/// Objects that allow applying edits are free to apply the edits in any way
/// and any order they see fit but they should guarantee that the resulting
/// namespace will be as if each edit was applied one at a time in the order
/// they were added.
/// 
/// Note that the above rule permits skipping edits that have no effect or
/// generate a non-final state.  For example, if renaming A to B then to C
/// we could just rename A to C.  This means notices may be elided.  However,
/// implementations must not elide notices that contain information about any
/// edit that clients must be able to know but otherwise cannot determine.
typedef struct sdf_BatchNamespaceEdit_t sdf_BatchNamespaceEdit_t;
/// \class SdfChangeBlock
/// 
/// <b>DANGER DANGER DANGER</b>
/// 
/// Please make sure you have read and fully understand the
/// issues below before using a changeblock!  They are very
/// easy to use in an unsafe way that could make the system
/// crash or corrupt data.  If you have any questions, please
/// contact the USD team, who would be happy to help!
/// 
/// SdfChangeBlock provides a way to group a round of related changes to
/// scene description in order to process them more efficiently.
/// 
/// Normally, Sdf sends notification immediately as changes are made so
/// that downstream representations like UsdStage can update accordingly.
/// 
/// However, sometimes it can be advantageous to group a series of Sdf
/// changes into a batch so that they can be processed more efficiently,
/// with a single round of change processing.  An example might be when
/// setting many avar values on a model at the same time.
/// 
/// Opening a changeblock tells Sdf to delay sending notification about
/// changes until the outermost changeblock is exited.  Until then,
/// Sdf internally queues up the notification it needs to send.
/// 
/// \note  It is *not* safe to use Usd or other downstream API
/// while a changeblock is open!!  This is because those derived
/// representations will not have had a chance to update while the
/// changeblock is open.  Not only will their view of the world be
/// stale, it could be unsafe to even make queries from, since they
/// may be holding onto expired handles to Sdf objects that no longer
/// exist.
/// 
/// If you need to make a bunch of changes to scene description,
/// the best approach is to build a list of necessary changes that
/// can be performed directly via the Sdf API, then submit those all
/// inside a changeblock without talking to any downstream libraries.
/// For example, this is how many mutators in Usd that operate on more 
/// than one field or Spec work.
typedef struct sdf_ChangeBlock_t sdf_ChangeBlock_t;
/// \class SdfChangeList
/// 
/// A list of scene description modifications, organized by the namespace
/// paths where the changes occur.
typedef struct sdf_ChangeList_t sdf_ChangeList_t;
/// \struct Entry
/// 
/// Entry of changes at a single path in namespace.
/// 
/// If the path is SdfPath::AbsoluteRootPath(), that indicates a change
/// to the root of namespace (that is, a layer or stage).
/// 
/// Note: Our language for invalidation used to be more precise
/// about items added, removed, or reordered.  It might seem that
/// this would afford more opportunities for efficient updates,
/// but in practice it does not.  Because our derived data typically
/// must recompose or reinstantiate based on the underlying data,
/// the particular delta might be ignored, overridden, or invalid.
/// It is simpler to treat all changes identically, and focus on 
/// making the common base case fast, rather than have complicated
/// differential update logic.  It also vastly simplifies the
/// language of invalidation.
typedef struct sdf_ChangeListEntry_t sdf_ChangeListEntry_t;
typedef struct sdf_PathChangeListEntryPair_t sdf_PathChangeListEntryPair_t;
typedef struct sdf_ChangeListEntryList_t sdf_ChangeListEntryList_t;
typedef struct sdf_DictionaryProxy_t sdf_DictionaryProxy_t;
/// \class SdfFileFormat
/// 
/// Base class for file format implementations.
typedef struct sdf_FileFormat_t sdf_FileFormat_t;
typedef struct sdf_InheritsProxy_t sdf_InheritsProxy_t;
typedef struct sdf_LayerFileFormatArguments_t sdf_LayerFileFormatArguments_t;
/// \class SdfLayer 
/// 
/// A scene description container that can combine with other such containers
/// to form simple component assets, and successively larger aggregates.  The
/// contents of an SdfLayer adhere to the SdfData data model.  A layer can be
/// ephemeral, or be an asset accessed and serialized through the ArAsset and
/// ArResolver interfaces.
/// 
/// The SdfLayer class provides a consistent API for accesing and serializing
/// scene description, using any data store provided by Ar plugins.  Sdf
/// itself provides a UTF-8 text format for layers identified by the ".sdf"
/// identifier extension, but via the SdfFileFormat abstraction, allows
/// downstream modules and plugins to adapt arbitrary data formats to the
/// SdfData/SdfLayer model.
/// 
/// The FindOrOpen() method returns a new SdfLayer object with scene
/// description from any supported asset format. Once read, a layer
/// remembers which asset it was read from. The Save() method saves the layer
/// back out to the original asset.  You can use the Export() method to write
/// the layer to a different location. You can use the GetIdentifier() method
/// to get the layer's Id or GetRealPath() to get the resolved, full URI.
/// 
/// Layers can have a timeCode range (startTimeCode and endTimeCode). This range
/// represents the suggested playback range, but has no impact on the extent of 
/// the animation data that may be stored in the layer. The metadatum 
/// "timeCodesPerSecond" is used to annotate how the time ordinate for samples
/// contained in the file scales to seconds. For example, if timeCodesPerSecond
/// is 24, then a sample at time ordinate 24 should be viewed exactly one second
/// after the sample at time ordinate 0.
typedef struct sdf_Layer_t sdf_Layer_t;
typedef struct sdf_LayerHandle_t sdf_LayerHandle_t;
typedef struct sdf_LayerHandleVector_t sdf_LayerHandleVector_t;
/// \class SdfLayerOffset 
/// 
/// Represents a time offset and scale between layers.
/// 
/// The SdfLayerOffset class is an affine transform, providing both a scale and
/// a translate.  It supports vector algebra semantics for composing
/// SdfLayerOffsets together via multiplication.  The SdfLayerOffset class is 
/// unitless: it does not refer to seconds or frames.
/// 
/// For example, suppose layer A uses layer B, with an offset of X:  
/// when bringing animation from B into A, you first apply the scale of X, and 
/// then the offset.  Suppose you have a scale of 2 and an offset of 24: 
/// first multiply B's frame numbers by 2, and then add 24.  The animation from 
/// B as seen in A will take twice as long and start 24 frames later.
/// 
/// Offsets are typically used in either sublayers or prim references. For more 
/// information, see the SetSubLayerOffset() method of the SdfLayer class (the 
/// subLayerOffsets property in Python), as well as the SetReference() and 
/// GetReferenceLayerOffset() methods (the latter is the referenceLayerOffset 
/// property in Python) of the SdfPrimSpec class.
typedef struct sdf_LayerOffset_t sdf_LayerOffset_t;
typedef struct sdf_LayerOffsetVector_t sdf_LayerOffsetVector_t;
typedef struct sdf_LayerRefPtr_t sdf_LayerRefPtr_t;
/// \class SdfLayerTree
/// 
/// A SdfLayerTree is an immutable tree structure representing a sublayer
/// stack and its recursive structure.
/// 
/// Layers can have sublayers, which can in turn have sublayers of their
/// own.  Clients that want to represent that hierarchical structure in
/// memory can build a SdfLayerTree for that purpose.
/// 
/// We use TfRefPtr<SdfLayerTree> as handles to LayerTrees, as a simple way
/// to pass them around as immutable trees without worrying about lifetime.
typedef struct sdf_LayerTree_t sdf_LayerTree_t;
typedef struct sdf_LayerTreeHandle_t sdf_LayerTreeHandle_t;
typedef struct sdf_LayerTreeHandleVector_t sdf_LayerTreeHandleVector_t;
typedef struct sdf_StringListOp_t sdf_StringListOp_t;
typedef struct sdf_NameChildrenOrderProxy_t sdf_NameChildrenOrderProxy_t;
typedef struct sdf_NameEditorProxy_t sdf_NameEditorProxy_t;
/// \class SdfNamespaceEdit
/// 
/// A single namespace edit.  It supports renaming, reparenting, reparenting
/// with a rename, reordering, and removal.
typedef struct sdf_NamespaceEdit_t sdf_NamespaceEdit_t;
typedef struct sdf_NamespaceEditVector_t sdf_NamespaceEditVector_t;
/// \struct SdfNamespaceEditDetail
/// 
/// Detailed information about a namespace edit.
typedef struct sdf_NamespaceEditDetail_t sdf_NamespaceEditDetail_t;
typedef struct sdf_NamespaceEditDetailVector_t sdf_NamespaceEditDetailVector_t;
/// \class Base
/// 
/// Base notification class for scene.  Only useful for type hierarchy
/// purposes.
typedef struct sdf_NoticeBase_t sdf_NoticeBase_t;
/// \class BaseLayersDidChange
/// 
/// Base class for LayersDidChange and LayersDidChangeSentPerLayer.
typedef struct sdf_NoticeBaseLayersDidChange_t sdf_NoticeBaseLayersDidChange_t;
/// \class LayerDidReloadContent
/// Sent after a layer is reloaded.
typedef struct sdf_NoticeLayerDidReloadContent_t sdf_NoticeLayerDidReloadContent_t;
/// \class LayerDidReplaceContent
/// 
/// Sent after a layer has been loaded from a file.
typedef struct sdf_NoticeLayerDidReplaceContent_t sdf_NoticeLayerDidReplaceContent_t;
/// \class LayerDidSaveLayerToFile
/// 
/// Sent after a layer is saved to file.
typedef struct sdf_NoticeLayerDidSaveLayerToFile_t sdf_NoticeLayerDidSaveLayerToFile_t;
/// \class LayerIdentifierDidChange
/// 
/// Sent when the identifier of a layer has changed.
typedef struct sdf_NoticeLayerIdentifierDidChange_t sdf_NoticeLayerIdentifierDidChange_t;
/// \class LayerInfoDidChange
/// 
/// Sent when the (scene spec) info of a layer have changed.
typedef struct sdf_NoticeLayerInfoDidChange_t sdf_NoticeLayerInfoDidChange_t;
/// \class LayerMutenessChanged
/// 
/// Sent after a layer has been added or removed from the set of
/// muted layers. Note this does not necessarily mean the specified
/// layer is currently loaded.
typedef struct sdf_NoticeLayerMutenessChanged_t sdf_NoticeLayerMutenessChanged_t;
/// \class LayersDidChange
/// 
/// Global notice sent to indicate that layer contents have changed.
typedef struct sdf_NoticeLayersDidChange_t sdf_NoticeLayersDidChange_t;
/// \class LayersDidChangeSentPerLayer
/// 
/// Notice sent per-layer indicating all layers whose contents have changed
/// within a single round of change processing.  If more than one layer
/// changes in a single round of change processing, we send this notice once
/// per layer with the same changeVec and serialNumber.  This is so clients
/// can listen to notices from only the set of layers they care about rather
/// than listening to the global LayersDidChange notice.
typedef struct sdf_NoticeLayersDidChangeSentPerLayer_t sdf_NoticeLayersDidChangeSentPerLayer_t;
/// \class SdfPath 
/// 
/// A path value used to locate objects in layers or scenegraphs.
/// 
/// \section sec_SdfPath_Overview Overview
/// 
/// SdfPath is used in several ways:
/// \li As a storage key for addressing and accessing values held in a SdfLayer
/// \li As a namespace identity for scenegraph objects
/// \li As a way to refer to other scenegraph objects through relative paths
/// 
/// The paths represented by an SdfPath class may be either relative or
/// absolute.  Relative paths are relative to the prim object that contains them
/// (that is, if an SdfRelationshipSpec target is relative, it is relative to
/// the SdfPrimSpec object that owns the SdfRelationshipSpec object).
/// 
/// SdfPath objects can be readily created from and converted back to strings,
/// but as SdfPath objects, they have behaviors that make it easy and efficient
/// to work with them. The SdfPath class provides a full range of methods for
/// manipulating scene paths by appending a namespace child, appending a
/// relationship target, getting the parent path,
/// and so on.  Since the SdfPath class uses a node-based representation
/// internally, you should use the editing functions rather than converting to
/// and from strings if possible.
/// 
/// \section sec_SdfPath_Syntax Path Syntax
/// 
/// Like a filesystem path, an SdfPath is conceptually just a sequence of
/// path components.  Unlike a filesystem path, each component has a type,
/// and the type is indicated by the syntax.
/// 
/// Two separators are used between parts of a path. A slash ("/") following an
/// identifier is used to introduce a namespace child. A period (".") following
/// an identifier is used to introduce a property.  A property may also have
/// several non-sequential colons (':') in its name to provide a rudimentary
/// namespace within properties but may not end or begin with a colon.
/// 
/// A leading slash in the string representation of an SdfPath object indicates
/// an absolute path.  Two adjacent periods indicate the parent namespace.
/// 
/// Brackets ("[" and "]") are used to indicate relationship target paths for
/// relational attributes.
/// 
/// The first part in a path is assumed to be a namespace child unless
/// it is preceded by a period.  That means:
/// \li <c>/Foo</c> is an absolute path specifying the root prim Foo.
/// \li <c>/Foo/Bar</c> is an absolute path specifying namespace child Bar
///     of root prim Foo.
/// \li <c>/Foo/Bar.baz</c> is an absolute path specifying property \c baz of
///     namespace child Bar of root prim Foo.
/// \li <c>Foo</c> is a relative path specifying namespace child Foo of
///     the current prim.
/// \li <c>Foo/Bar</c> is a relative path specifying namespace child Bar of
///     namespace child Foo of the current prim.
/// \li <c>Foo/Bar.baz</c> is a relative path specifying property \c baz of
///     namespace child Bar of namespace child Foo of the current prim.
/// \li <c>.foo</c> is a relative path specifying the property \c foo of the
///     current prim.
/// \li <c>/Foo.bar[/Foo.baz].attrib</c> is a relational attribute path. The
///     relationship <c>/Foo.bar</c> has a target <c>/Foo.baz</c>. There is a
///     relational attribute \c attrib on that relationship-&gt;target pair.
/// 
/// \section sec_SdfPath_ThreadSafety A Note on Thread-Safety
/// 
/// SdfPath is strongly thread-safe, in the sense that zero additional
/// synchronization is required between threads creating or using SdfPath
/// values. Just like TfToken, SdfPath values are immutable. Internally,
/// SdfPath uses a global prefix tree to efficiently share representations
/// of paths, and provide fast equality/hashing operations, but
/// modifications to this table are internally synchronized. Consequently,
/// as with TfToken, for best performance it is important to minimize
/// the number of values created (since it requires synchronized access to
/// this table) or copied (since it requires atomic ref-counting operations).
typedef struct sdf_Path_t sdf_Path_t;
/// \class SdfPathExpression
/// 
/// Objects of this class represent a logical expression syntax tree consisting
/// of SdfPath matching patterns (with optionally embedded predicate
/// expressions) joined by the set-algebraic operators '+' (union), '&'
/// (intersection), '-' (difference), '~' (complement) and an implied-union
/// operator represented by two subexpressions joined by whitespace.
/// 
/// An SdfPathExpression can be constructed from a string, which will parse the
/// string into an expression object.  The syntax for an expression is as
/// follows:
/// 
/// The fundamental building blocks are path patterns and expression references.
/// A path pattern is similar to an SdfPath, but it may contain glob-style
/// wild-card characters, embedded brace-enclosed predicate expressions (see
/// SdfPredicateExpression) and '//' elements indicating arbitrary levels of
/// prim hierarchy.  For example, consider "/foo//bar*/baz{active:false}".  This
/// pattern matches absolute paths whose first component is 'foo', that also
/// have some descendant prim whose name begins with 'bar', which in turn has a
/// child named 'baz' where the predicate "active:false" evaluates to true.
/// 
/// An expression reference starts with '%' followed by a prim path, a ':', and
/// a name.  There is also one "special" expression reference, "%_" which means
/// "the weaker" expression when composing expressions together.  See
/// ComposeOver() and ResolveReferences() for more information.
/// 
/// These building blocks may be joined as mentioned above, with '+', '-', '&',
/// or whitespace, and may be complemented with '~', and grouped with '(' and
/// ')'.
typedef struct sdf_PathExpression_t sdf_PathExpression_t;
typedef struct sdf_PathSet_t sdf_PathSet_t;
typedef struct sdf_PathVector_t sdf_PathVector_t;
/// \class SdfPayload
/// 
/// Represents a payload and all its meta data.
/// 
/// A payload represents a prim reference to an external layer.  A payload
/// is similar to a prim reference (see SdfReference) with the major
/// difference that payloads are explicitly loaded by the user.
/// 
/// Unloaded payloads represent a boundary that lazy composition and
/// system behaviors will not traverse across, providing a user-visible
/// way to manage the working set of the scene.
typedef struct sdf_Payload_t sdf_Payload_t;
typedef struct sdf_PayloadEditorProxy_t sdf_PayloadEditorProxy_t;
typedef struct sdf_PayloadVector_t sdf_PayloadVector_t;
/// \class SdfPrimSpec
/// 
/// Represents a prim description in an SdfLayer object.
/// 
/// Every SdfPrimSpec object is defined in a layer.  It is identified by its
/// path (SdfPath class) in the namespace hierarchy of its layer.  SdfPrimSpecs
/// can be created using the New() method as children of either the containing
/// SdfLayer itself (for "root level" prims), or as children of other 
/// SdfPrimSpec objects to extend a hierarchy.  The helper function 
/// SdfCreatePrimInLayer() can be used to quickly create a hierarchy of
/// primSpecs.
/// 
/// SdfPrimSpec objects have properties of two general types: attributes
/// (containing values) and relationships (different types of connections to
/// other prims and attributes).  Attributes are represented by the
/// SdfAttributeSpec class and relationships by the SdfRelationshipSpec class.
/// Each prim has its own namespace of properties.  Properties are stored and
/// accessed by their name.
/// 
/// SdfPrimSpec objects have a typeName, permission restriction, and they
/// reference and inherit prim paths.  Permission restrictions control which
/// other layers may refer to, or express opinions about a prim. See the
/// SdfPermission class for more information.
/// 
/// \todo
/// \li Insert doc about references and inherits here.
/// \li Should have validate... methods for name, children, properties
typedef struct sdf_PrimSpec_t sdf_PrimSpec_t;
typedef struct sdf_PrimSpecHandle_t sdf_PrimSpecHandle_t;
typedef struct sdf_PrimSpecHandleVector_t sdf_PrimSpecHandleVector_t;
typedef struct sdf_PrimSpecHandleOffsetPair_t sdf_PrimSpecHandleOffsetPair_t;
typedef struct sdf_PrimSpecHandleOffsetPairVector_t sdf_PrimSpecHandleOffsetPairVector_t;
typedef struct sdf_PrimSpecView_t sdf_PrimSpecView_t;
/// \class SdfPropertySpec
/// 
/// Base class for SdfAttributeSpec and SdfRelationshipSpec.
/// 
/// Scene Spec Attributes (SdfAttributeSpec) and Relationships
/// (SdfRelationshipSpec) are the basic properties that make up Scene Spec Prims
/// (SdfPrimSpec).  They share many qualities and can sometimes be treated
/// uniformly.  The common qualities are provided by this base class.
/// 
/// NOTE: Do not use Python reserved words and keywords as attribute names.
/// This will cause attribute resolution to fail.
typedef struct sdf_PropertySpec_t sdf_PropertySpec_t;
typedef struct sdf_PropertySpecHandle_t sdf_PropertySpecHandle_t;
typedef struct sdf_PropertySpecHandleVector_t sdf_PropertySpecHandleVector_t;
typedef struct sdf_PropertySpecHandleOffsetPair_t sdf_PropertySpecHandleOffsetPair_t;
typedef struct sdf_PropertySpecHandleOffsetPairVector_t sdf_PropertySpecHandleOffsetPairVector_t;
typedef struct sdf_PropertySpecView_t sdf_PropertySpecView_t;
/// \class SdfReference
/// 
/// Represents a reference and all its meta data.
/// 
/// A reference is expressed on a prim in a given layer and it identifies a
/// prim in a layer stack.  All opinions in the namespace hierarchy
/// under the referenced prim will be composed with the opinions in the
/// namespace hierarchy under the referencing prim.
/// 
/// The asset path specifies the layer stack being referenced.  If this
/// asset path is non-empty, this reference is considered an 'external' 
/// reference to the layer stack rooted at the specified layer.  If this
/// is empty, this reference is considered an 'internal' reference to the
/// layer stack containing (but not necessarily rooted at) the layer where
/// the reference is authored.
/// 
/// The prim path specifies the prim in the referenced layer stack from
/// which opinions will be composed.  If this prim path is empty, it will
/// be considered a reference to the default prim specified in the root layer
/// of the referenced layer stack -- see SdfLayer::GetDefaultPrim.
/// 
/// The meta data for a reference is its layer offset and custom data.  The
/// layer offset is an affine transformation applied to all anim splines in
/// the referenced prim's namespace hierarchy, see SdfLayerOffset for details.
/// Custom data is for use by plugins or other non-tools supplied extensions
/// that need to be able to store data associated with references.
typedef struct sdf_Reference_t sdf_Reference_t;
typedef struct sdf_ReferenceEditorProxy_t sdf_ReferenceEditorProxy_t;
typedef struct sdf_ReferenceVector_t sdf_ReferenceVector_t;
/// \class SdfRelationshipSpec
/// 
/// A property that contains a reference to one or more SdfPrimSpec instances.
/// 
/// A relationship may refer to one or more target prims or attributes.
/// All targets of a single relationship are considered to be playing the same
/// role. Note that \c role does not imply that the target prims or attributes
/// are of the same \c type.
/// 
/// Relationships may be annotated with relational attributes.
/// Relational attributes are named SdfAttributeSpec objects containing
/// values that describe the relationship.  For example, point weights are
/// commonly expressed as relational attributes.
typedef struct sdf_RelationshipSpec_t sdf_RelationshipSpec_t;
typedef struct sdf_RelationshipSpecHandle_t sdf_RelationshipSpecHandle_t;
typedef struct sdf_RelationshipSpecHandleVector_t sdf_RelationshipSpecHandleVector_t;
typedef struct sdf_RelationshipSpecView_t sdf_RelationshipSpecView_t;
typedef struct sdf_RelationshipSpecHandleOffsetPair_t sdf_RelationshipSpecHandleOffsetPair_t;
typedef struct sdf_RelationshipSpecHandleOffsetPairVector_t sdf_RelationshipSpecHandleOffsetPairVector_t;
typedef struct sdf_RelocatesMap_t sdf_RelocatesMap_t;
typedef struct sdf_RelocatesMapProxy_t sdf_RelocatesMapProxy_t;
/// \class SdfSchemaBase
/// 
/// Generic class that provides information about scene description fields
/// but doesn't actually provide any fields.
typedef struct sdf_SchemaBase_t sdf_SchemaBase_t;
/// \class FieldDefinition
/// 
/// Class defining various attributes for a field.
typedef struct sdf_SchemaBaseFieldDefinition_t sdf_SchemaBaseFieldDefinition_t;
typedef struct sdf_SchemaBaseFieldDefinitionInfoVec_t sdf_SchemaBaseFieldDefinitionInfoVec_t;
typedef struct sdf_TokenValuePair_t sdf_TokenValuePair_t;
/// \class SpecDefinition
/// 
/// Class representing fields and other information for a spec type.
typedef struct sdf_SchemaBaseSpecDefinition_t sdf_SchemaBaseSpecDefinition_t;
/// \class SdfSpec
/// 
/// Base class for all Sdf spec classes.
typedef struct sdf_Spec_t sdf_Spec_t;
typedef struct sdf_SpecHandle_t sdf_SpecHandle_t;
typedef struct sdf_SubLayerProxy_t sdf_SubLayerProxy_t;
/// \class SdfTextFileFormat
/// 
/// Sdf text file format
typedef struct sdf_TextFileFormat_t sdf_TextFileFormat_t;
/// \class SdfTimeCode
/// 
/// Value type that represents a time code. It's equivalent to a double type
/// value but is used to indicate that this value should be resolved by any
/// time based value resolution.
typedef struct sdf_TimeCode_t sdf_TimeCode_t;
typedef struct sdf_TimeSampleMap_t sdf_TimeSampleMap_t;
/// \struct SdfTupleDimensions
/// 
/// Represents the shape of a value type (or that of an element in an array).
typedef struct BBL_ALIGN(8) sdf_TupleDimensions_t {
    size_t d[2];
    size_t size;
} sdf_TupleDimensions_t;

/// \class SdfValueBlock
/// A special value type that can be used to explicitly author an
/// opinion for an attribute's default value or time sample value
/// that represents having no value. Note that this is different
/// from not having a value authored.
/// 
/// One could author such a value in two ways.
/// 
/// \code
/// attribute->SetDefaultValue(VtValue(SdfValueBlock());
/// ...
/// layer->SetTimeSample(attribute->GetPath(), 101, VtValue(SdfValueBlock()));
/// \endcode
typedef struct sdf_ValueBlock_t sdf_ValueBlock_t;
/// \class SdfValueTypeName
/// 
/// Represents a value type name, i.e. an attribute's type name.  Usually,
/// a value type name associates a string with a \c TfType and an optional
/// role, along with additional metadata.  A schema registers all known
/// value type names and may register multiple names for the same TfType
/// and role pair.  All name strings for a given pair are collectively
/// called its aliases.
/// 
/// A value type name may also represent just a name string, without a
/// \c TfType, role or other metadata.  This is currently used exclusively
/// to unserialize and re-serialize an attribute's type name where that
/// name is not known to the schema.
/// 
/// Because value type names can have aliases and those aliases may change
/// in the future, clients should avoid using the value type name's string
/// representation except to report human readable messages and when
/// serializing.  Clients can look up a value type name by string using
/// \c SdfSchemaBase::FindType() and shouldn't otherwise need the string.
/// Aliases compare equal, even if registered by different schemas.
typedef struct sdf_ValueTypeName_t sdf_ValueTypeName_t;
typedef struct sdf_ValueTypeNameVector_t sdf_ValueTypeNameVector_t;
/// \class SdfVariableExpression
/// 
/// Class responsible for parsing and evaluating variable expressions.
/// 
/// Variable expressions are written in a custom language and 
/// represented in scene description as a string surrounded by backticks (`).
/// These expressions may refer to "expression variables", which are key-value
/// pairs authored as layer metadata. For example, when evaluating an 
/// expression like:
/// 
/// \code
/// `"a_${NAME}_string"`
/// \endcode
/// 
/// The "${NAME}" portion of the string with the value of expression variable
/// "NAME".
/// 
/// Higher levels of the system (e.g., composition) are responsible for
/// examining fields that support variable expressions, evaluating them
/// with the appropriate variables (via this class) and consuming the
/// results.
/// 
/// See \ref Sdf_Page_VariableExpressions "Variable Expressions"
/// or more information on the expression language and areas of the system
/// where expressions may be used.
typedef struct sdf_VariableExpression_t sdf_VariableExpression_t;
/// \class Result
typedef struct sdf_VariableExpressionResult_t sdf_VariableExpressionResult_t;
typedef struct sdf_VariantSelectionProxy_t sdf_VariantSelectionProxy_t;
/// \class SdfVariantSetSpec 
/// 
/// Represents a coherent set of alternate representations for part of a
/// scene.
/// 
/// An SdfPrimSpec object may contain one or more named SdfVariantSetSpec
/// objects that define variations on the prim.
/// 
/// An SdfVariantSetSpec object contains one or more named SdfVariantSpec
/// objects. It may also define the name of one of its variants to be used by
/// default. 
/// 
/// When a prim references another prim, the referencing prim may specify
/// one of the variants from each of the variant sets of the target prim.
/// The chosen variant from each set (or the default variant from those sets
/// that the referencing prim does not explicitly specify) is composited 
/// over the target prim, and then the referencing prim is composited over 
/// the result.
typedef struct sdf_VariantSetSpec_t sdf_VariantSetSpec_t;
typedef struct sdf_VariantSetsProxy_t sdf_VariantSetsProxy_t;
/// \class SdfVariantSpec 
/// 
/// Represents a single variant in a variant set.
/// 
/// A variant contains a prim.  This prim is the root prim of the variant.
/// 
/// SdfVariantSpecs are value objects.  This means they are immutable 
/// once created and they are passed by copy-in APIs.  To change a variant 
/// spec, you make a new one and replace the existing one.
typedef struct sdf_VariantSpec_t sdf_VariantSpec_t;
typedef struct sdf_VariantSetSpecHandle_t sdf_VariantSetSpecHandle_t;
typedef struct sdf_VariantSpecHandle_t sdf_VariantSpecHandle_t;
typedef struct sdf_VariantSpecHandleVector_t sdf_VariantSpecHandleVector_t;
typedef struct sdf_VariantView_t sdf_VariantView_t;
typedef struct std_String_t std_String_t;
typedef struct std_StringVector_t std_StringVector_t;
typedef struct std_StringSet_t std_StringSet_t;
typedef struct std_DoubleVector_t std_DoubleVector_t;
typedef struct std_DoubleSet_t std_DoubleSet_t;
/// \class TfEnum
/// \ingroup group_tf_RuntimeTyping
/// 
/// An enum class that records both enum type and enum value.
/// 
/// \section cppcode_runtimeTyping Run-Time Typing 
/// 
/// A \c TfEnum can hold an enum variable of any enum type, while still
/// being able to distinguish between various enum types.
/// Here is an example:
/// 
/// \code
/// enum Monsters { SULLEY = 0, MIKE, ROZ };
/// enum Fish { NEMO = 0, FATHER, DORY };
/// 
/// TfEnum t1 = MIKE,
///        t2 = NEMO;
/// 
/// t1 == MIKE;        // yields true
/// t2 == NEMO;        // yields true
/// t1 == t2;          // yields false
/// t1 == SULLEY;      // yields false
/// 
/// t1.IsA<Monsters>();        // yields true
/// t1.IsA<Fish>();    // yields false
/// \endcode
/// 
/// Even though \c NEMO and \c SULLEY both are represented with integral
/// value zero, \c t1 and \c t2 compare false.  A \c TfEnum can be passed
/// by value, assigned, etc. just like a regular \c Enum variable.
/// A \c TfEnum can also hold a plain integer, which will compare false against
/// any other enum variable.
/// 
/// \section cppcode_enumvals Associating Names with Enumerated Values 
/// 
/// The \c TfEnum class can also be used to represent enumerated values
/// as strings. This can be useful for storing enum values in files for
/// later retrieval.
/// 
/// Use the \c TF_ADD_ENUM_NAME() macro to set up and enable strings
/// for the values of an enum. Once this is done, several static 
/// \c TfEnum methods may be used to look up names corresponding to enum
/// values and vice-versa.
/// 
/// For example, see \c TfRegistryManager to understand the use of
/// the \c TF_REGISTRY_FUNCTION() macro below:
/// 
/// \section cppcode_enumRegMacro Enum Registration Macro
/// 
/// \code
/// // header file
/// // Declare an enumerated type with some values
/// enum Season {
///     SPRING,
///     SUMMER = 3, // It's ok to have initializers
///     AUTUMN,
///     WINTER
/// };
/// 
/// // source file
/// #include "pxr/base/tf/registryManager.h"
/// TF_REGISTRY_FUNCTION(TfEnum) {
///     // Register the names for the values:
///     TF_ADD_ENUM_NAME(SPRING);
///     TF_ADD_ENUM_NAME(SUMMER);
///     TF_ADD_ENUM_NAME(AUTUMN);
///     TF_ADD_ENUM_NAME(WINTER);
/// }
/// 
/// // another source file:
/// 
/// // Look up the name for a value:
/// string name1 = TfEnum::GetName(SUMMER);     // Returns "SUMMER"
/// string name2 = TfEnum::GetFullName(SUMMER); // Returns "Season::SUMMER"
/// 
/// // Look up the value for a name:
/// bool found;
/// Season s1 = TfEnum::GetValueFromName<Season>("AUTUMN", &found);
/// // Returns 4, sets found to true
/// Season s2 = TfEnum::GetValueFromName<Season>("MONDAY", &found);
/// // Returns -1, sets found to false
/// 
/// // Look up a fully-qualified name. Since this is not a templated
/// // function, it has to return a generic value type, so we use
/// // TfEnum.
/// TfEnum s3 = TfEnum::GetValueFromFullName("Season::WINTER", &found);
/// // Returns 5, sets found to \c true
/// \endcode
typedef struct tf_Enum_t tf_Enum_t;
/// \class TfToken
/// \ingroup group_tf_String
/// 
/// Token for efficient comparison, assignment, and hashing of known strings.
/// 
/// A TfToken is a handle for a registered string, and can be compared,
/// assigned, and hashed in constant time.  It is useful when a bounded number
/// of strings are used as fixed symbols (but never modified).
/// 
/// For example, the set of avar names in a shot is large but bounded, and
/// once an avar name is discovered, it is never manipulated.  If these names
/// were passed around as strings, every comparison and hash would be linear
/// in the number of characters.  (String assignment itself is sometimes a
/// constant time operation, but it is sometimes linear in the length of the
/// string as well as requiring a memory allocation.)
/// 
/// To use TfToken, simply create an instance from a string or const char*.
/// If the string hasn't been seen before, a copy of it is added to a global
/// table.  The resulting TfToken is simply a wrapper around an string*,
/// pointing that canonical copy of the string.  Thus, operations on the token
/// are very fast.  (The string's hash is simply the address of the canonical
/// copy, so hashing the string is constant time.)
/// 
/// The free functions \c TfToTokenVector() and \c TfToStringVector() provide
/// conversions to and from vectors of \c string.
/// 
/// Note: Access to the global table is protected by a mutex.  This is a good
/// idea as long as clients do not construct tokens from strings too
/// frequently.  Construct tokens only as often as you must (for example, as
/// you read data files), and <i>never</i> in inner loops.  Of course, once
/// you have a token, feel free to compare, assign, and hash it as often as
/// you like.  (That's what it's for.)  In order to help prevent tokens from
/// being re-created over and over, auto type conversion from \c string and \c
/// char* to \c TfToken is disabled (you must use the explicit \c TfToken
/// constructors).  However, auto conversion from \c TfToken to \c string and
/// \c char* is provided.
typedef struct tf_Token_t tf_Token_t;
/// \class TfType
/// 
/// TfType represents a dynamic runtime type.
/// 
/// TfTypes are created and discovered at runtime, rather than compile
/// time.
/// 
/// Features:
/// 
/// - unique typename
/// - safe across DSO boundaries
/// - can represent C++ types, pure Python types, or Python subclasses of
///   wrapped C++ types
/// - lightweight value semantics -- you can copy and default construct
///   TfType, unlike \c std::type_info.
/// - totally ordered -- can use as a \c std::map key
typedef struct tf_Type_t tf_Type_t;
typedef struct tf_TokenVector_t tf_TokenVector_t;
/// \class UsdGeomBasisCurves
/// 
/// BasisCurves are a batched curve representation analogous to the
/// classic RIB definition via Basis and Curves statements. BasisCurves are
/// often used to render dense aggregate geometry like hair or grass.
/// 
/// A 'matrix' and 'vstep' associated with the \em basis are used to
/// interpolate the vertices of a cubic BasisCurves. (The basis attribute
/// is unused for linear BasisCurves.)
/// 
/// A single prim may have many curves whose count is determined implicitly by
/// the length of the \em curveVertexCounts vector.  Each individual curve is
/// composed of one or more segments. Each segment is defined by four vertices
/// for cubic curves and two vertices for linear curves. See the next section
/// for more information on how to map curve vertex counts to segment counts.
/// 
/// \section UsdGeomBasisCurves_Segment Segment Indexing
/// Interpolating a curve requires knowing how to decompose it into its 
/// individual segments.
/// 
/// The segments of a cubic curve are determined by the vertex count,
/// the \em wrap (periodicity), and the vstep of the basis. For linear
/// curves, the basis token is ignored and only the vertex count and
/// wrap are needed.
/// 
/// cubic basis   | vstep
/// ------------- | ------
/// bezier        | 3
/// catmullRom    | 1
/// bspline       | 1
/// 
/// The first segment of a cubic (nonperiodic) curve is always defined by its
/// first four points. The vstep is the increment used to determine what
/// vertex indices define the next segment.  For a two segment (nonperiodic)
/// bspline basis curve (vstep = 1), the first segment will be defined by
/// interpolating vertices [0, 1, 2, 3] and the second segment will be defined
/// by [1, 2, 3, 4].  For a two segment bezier basis curve (vstep = 3), the
/// first segment will be defined by interpolating vertices [0, 1, 2, 3] and
/// the second segment will be defined by [3, 4, 5, 6].  If the vstep is not
/// one, then you must take special care to make sure that the number of cvs
/// properly divides by your vstep. (The indices described are relative to
/// the initial vertex index for a batched curve.)
/// 
/// For periodic curves, at least one of the curve's initial vertices are
/// repeated to close the curve. For cubic curves, the number of vertices
/// repeated is '4 - vstep'. For linear curves, only one vertex is repeated
/// to close the loop.
/// 
/// Pinned curves are a special case of nonperiodic curves that only affects
/// the behavior of cubic Bspline and Catmull-Rom curves. To evaluate or render
/// pinned curves, a client must effectively add 'phantom points' at the 
/// beginning and end of every curve in a batch.  These phantom points
/// are injected to ensure that the interpolated curve begins at P[0] and
/// ends at P[n-1].
/// 
/// For a curve with initial point P[0] and last point P[n-1], the phantom
/// points are defined as.
/// P[-1]  = 2 * P[0] - P[1]
/// P[n] = 2 * P[n-1] - P[n-2]
/// 
/// Pinned cubic curves will (usually) have to be unpacked into the standard
/// nonperiodic representation before rendering. This unpacking can add some 
/// additional overhead. However, using pinned curves reduces the amount of
/// data recorded in a scene and (more importantly) better records the
/// authors' intent for interchange.
/// 
/// \note The additional phantom points mean that the minimum curve vertex
/// count for cubic bspline and catmullRom curves is 2.
/// 
/// Linear curve segments are defined by two vertices.
/// A two segment linear curve's first segment would be defined by
/// interpolating vertices [0, 1]. The second segment would be defined by 
/// vertices [1, 2]. (Again, for a batched curve, indices are relative to
/// the initial vertex index.)
/// 
/// When validating curve topology, each renderable entry in the
/// curveVertexCounts vector must pass this check.
/// 
/// type    | wrap                        | validitity
/// ------- | --------------------------- | ----------------
/// linear  | nonperiodic                 | curveVertexCounts[i] > 2
/// linear  | periodic                    | curveVertexCounts[i] > 3
/// cubic   | nonperiodic                 | (curveVertexCounts[i] - 4) % vstep == 0
/// cubic   | periodic                    | (curveVertexCounts[i]) % vstep == 0
/// cubic   | pinned (catmullRom/bspline) | (curveVertexCounts[i] - 2) >= 0
/// 
/// \section UsdGeomBasisCurves_BasisMatrix Cubic Vertex Interpolation
/// 
/// \image html USDCurveBasisMatrix.png width=750
/// 
/// \section UsdGeomBasisCurves_Linear Linear Vertex Interpolation
/// 
/// Linear interpolation is always used on curves of type linear.
/// 't' with domain [0, 1], the curve is defined by the equation 
/// P0 * (1-t) + P1 * t. t at 0 describes the first point and t at 1 describes
/// the end point.
/// 
/// \section UsdGeomBasisCurves_PrimvarInterpolation Primvar Interpolation
/// 
/// For cubic curves, primvar data can be either interpolated cubically between 
/// vertices or linearly across segments.  The corresponding token
/// for cubic interpolation is 'vertex' and for linear interpolation is
/// 'varying'.  Per vertex data should be the same size as the number
/// of vertices in your curve.  Segment varying data is dependent on the 
/// wrap (periodicity) and number of segments in your curve.  For linear curves,
/// varying and vertex data would be interpolated the same way.  By convention 
/// varying is the preferred interpolation because of the association of 
/// varying with linear interpolation.
/// 
/// \image html USDCurvePrimvars.png 
/// 
/// To convert an entry in the curveVertexCounts vector into a segment count 
/// for an individual curve, apply these rules.  Sum up all the results in
/// order to compute how many total segments all curves have.
/// 
/// The following tables describe the expected segment count for the 'i'th
/// curve in a curve batch as well as the entire batch. Python syntax
/// like '[:]' (to describe all members of an array) and 'len(...)' 
/// (to describe the length of an array) are used.
/// 
/// type    | wrap                        | curve segment count                    | batch segment count                                                       
/// ------- | --------------------------- | -------------------------------------- | --------------------------
/// linear  | nonperiodic                 | curveVertexCounts[i] - 1               | sum(curveVertexCounts[:]) - len(curveVertexCounts)
/// linear  | periodic                    | curveVertexCounts[i]                   | sum(curveVertexCounts[:])
/// cubic   | nonperiodic                 | (curveVertexCounts[i] - 4) / vstep + 1 | sum(curveVertexCounts[:] - 4) / vstep + len(curveVertexCounts)
/// cubic   | periodic                    | curveVertexCounts[i] / vstep           | sum(curveVertexCounts[:]) / vstep
/// cubic   | pinned (catmullRom/bspline) | (curveVertexCounts[i] - 2) + 1         | sum(curveVertexCounts[:] - 2) + len(curveVertexCounts)
/// 
/// The following table descrives the expected size of varying
/// (linearly interpolated) data, derived from the segment counts computed
/// above.
/// 
/// wrap                | curve varying count          | batch varying count
/// ------------------- | ---------------------------- | ------------------------------------------------
/// nonperiodic/pinned  | segmentCounts[i] + 1         | sum(segmentCounts[:]) + len(curveVertexCounts)
/// periodic            | segmentCounts[i]             | sum(segmentCounts[:])
/// 
/// Both curve types additionally define 'constant' interpolation for the
/// entire prim and 'uniform' interpolation as per curve data.
/// 
/// 
/// \note Take care when providing support for linearly interpolated data for
/// cubic curves. Its shape doesn't provide a one to one mapping with either
/// the number of curves (like 'uniform') or the number of vertices (like
/// 'vertex') and so it is often overlooked. This is the only primitive in
/// UsdGeom (as of this writing) where this is true. For meshes, while they
/// use different interpolation methods, 'varying' and 'vertex' are both
/// specified per point. It's common to assume that curves follow a similar
/// pattern and build in structures and language for per primitive, per
/// element, and per point data only to come upon these arrays that don't 
/// quite fit into either of those categories. It is
/// also common to conflate 'varying' with being per segment data and use the
/// segmentCount rules table instead of its neighboring varying data table
/// rules. We suspect that this is because for the common case of
/// nonperiodic cubic curves, both the provided segment count and varying data
/// size formula end with '+ 1'. While debugging, users may look at the double
/// '+ 1' as a mistake and try to remove it.  We take this time to enumerate
/// these issues because we've fallen into them before and hope that we save
/// others time in their own implementations.
/// 
/// As an example of deriving per curve segment and varying primvar data counts from
/// the wrap, type, basis, and curveVertexCount, the following table is provided.
/// 
/// wrap          | type    | basis   | curveVertexCount  | curveSegmentCount  | varyingDataCount
/// ------------- | ------- | ------- | ----------------- | ------------------ | -------------------------
/// nonperiodic   | linear  | N/A     | [2 3 2 5]         | [1 2 1 4]          | [2 3 2 5]
/// nonperiodic   | cubic   | bezier  | [4 7 10 4 7]      | [1 2 3 1 2]        | [2 3 4 2 3]
/// nonperiodic   | cubic   | bspline | [5 4 6 7]         | [2 1 3 4]          | [3 2 4 5]
/// periodic      | cubic   | bezier  | [6 9 6]           | [2 3 2]            | [2 3 2]
/// periodic      | linear  | N/A     | [3 7]             | [3 7]              | [3 7]
/// 
/// \section UsdGeomBasisCurves_TubesAndRibbons Tubes and Ribbons
/// 
/// The strictest definition of a curve as an infinitely thin wire is not 
/// particularly useful for describing production scenes. The additional
/// \em widths and \em normals attributes can be used to describe cylindrical
/// tubes and or flat oriented ribbons.
/// 
/// Curves with only widths defined are imaged as tubes with radius
/// 'width / 2'. Curves with both widths and normals are imaged as ribbons
/// oriented in the direction of the interpolated normal vectors.
/// 
/// While not technically UsdGeomPrimvars, widths and normals
/// also have interpolation metadata. It's common for authored widths to have
/// constant, varying, or vertex interpolation 
/// (see UsdGeomCurves::GetWidthsInterpolation()).  It's common for
/// authored normals to have varying interpolation 
/// (see UsdGeomPointBased::GetNormalsInterpolation()).
/// 
/// \image html USDCurveHydra.png
/// 
/// The file used to generate these curves can be found in
/// extras/usd/examples/usdGeomExamples/basisCurves.usda.  It's provided
/// as a reference on how to properly image both tubes and ribbons. The first
/// row of curves are linear; the second are cubic bezier. (We aim in future
/// releases of HdSt to fix the discontinuity seen with broken tangents to
/// better match offline renderers like RenderMan.) The yellow and violet
/// cubic curves represent cubic vertex width interpolation for which there is
/// no equivalent for linear curves.
/// 
/// \note How did this prim type get its name?  This prim is a portmanteau of
/// two different statements in the original RenderMan specification:
/// 'Basis' and 'Curves'.
/// 
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_BasisCurves_t usdGeom_BasisCurves_t;
/// \class UsdGeomBBoxCache
/// 
/// Caches bounds by recursively computing and aggregating bounds of children in
/// world space and aggregating the result back into local space.
/// 
/// The cache is configured for a specific time and
/// \ref UsdGeomImageable::GetPurposeAttr() set of purposes. When querying a
/// bound, transforms and extents are read either from the time specified or
/// UsdTimeCode::Default(), following \ref Usd_ValueResolution standard
/// time-sample value resolution.  As noted in SetIncludedPurposes(), changing
/// the included purposes does not invalidate the cache, because we cache
/// purpose along with the geometric data.
/// 
/// Child prims that are invisible at the requested time are excluded when
/// computing a prim's bounds.  However, if a bound is requested directly for an
/// excluded prim, it will be computed. Additionally, only prims deriving from
/// UsdGeomImageable are included in child bounds computations.
/// 
/// Unlike standard UsdStage traversals, the traversal performed by the
/// UsdGeomBBoxCache includes prims that are unloaded (see UsdPrim::IsLoaded()).
/// This makes it possible to fetch bounds for a UsdStage that has been opened
/// without \em forcePopulate , provided the unloaded model prims have authored
/// extent hints (see UsdGeomModelAPI::GetExtentsHint()).
/// 
/// This class is optimized for computing tight <b>untransformed "object"
/// space</b> bounds for component-models.  In the absence of component models,
/// bounds are optimized for world-space, since there is no other easily
/// identifiable space for which to optimize, and we cannot optimize for every
/// prim's local space without performing quadratic work.
/// 
/// The TfDebug flag, USDGEOM_BBOX, is provided for debugging.
/// 
/// Warnings:
///  * This class should only be used with valid UsdPrim objects.
/// 
///  * This cache does not listen for change notifications; the user is
///    responsible for clearing the cache when changes occur.
/// 
///  * Thread safety: instances of this class may not be used concurrently.
/// 
///  * Plugins may be loaded in order to compute extents for prim types provided
///    by that plugin.  See UsdGeomBoundable::ComputeExtentFromPlugins
typedef struct usdGeom_BBoxCache_t usdGeom_BBoxCache_t;
typedef struct usdGeom_PathMatrixHashMap_t usdGeom_PathMatrixHashMap_t;
/// \class UsdGeomBoundable
/// 
/// Boundable introduces the ability for a prim to persistently
/// cache a rectilinear, local-space, extent.
/// 
/// \section UsdGeom_Boundable_Extent Why Extent and not Bounds ?
/// Boundable introduces the notion of "extent", which is a cached computation
/// of a prim's local-space 3D range for its resolved attributes <b>at the
/// layer and time in which extent is authored</b>.  We have found that with
/// composed scene description, attempting to cache pre-computed bounds at
/// interior prims in a scene graph is very fragile, given the ease with which
/// one can author a single attribute in a stronger layer that can invalidate
/// many authored caches - or with which a re-published, referenced asset can
/// do the same.
/// 
/// Therefore, we limit to precomputing (generally) leaf-prim extent, which
/// avoids the need to read in large point arrays to compute bounds, and
/// provides UsdGeomBBoxCache the means to efficiently compute and
/// (session-only) cache intermediate bounds.  You are free to compute and
/// author intermediate bounds into your scenes, of course, which may work
/// well if you have sufficient locks on your pipeline to guarantee that once
/// authored, the geometry and transforms upon which they are based will
/// remain unchanged, or if accuracy of the bounds is not an ironclad
/// requisite. 
/// 
/// When intermediate bounds are authored on Boundable parents, the child prims
/// will be pruned from BBox computation; the authored extent is expected to
/// incorporate all child bounds.
typedef struct usdGeom_Boundable_t usdGeom_Boundable_t;
/// \class UsdGeomCamera
/// 
/// Transformable camera.
/// 
/// Describes optical properties of a camera via a common set of attributes
/// that provide control over the camera's frustum as well as its depth of
/// field. For stereo, the left and right camera are individual prims tagged
/// through the \ref UsdGeomCamera::GetStereoRoleAttr() "stereoRole attribute".
/// 
/// There is a corresponding class GfCamera, which can hold the state of a
/// camera (at a particular time). \ref UsdGeomCamera::GetCamera() and
/// \ref UsdGeomCamera::SetFromCamera() convert between a USD camera prim and
/// a GfCamera.
/// 
/// To obtain the camera's location in world space, call the following on a
/// UsdGeomCamera 'camera':
/// \code
/// GfMatrix4d camXform = camera.ComputeLocalToWorldTransform(time);
/// \endcode
/// \note
/// <b>Cameras in USD are always "Y up", regardless of the stage's orientation
/// (i.e. UsdGeomGetStageUpAxis()).</b>  This means that the inverse of 
/// 'camXform' (the VIEW half of the <A HREF="http://www.glprogramming.com/red/chapter03.html#name2">MODELVIEW transform in OpenGL parlance</A>) 
/// will transform the world such that the camera is at the origin, looking 
/// down the -Z axis, with +Y as the up axis, and +X pointing to the right.
/// This describes a __right handed coordinate system__. 
/// 
/// \section UsdGeom_CameraUnits Units of Measure for Camera Properties
/// 
/// Despite the familiarity of millimeters for specifying some physical
/// camera properties, UsdGeomCamera opts for greater consistency with all
/// other UsdGeom schemas, which measure geometric properties in scene units,
/// as determined by UsdGeomGetStageMetersPerUnit().  We do make a
/// concession, however, in that lens and filmback properties are measured in
/// __tenths of a scene unit__ rather than "raw" scene units.  This means
/// that with the fallback value of .01 for _metersPerUnit_ - i.e. scene unit
/// of centimeters - then these "tenth of scene unit" properties are
/// effectively millimeters.
/// 
/// \note If one adds a Camera prim to a UsdStage whose scene unit is not
/// centimeters, the fallback values for filmback properties will be
/// incorrect (or at the least, unexpected) in an absolute sense; however,
/// proper imaging through a "default camera" with focusing disabled depends
/// only on ratios of the other properties, so the camera is still usable.
/// However, it follows that if even one property is authored in the correct
/// scene units, then they all must be.
/// 
/// 
/// \sa \ref UsdGeom_LinAlgBasics
/// 
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_Camera_t usdGeom_Camera_t;
/// \class UsdGeomCapsule
/// 
/// Defines a primitive capsule, i.e. a cylinder capped by two half
/// spheres, centered at the origin, whose spine is along the specified
/// \em axis.
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_Capsule_t usdGeom_Capsule_t;
/// \class UsdGeomCone
/// 
/// Defines a primitive cone, centered at the origin, whose spine
/// is along the specified \em axis, with the apex of the cone pointing
/// in the direction of the positive axis.
/// 
/// The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
/// they all pack into the same volume/bounds.
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_Cone_t usdGeom_Cone_t;
/// \class UsdGeomConstraintTarget
/// 
/// Schema wrapper for UsdAttribute for authoring and introspecting
/// attributes that are constraint targets.
/// 
/// Constraint targets correspond roughly to what some DCC's call locators.
/// They are coordinate frames, represented as (animated or static) GfMatrix4d
/// values.  We represent them as attributes in USD rather than transformable
/// prims because generally we require no other coordinated information about 
/// a constraint target other than its name and its matrix value, and because
/// attributes are more concise than prims.
/// 
/// Because consumer clients often care only about the identity and value of
/// constraint targets and may be able to usefully consume them without caring
/// about the actual geometry with which they may logically correspond,
/// UsdGeom aggregates all constraint targets onto a model's root prim,
/// assuming that an exporter will use property namespacing within the 
/// constraint target attribute's name to indicate a path to a prim within 
/// the model with which the constraint target may correspond.
/// 
/// To facilitate instancing, and also position-tweaking of baked assets, we
/// stipulate that constraint target values always be recorded in
/// <b>model-relative transformation space</b>.  In other words, to get the
/// world-space value of a constraint target, transform it by the
/// local-to-world transformation of the prim on which it is recorded.  
/// ComputeInWorldSpace() will perform this calculation.
/// 
/// \todo Provide API for extracting prim or property path from a target's
/// namespaced name.
typedef struct usdGeom_ConstraintTarget_t usdGeom_ConstraintTarget_t;
typedef struct usdGeom_ConstraintTargetVector_t usdGeom_ConstraintTargetVector_t;
/// \class UsdGeomCube
/// 
/// Defines a primitive rectilinear cube centered at the origin.
/// 
/// The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
/// they all pack into the same volume/bounds.
typedef struct usdGeom_Cube_t usdGeom_Cube_t;
/// \class UsdGeomCurves
/// 
/// Base class for UsdGeomBasisCurves, UsdGeomNurbsCurves, and
/// UsdGeomHermiteCurves.  The BasisCurves schema is designed to be
/// analagous to offline renderers' notion of batched curves (such as
/// the classical RIB definition via Basis and Curves statements),
/// while the NurbsCurve schema is designed to be analgous to the
/// NURBS curves found in packages like Maya and Houdini while
/// retaining their consistency with the RenderMan specification for
/// NURBS Patches. HermiteCurves are useful for the
/// interchange of animation guides and paths.
/// 
/// It is safe to use the length of the curve vertex count to derive
/// the number of curves and the number and layout of curve vertices,
/// but this schema should NOT be used to derive the number of curve
/// points. While vertex indices are implicit in all shipped
/// descendent types of this schema, one should not assume that all
/// internal or future shipped schemas will follow this pattern. Be
/// sure to key any indexing behavior off the concrete type, not this
/// abstract type.
typedef struct usdGeom_Curves_t usdGeom_Curves_t;
/// \class UsdGeomCylinder
/// 
/// Defines a primitive cylinder with closed ends, centered at the 
/// origin, whose spine is along the specified \em axis.
/// 
/// The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
/// they all pack into the same volume/bounds.
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_Cylinder_t usdGeom_Cylinder_t;
/// \class UsdGeomGprim
/// 
/// Base class for all geometric primitives.  
/// 
/// Gprim encodes basic graphical properties such as \em doubleSided and
/// \em orientation, and provides primvars for "display color" and "display
/// opacity" that travel with geometry to be used as shader overrides.  
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_Gprim_t usdGeom_Gprim_t;
/// \class UsdGeomHermiteCurves
/// 
/// This schema specifies a cubic hermite interpolated curve batch as
/// sometimes used for defining guides for animation. While hermite curves can
/// be useful because they interpolate through their control points, they are
/// not well supported by high-end renderers for imaging. Therefore, while we
/// include this schema for interchange, we strongly recommend the use of
/// UsdGeomBasisCurves as the representation of curves intended to be rendered
/// (ie. hair or grass). Hermite curves can be converted to a Bezier
/// representation (though not from Bezier back to Hermite in general).
/// 
/// \section UsdGeomHermiteCurves_Interpolation Point Interpolation
/// 
/// The initial cubic curve segment is defined by the first two points and
/// first two tangents. Additional segments are defined by additional 
/// point / tangent pairs.  The number of segments for each non-batched hermite
/// curve would be len(curve.points) - 1.  The total number of segments
/// for the batched UsdGeomHermiteCurves representation is
/// len(points) - len(curveVertexCounts).
/// 
/// \section UsdGeomHermiteCurves_Primvars Primvar, Width, and Normal Interpolation
/// 
/// Primvar interpolation is not well specified for this type as it is not
/// intended as a rendering representation. We suggest that per point
/// primvars would be linearly interpolated across each segment and should 
/// be tagged as 'varying'.
/// 
/// It is not immediately clear how to specify cubic or 'vertex' interpolation
/// for this type, as we lack a specification for primvar tangents. This
/// also means that width and normal interpolation should be restricted to
/// varying (linear), uniform (per curve element), or constant (per prim).
typedef struct usdGeom_HermiteCurves_t usdGeom_HermiteCurves_t;
/// \class UsdGeomImageable
/// 
/// Base class for all prims that may require rendering or 
/// visualization of some sort. The primary attributes of Imageable 
/// are \em visibility and \em purpose, which each provide instructions for
/// what geometry should be included for processing by rendering and other
/// computations.
/// 
/// \deprecated Imageable also provides API for accessing primvars, which
/// has been moved to the UsdGeomPrimvarsAPI schema, because primvars can now
/// be applied on non-Imageable prim types.  This API is planned
/// to be removed, UsdGeomPrimvarsAPI should be used directly instead.
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_Imageable_t usdGeom_Imageable_t;
/// Value type containing information about a prim's computed effective
/// purpose as well as storing whether the prim's purpose value can be
/// inherited by namespace children if necessary. This provides the purpose
/// information necessary for efficiently computing and caching the purposes
/// of a hierarchy of prims.
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
typedef struct usdGeom_ImageablePurposeInfo_t usdGeom_ImageablePurposeInfo_t;
/// \class UsdGeomMesh
/// 
/// Encodes a mesh with optional subdivision properties and features.
/// 
/// As a point-based primitive, meshes are defined in terms of points that 
/// are connected into edges and faces. Many references to meshes use the
/// term 'vertex' in place of or interchangeably with 'points', while some
/// use 'vertex' to refer to the 'face-vertices' that define a face.  To
/// avoid confusion, the term 'vertex' is intentionally avoided in favor of
/// 'points' or 'face-vertices'.
/// 
/// The connectivity between points, edges and faces is encoded using a
/// common minimal topological description of the faces of the mesh.  Each
/// face is defined by a set of face-vertices using indices into the Mesh's
/// _points_ array (inherited from UsdGeomPointBased) and laid out in a
/// single linear _faceVertexIndices_ array for efficiency.  A companion
/// _faceVertexCounts_ array provides, for each face, the number of
/// consecutive face-vertices in _faceVertexIndices_ that define the face.
/// No additional connectivity information is required or constructed, so
/// no adjacency or neighborhood queries are available.
/// 
/// A key property of this mesh schema is that it encodes both subdivision
/// surfaces and simpler polygonal meshes. This is achieved by varying the
/// _subdivisionScheme_ attribute, which is set to specify Catmull-Clark
/// subdivision by default, so polygonal meshes must always be explicitly
/// declared. The available subdivision schemes and additional subdivision
/// features encoded in optional attributes conform to the feature set of
/// OpenSubdiv
/// (https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html).
/// 
/// \anchor UsdGeom_Mesh_Primvars
/// __A Note About Primvars__
/// 
/// The following list clarifies the number of elements for and the
/// interpolation behavior of the different primvar interpolation types
/// for meshes:
/// 
/// - __constant__: One element for the entire mesh; no interpolation.
/// - __uniform__: One element for each face of the mesh; elements are
/// typically not interpolated but are inherited by other faces derived
/// from a given face (via subdivision, tessellation, etc.).
/// - __varying__: One element for each point of the mesh;
/// interpolation of point data is always linear.
/// - __vertex__: One element for each point of the mesh;
/// interpolation of point data is applied according to the
/// _subdivisionScheme_ attribute.
/// - __faceVarying__: One element for each of the face-vertices that
/// define the mesh topology; interpolation of face-vertex data may
/// be smooth or linear, according to the _subdivisionScheme_ and
/// _faceVaryingLinearInterpolation_ attributes.
/// 
/// Primvar interpolation types and related utilities are described more
/// generally in \ref Usd_InterpolationVals.
/// 
/// \anchor UsdGeom_Mesh_Normals
/// __A Note About Normals__
/// 
/// Normals should not be authored on a subdivision mesh, since subdivision
/// algorithms define their own normals. They should only be authored for
/// polygonal meshes (_subdivisionScheme_ = "none").
/// 
/// The _normals_ attribute inherited from UsdGeomPointBased is not a generic
/// primvar, but the number of elements in this attribute will be determined by
/// its _interpolation_.  See \ref UsdGeomPointBased::GetNormalsInterpolation() .
/// If _normals_ and _primvars:normals_ are both specified, the latter has
/// precedence.  If a polygonal mesh specifies __neither__ _normals_ nor
/// _primvars:normals_, then it should be treated and rendered as faceted,
/// with no attempt to compute smooth normals.
/// 
/// The normals generated for smooth subdivision schemes, e.g. Catmull-Clark
/// and Loop, will likewise be smooth, but others, e.g. Bilinear, may be
/// discontinuous between faces and/or within non-planar irregular faces.
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_Mesh_t usdGeom_Mesh_t;
/// \class UsdGeomModelAPI
/// 
/// UsdGeomModelAPI extends the generic UsdModelAPI schema with
/// geometry specific concepts such as cached extents for the entire model,
/// constraint targets, and geometry-inspired extensions to the payload
/// lofting process.
/// 
/// As described in GetExtentsHint() below, it is useful to cache extents
/// at the model level.  UsdGeomModelAPI provides schema for computing and
/// storing these cached extents, which can be consumed by UsdGeomBBoxCache to
/// provide fast access to precomputed extents that will be used as the model's
/// bounds ( see UsdGeomBBoxCache::UsdGeomBBoxCache() ).
/// 
/// \section UsdGeomModelAPI_drawMode Draw Modes
/// 
/// Draw modes provide optional alternate imaging behavior for USD subtrees with
/// kind model. \em model:drawMode (which is inheritable) and
/// \em model:applyDrawMode (which is not) are resolved into a decision to stop
/// traversing the scene graph at a certain point, and replace a USD subtree
/// with proxy geometry.
/// 
/// The value of \em model:drawMode determines the type of proxy geometry:
/// - \em origin - Draw the model-space basis vectors of the replaced prim.
/// - \em bounds - Draw the model-space bounding box of the replaced prim.
/// - \em cards - Draw textured quads as a placeholder for the replaced prim.
/// - \em default - An explicit opinion to draw the USD subtree as normal.
/// - \em inherited - Defer to the parent opinion.
/// 
/// \em model:drawMode falls back to _inherited_ so that a whole scene,
/// a large group, or all prototypes of a model hierarchy PointInstancer can
/// be assigned a draw mode with a single attribute edit.  If no draw mode is
/// explicitly set in a hierarchy, the resolved value is _default_.
/// 
/// \em model:applyDrawMode is meant to be written when an asset is authored,
/// and provides flexibility for different asset types. For example,
/// a character assembly (composed of character, clothes, etc) might have
/// \em model:applyDrawMode set at the top of the subtree so the whole group
/// can be drawn as a single card object. An effects subtree might have
/// \em model:applyDrawMode set at a lower level so each particle
/// group draws individually.
/// 
/// Models of kind component are treated as if \em model:applyDrawMode
/// were true.  This means a prim is drawn with proxy geometry when: the
/// prim has kind component, and/or \em model:applyDrawMode is set; and
/// the prim's resolved value for \em model:drawMode is not _default_.
/// 
/// \section UsdGeomModelAPI_cardGeometry Cards Geometry
/// 
/// The specific geometry used in cards mode is controlled by the
/// \em model:cardGeometry attribute:
/// - \em cross - Generate a quad normal to each basis direction and negative.
/// Locate each quad so that it bisects the model extents.
/// - \em box   - Generate a quad normal to each basis direction and negative.
/// Locate each quad on a face of the model extents, facing out.
/// - \em fromTexture - Generate a quad for each supplied texture from
/// attributes stored in that texture's metadata.
/// 
/// For \em cross and \em box mode, the extents are calculated for purposes
/// \em default, \em proxy, and \em render, at their earliest authored time.
/// If the model has no textures, all six card faces are rendered using
/// \em model:drawModeColor. If one or more textures are present, only axes
/// with one or more textures assigned are drawn.  For each axis, if both
/// textures (positive and negative) are specified, they'll be used on the
/// corresponding card faces; if only one texture is specified, it will be
/// mapped to the opposite card face after being flipped on the texture's
/// s-axis. Any card faces with invalid asset paths will be drawn with
/// \em model:drawModeColor.
/// 
/// Both \em model:cardGeometry and \em model:drawModeColor should be
/// authored on the prim where the draw mode takes effect, since these
/// attributes are not inherited.
/// 
/// For \em fromTexture mode, only card faces with valid textures assigned
/// are drawn. The geometry is generated by pulling the \em worldtoscreen
/// attribute out of texture metadata.  This is expected to be a 4x4 matrix
/// mapping the model-space position of the card quad to the clip-space quad
/// with corners (-1,-1,0) and (1,1,0).  The card vertices are generated by
/// transforming the clip-space corners by the inverse of \em worldtoscreen.
/// Textures are mapped so that (s) and (t) map to (+x) and (+y) in clip space.
/// If the metadata cannot be read in the right format, or the matrix can't
/// be inverted, the card face is not drawn.
/// 
/// All card faces are drawn and textured as single-sided.
/// 
/// \todo CreatePayload() 
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_ModelAPI_t usdGeom_ModelAPI_t;
/// \class UsdGeomMotionAPI
/// 
/// UsdGeomMotionAPI encodes data that can live on any prim that
/// may affect computations involving:
/// - computed motion for motion blur
/// - sampling for motion blur
/// 
/// The \ref GetMotionBlurScaleAttr() "motion:blurScale" attribute allows
/// artists to scale the __amount__ of motion blur to be rendered for parts
/// of the scene without changing the recorded animation.  See
/// \ref UsdGeomMotionAPI_blurScale for use and implementation details.
typedef struct usdGeom_MotionAPI_t usdGeom_MotionAPI_t;
/// \class UsdGeomNurbsCurves
/// 
/// This schema is analagous to NURBS Curves in packages like Maya
/// and Houdini, often used for interchange of rigging and modeling curves.  
/// Unlike Maya, this curve spec supports batching of multiple curves into a 
/// single prim, widths, and normals in the schema.  Additionally, we require 
/// 'numSegments + 2 * degree + 1' knots (2 more than maya does).  This is to
/// be more consistent with RenderMan's NURBS patch specification.  
/// 
/// To express a periodic curve:
/// - knot[0] = knot[1] - (knots[-2] - knots[-3]; 
/// - knot[-1] = knot[-2] + (knot[2] - knots[1]);
/// 
/// To express a nonperiodic curve:
/// - knot[0] = knot[1];
/// - knot[-1] = knot[-2];
/// 
/// In spite of these slight differences in the spec, curves generated in Maya
/// should be preserved when roundtripping.
/// 
/// \em order and \em range, when representing a batched NurbsCurve should be
/// authored one value per curve.  \em knots should be the concatentation of
/// all batched curves.
typedef struct usdGeom_NurbsCurves_t usdGeom_NurbsCurves_t;
/// \class UsdGeomNurbsPatch
/// 
/// Encodes a rational or polynomial non-uniform B-spline
/// surface, with optional trim curves.
/// 
/// The encoding mostly follows that of RiNuPatch and RiTrimCurve: 
/// https://renderman.pixar.com/resources/RenderMan_20/geometricPrimitives.html#rinupatch , with some minor renaming and coalescing for clarity.
/// 
/// The layout of control vertices in the \em points attribute inherited
/// from UsdGeomPointBased is row-major with U considered rows, and V columns.
/// 
/// \anchor UsdGeom_NurbsPatch_Form
/// <b>NurbsPatch Form</b>
/// 
/// The authored points, orders, knots, weights, and ranges are all that is
/// required to render the nurbs patch.  However, the only way to model closed
/// surfaces with nurbs is to ensure that the first and last control points
/// along the given axis are coincident.  Similarly, to ensure the surface is
/// not only closed but also C2 continuous, the last \em order - 1 control
/// points must be (correspondingly) coincident with the first \em order - 1
/// control points, and also the spacing of the last corresponding knots
/// must be the same as the first corresponding knots.
/// 
/// <b>Form</b> is provided as an aid to interchange between modeling and
/// animation applications so that they can robustly identify the intent with
/// which the surface was modelled, and take measures (if they are able) to
/// preserve the continuity/concidence constraints as the surface may be rigged
/// or deformed.  
/// \li An \em open-form NurbsPatch has no continuity constraints.
/// \li A \em closed-form NurbsPatch expects the first and last control points
/// to overlap
/// \li A \em periodic-form NurbsPatch expects the first and last
/// \em order - 1 control points to overlap.
/// 
/// <b>Nurbs vs Subdivision Surfaces</b>
/// 
/// Nurbs are an important modeling primitive in CAD/CAM tools and early
/// computer graphics DCC's.  Because they have a natural UV parameterization
/// they easily support "trim curves", which allow smooth shapes to be
/// carved out of the surface.
/// 
/// However, the topology of the patch is always rectangular, and joining two 
/// nurbs patches together (especially when they have differing numbers of
/// spans) is difficult to do smoothly.  Also, nurbs are not supported by
/// the Ptex texturing technology (http://ptex.us).
/// 
/// Neither of these limitations are shared by subdivision surfaces; therefore,
/// although they do not subscribe to trim-curve-based shaping, subdivs are
/// often considered a more flexible modeling primitive.
/// 
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_NurbsPatch_t usdGeom_NurbsPatch_t;
/// \class UsdGeomPlane
/// 
/// Defines a primitive plane, centered at the origin, and is defined by
/// a cardinal axis, width, and length. The plane is double-sided by default.
/// 
/// The axis of width and length are perpendicular to the plane's \em axis:
/// 
/// axis  | width  | length
/// ----- | ------ | -------
/// X     | z-axis | y-axis
/// Y     | x-axis | z-axis
/// Z     | x-axis | y-axis
/// 
/// 
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_Plane_t usdGeom_Plane_t;
/// \class UsdGeomPointBased
/// 
/// Base class for all UsdGeomGprims that possess points,
/// providing common attributes such as normals and velocities.
typedef struct usdGeom_PointBased_t usdGeom_PointBased_t;
/// \class UsdGeomPointInstancer
/// 
/// Encodes vectorized instancing of multiple, potentially
/// animated, prototypes (object/instance masters), which can be arbitrary
/// prims/subtrees on a UsdStage.
/// 
/// PointInstancer is a "multi instancer", as it allows multiple prototypes
/// to be scattered among its "points".  We use a UsdRelationship
/// \em prototypes to identify and order all of the possible prototypes, by
/// targeting the root prim of each prototype.  The ordering imparted by
/// relationships associates a zero-based integer with each prototype, and
/// it is these integers we use to identify the prototype of each instance,
/// compactly, and allowing prototypes to be swapped out without needing to
/// reauthor all of the per-instance data.
/// 
/// The PointInstancer schema is designed to scale to billions of instances,
/// which motivates the choice to split the per-instance transformation into
/// position, (quaternion) orientation, and scales, rather than a
/// 4x4 matrix per-instance.  In addition to requiring fewer bytes even if
/// all elements are authored (32 bytes vs 64 for a single-precision 4x4
/// matrix), we can also be selective about which attributes need to animate
/// over time, for substantial data reduction in many cases.
/// 
/// Note that PointInstancer is \em not a Gprim, since it is not a graphical
/// primitive by any stretch of the imagination. It \em is, however,
/// Boundable, since we will sometimes want to treat the entire PointInstancer
/// similarly to a procedural, from the perspective of inclusion or framing.
/// 
/// \section UsdGeomPointInstancer_varyingTopo Varying Instance Identity over Time
/// 
/// PointInstancers originating from simulations often have the characteristic
/// that points/instances are "born", move around for some time period, and then
/// die (or leave the area of interest). In such cases, billions of instances
/// may be birthed over time, while at any \em specific time, only a much
/// smaller number are actually alive.  To encode this situation efficiently,
/// the simulator may re-use indices in the instance arrays, when a particle
/// dies, its index will be taken over by a new particle that may be birthed in
/// a much different location.  This presents challenges both for 
/// identity-tracking, and for motion-blur.
/// 
/// We facilitate identity tracking by providing an optional, animatable
/// \em ids attribute, that specifies the 64 bit integer ID of the particle
/// at each index, at each point in time.  If the simulator keeps monotonically
/// increasing a particle-count each time a new particle is birthed, it will
/// serve perfectly as particle \em ids.
/// 
/// We facilitate motion blur for varying-topology particle streams by
/// optionally allowing per-instance \em velocities and \em angularVelocities
/// to be authored.  If instance transforms are requested at a time between
/// samples and either of the velocity attributes is authored, then we will
/// not attempt to interpolate samples of \em positions or \em orientations.
/// If not authored, and the bracketing samples have the same length, then we
/// will interpolate.
/// 
/// \section UsdGeomPointInstancer_transform Computing an Instance Transform
/// 
/// Each instance's transformation is a combination of the SRT affine transform
/// described by its scale, orientation, and position, applied \em after
/// (i.e. less locally than) the local to parent transformation computed at 
/// the root of the prototype it is instancing. 
/// 
/// If your processing of prototype geometry naturally takes into account the 
/// transform of the prototype root, then this term can be omitted from the 
/// computation of each instance transform, and this can be controlled when 
/// computing instance transformation matrices using the 
/// UsdGeomPointInstancer::PrototypeXformInclusion enumeration.
/// 
/// To understand the computation of the instance transform, in order to put
/// an instance of a PointInstancer into the space of the PointInstancer's 
/// parent prim we do the following:
/// 
/// 1. Apply (most locally) the authored local to parent transformation for 
/// <em>prototypes[protoIndices[i]]</em>
/// 2. If *scales* is authored, next apply the scaling matrix from *scales[i]*
/// 3. If *orientations* is authored: **if *angularVelocities* is authored**, 
/// first multiply *orientations[i]* by the unit quaternion derived by scaling 
/// *angularVelocities[i]* by the \ref UsdGeom_PITimeScaling "time differential" 
/// from the left-bracketing timeSample for *orientation* to the requested 
/// evaluation time *t*, storing the result in *R*, **else** assign *R* 
/// directly from *orientations[i]*.  Apply the rotation matrix derived 
/// from *R*.
/// 4. Apply the translation derived from *positions[i]*. If *velocities* is 
/// authored, apply the translation deriving from *velocities[i]* scaled by 
/// the time differential from the left-bracketing timeSample for *positions* 
/// to the requested evaluation time *t*.
/// 5. Least locally, apply the transformation authored on the PointInstancer 
/// prim itself (or the UsdGeomImageable::ComputeLocalToWorldTransform() of the 
/// PointInstancer to put the instance directly into world space)
/// 
/// If neither *velocities* nor *angularVelocities* are authored, we fallback to
/// standard position and orientation computation logic (using linear
/// interpolation between timeSamples) as described by
/// \ref UsdGeom_VelocityInterpolation .
/// 
/// \anchor UsdGeom_PITimeScaling
/// <b>Scaling Velocities for Interpolation</b>
/// 
/// When computing time-differentials by which to apply velocity or
/// angularVelocity to positions or orientations, we must scale by
/// ( 1.0 / UsdStage::GetTimeCodesPerSecond() ), because velocities are recorded
/// in units/second, while we are interpolating in UsdTimeCode ordinates.
/// 
/// We provide both high and low-level API's for dealing with the
/// transformation as a matrix, both will compute the instance matrices using
/// multiple threads; the low-level API allows the client to cache unvarying
/// inputs so that they need not be read duplicately when computing over
/// time.
/// 
/// See also \ref UsdGeom_VelocityInterpolation .
/// 
/// \section UsdGeomPointInstancer_primvars Primvars on PointInstancer
/// 
/// \ref UsdGeomPrimvar "Primvars" authored on a PointInstancer prim should
/// always be applied to each instance with \em constant interpolation at
/// the root of the instance.  When you are authoring primvars on a 
/// PointInstancer, think about it as if you were authoring them on a 
/// point-cloud (e.g. a UsdGeomPoints gprim).  The same 
/// <A HREF="https://renderman.pixar.com/resources/RenderMan_20/appnote.22.html#classSpecifiers">interpolation rules for points</A> apply here, substituting
/// "instance" for "point".
/// 
/// In other words, the (constant) value extracted for each instance
/// from the authored primvar value depends on the authored \em interpolation
/// and \em elementSize of the primvar, as follows:
/// \li <b>constant</b> or <b>uniform</b> : the entire authored value of the
/// primvar should be applied exactly to each instance.
/// \li <b>varying</b>, <b>vertex</b>, or <b>faceVarying</b>: the first
/// \em elementSize elements of the authored primvar array should be assigned to
/// instance zero, the second \em elementSize elements should be assigned to
/// instance one, and so forth.
/// 
/// 
/// \section UsdGeomPointInstancer_masking Masking Instances: "Deactivating" and Invising
/// 
/// Often a PointInstancer is created "upstream" in a graphics pipeline, and
/// the needs of "downstream" clients necessitate eliminating some of the 
/// instances from further consideration.  Accomplishing this pruning by 
/// re-authoring all of the per-instance attributes is not very attractive,
/// since it may mean destructively editing a large quantity of data.  We
/// therefore provide means of "masking" instances by ID, such that the 
/// instance data is unmolested, but per-instance transform and primvar data
/// can be retrieved with the no-longer-desired instances eliminated from the
/// (smaller) arrays.  PointInstancer allows two independent means of masking
/// instances by ID, each with different features that meet the needs of
/// various clients in a pipeline.  Both pruning features' lists of ID's are
/// combined to produce the mask returned by ComputeMaskAtTime().
/// 
/// \note If a PointInstancer has no authored \em ids attribute, the masking
/// features will still be available, with the integers specifying element
/// position in the \em protoIndices array rather than ID.
/// 
/// \subsection UsdGeomPointInstancer_inactiveIds InactiveIds: List-edited, Unvarying Masking
/// 
/// The first masking feature encodes a list of IDs in a list-editable metadatum
/// called \em inactiveIds, which, although it does not have any similar 
/// impact to stage population as \ref UsdPrim::SetActive() "prim activation",
/// it shares with that feature that its application is uniform over all time.
/// Because it is list-editable, we can \em sparsely add and remove instances
/// from it in many layers.
/// 
/// This sparse application pattern makes \em inactiveIds a good choice when
/// further downstream clients may need to reverse masking decisions made
/// upstream, in a manner that is robust to many kinds of future changes to
/// the upstream data.
/// 
/// See ActivateId(), ActivateIds(), DeactivateId(), DeactivateIds(), 
/// ActivateAllIds()
/// 
/// \subsection UsdGeomPointInstancer_invisibleIds invisibleIds: Animatable Masking
/// 
/// The second masking feature encodes a list of IDs in a time-varying
/// Int64Array-valued UsdAttribute called \em invisibleIds , since it shares
/// with \ref UsdGeomImageable::GetVisibilityAttr() "Imageable visibility"
/// the ability to animate object visibility.
/// 
/// Unlike \em inactiveIds, overriding a set of opinions for \em invisibleIds
/// is not at all straightforward, because one will, in general need to
/// reauthor (in the overriding layer) **all** timeSamples for the attribute
/// just to change one Id's visibility state, so it cannot be authored
/// sparsely.  But it can be a very useful tool for situations like encoding
/// pre-computed camera-frustum culling of geometry when either or both of
/// the instances or the camera is animated.
/// 
/// See VisId(), VisIds(), InvisId(), InvisIds(), VisAllIds()
/// 
/// \section UsdGeomPointInstancer_protoProcessing Processing and Not Processing Prototypes
/// 
/// Any prim in the scenegraph can be targeted as a prototype by the
/// \em prototypes relationship.  We do not, however, provide a specific
/// mechanism for identifying prototypes as geometry that should not be drawn
/// (or processed) in their own, local spaces in the scenegraph.  We
/// encourage organizing all prototypes as children of the PointInstancer
/// prim that consumes them, and pruning "raw" processing and drawing
/// traversals when they encounter a PointInstancer prim; this is what the
/// UsdGeomBBoxCache and UsdImaging engines do.
/// 
/// There \em is a pattern one can deploy for organizing the prototypes
/// such that they will automatically be skipped by basic UsdPrim::GetChildren()
/// or UsdPrimRange traversals.  Usd prims each have a 
/// \ref Usd_PrimSpecifiers "specifier" of "def", "over", or "class".  The
/// default traversals skip over prims that are "pure overs" or classes.  So
/// to protect prototypes from all generic traversals and processing, place
/// them under a prim that is just an "over".  For example,
/// \code
/// 01 def PointInstancer "Crowd_Mid"
/// 02 {
/// 03     rel prototypes = [ </Crowd_Mid/Prototypes/MaleThin_Business>, </Crowd_Mid/Prototypes/MaleThin_Casual> ]
/// 04     
/// 05     over "Prototypes" 
/// 06     {
/// 07          def "MaleThin_Business" (
/// 08              references = [@MaleGroupA/usd/MaleGroupA.usd@</MaleGroupA>]
/// 09              variants = {
/// 10                  string modelingVariant = "Thin"
/// 11                  string costumeVariant = "BusinessAttire"
/// 12              }
/// 13          )
/// 14          { ... }
/// 15          
/// 16          def "MaleThin_Casual"
/// 17          ...
/// 18     }
/// 19 }
/// \endcode
typedef struct usdGeom_PointInstancer_t usdGeom_PointInstancer_t;
/// \class UsdGeomPoints
/// 
/// Points are analogous to the <A HREF="https://renderman.pixar.com/resources/RenderMan_20/appnote.18.html">RiPoints spec</A>.  
/// 
/// Points can be an efficient means of storing and rendering particle
/// effects comprised of thousands or millions of small particles.  Points
/// generally receive a single shading sample each, which should take 
/// \em normals into account, if present.
/// 
/// While not technically UsdGeomPrimvars, the widths and normals also
/// have interpolation metadata.  It's common for authored widths and normals
/// to have constant or varying interpolation.
typedef struct usdGeom_Points_t usdGeom_Points_t;
/// \class UsdGeomPrimvar
/// 
/// Schema wrapper for UsdAttribute for authoring and introspecting attributes
/// that are primvars.
/// 
/// UsdGeomPrimvar provides API for authoring and retrieving the
/// additional data required to encode an attribute as a "Primvar",
/// which is a convenient contraction of RenderMan's "Primitive Variable" 
/// concept, which is represented in Alembic as 
/// "arbitrary geometry parameters" (arbGeomParams).
/// 
/// This includes the attribute's \ref GetInterpolation() "interpolation"
/// across the primitive (which RenderMan refers to as its 
/// \ref Usd_InterpolationVals "class specifier"
/// and Alembic as its <A HREF="https://github.com/alembic/alembic/blob/master/lib/Alembic/AbcGeom/GeometryScope.h#L47"> "geometry scope"</A>);
/// it also includes the attribute's \ref GetElementSize() "elementSize",
/// which states how many values in the value array must be aggregated for
/// each element on the primitive.  An attribute's \ref
/// UsdAttribute::GetTypeName() "TypeName" also factors into the encoding of 
/// Primvar.
/// 
/// \section Usd_What_Is_Primvar What is the Purpose of a Primvar?
/// 
/// There are three key aspects of Primvar identity:
/// \li Primvars define a value that can vary across the primitive on which
///     they are defined, via prescribed interpolation rules
/// \li Taken collectively on a prim, its Primvars describe the "per-primitive
///     overrides" to the material to which the prim is bound.  Different
///     renderers may communicate the variables to the shaders using different
///     mechanisms over which Usd has no control; Primvars simply provide the
///     classification that any renderer should use to locate potential
///     overrides.  Do please note that primvars override parameters on
///     UsdShadeShader objects, \em not 
///     \ref UsdShadeNodeGraph_Interfaces "Interface Attributes" on UsdShadeMaterial
///     prims.
/// \li *Primvars inherit down scene namespace.*  Regular USD attributes only
///     apply to the prim on which they are specified, but primvars implicitly
///     also apply to any child prims, unless those child prims have their
///     own opinions about those primvars.  This capability necessarily
///     entails added cost to check for inherited values, but the benefit
///     is that it allows concise encoding of certain opinions that broadly
///     affect large amounts of geometry.  See
///     UsdGeomImageable::FindInheritedPrimvars().
/// 
/// \section Usd_Creating_and_Accessing_Primvars Creating and Accessing Primvars
/// 
/// The UsdGeomPrimvarsAPI schema provides a complete interface for creating
/// and querying prims for primvars.
/// 
/// The <b>only</b> way to create a new Primvar in scene description is by
/// calling UsdGeomPrimvarsAPI::CreatePrimvar().  One cannot "enhance" or
/// "promote" an already existing attribute into a Primvar, because doing so
/// may require a namespace edit to rename the attribute, which cannot, in
/// general, be done within a single UsdEditContext.  Instead, create a new
/// UsdGeomPrimvar of the desired name using
/// UsdGeomPrimvarsAPI::CreatePrimvar(), and then copy the existing attribute
/// onto the new UsdGeomPrimvar.
/// 
/// Primvar names can contain arbitrary sub-namespaces. The behavior of
/// UsdGeomImageable::GetPrimvar(TfToken const &name) is to prepend "primvars:"
/// onto 'name' if it is not already a prefix, and return the result, which
/// means we do not have any ambiguity between the primvars
/// "primvars:nsA:foo" and "primvars:nsB:foo".  <b>There are reserved keywords
/// that may not be used as the base names of primvars,</b> and attempting to
/// create Primvars of these names will result in a coding error.  The
/// reserved keywords are tokens the Primvar uses internally to encode various
/// features, such as the "indices" keyword used by
/// \ref UsdGeomPrimvar_Indexed_primvars "Indexed Primvars".
/// 
/// \anchor UsdGeomPrimvar_Using_Primvar
/// If a client wishes to access an already-extant attribute as a Primvar,
/// (which may or may not actually be valid Primvar), they can use the
/// speculative constructor; typically, a primvar is only "interesting" if it
/// additionally provides a value.  This might look like:
/// \code
/// UsdGeomPrimvar primvar = UsdGeomPrimvar(usdAttr);
/// if (primvar.HasValue()) {
///     VtValue values;
///     primvar.Get(&values, timeCode);
///     TfToken interpolation = primvar.GetInterpolation();
///     int     elementSize = primvar.GetElementSize();
///     ...
/// }
/// \endcode
/// 
/// or, because Get() returns `true` if and only if it found a value:
/// \code
/// UsdGeomPrimvar primvar = UsdGeomPrimvar(usdAttr);
/// VtValue values;
/// if (primvar.Get(&values, timeCode)) {
///     TfToken interpolation = primvar.GetInterpolation();
///     int     elementSize = primvar.GetElementSize();
///     ...
/// }
/// \endcode
/// 
/// \subsection Usd_Handling_Indexed_Primvars Proper Client Handling of "Indexed" Primvars
/// 
/// As discussed in greater detail in 
/// \ref UsdGeomPrimvar_Indexed_primvars "Indexed Primvars", primvars can 
/// optionally contain a (possibly time-varying) indexing attribute that 
/// establishes a sharing topology for elements of the primvar.  Consumers
/// can always chose to ignore the possibility of indexed data by exclusively 
/// using the ComputeFlattened() API.  If a client wishes to preserve indexing
/// in their processing of a primvar, we suggest a pattern like the following,
/// which accounts for the fact that a stronger layer can 
/// \ref UsdAttribute::Block() "block" a primvar's indexing from a weaker
/// layer, via UsdGeomPrimvar::BlockIndices():
/// \code
/// VtValue values;
/// VtIntArray indices;
/// 
/// if (primvar.Get(&values, timeCode)){
///     if (primvar.GetIndices(&indices, timeCode)){
///         // primvar is indexed: validate/process values and indices together
///     }
///     else {
///         // primvar is not indexed: validate/process values as flat array
///     }
/// }
/// \endcode
/// 
/// \subsection Usd_Primvar_As_Attribute UsdGeomPrimvar and UsdAttribute API
/// 
/// UsdGeomPrimvar presents a small slice of the UsdAttribute API - enough to 
/// extract the data that comprises the "Declaration info", and get/set of
/// the attribute value.  A UsdGeomPrimvar also auto-converts to UsdAttribute, 
/// so you can pass a UsdGeomPrimvar to any function that accepts a UsdAttribute
/// or const-ref thereto.
/// 
/// \section Usd_Primvar_Types Primvar Allowed Scene Description Types and Plurality
/// There are no limitations imposed on the allowable scene description types
/// for Primvars; it is the responsibility of each consuming client to perform
/// renderer-specific conversions, if need be (the USD distribution will include
/// reference RenderMan conversion utilities).
/// 
/// A note about type plurality of Primvars: It is legitimate for a Primvar
/// to be of scalar or array type, and again, consuming clients must be
/// prepared to accommodate both.  However, while it is not possible, in all
/// cases, for USD to \em prevent one from \em changing the type of an attribute
/// in different layers or variants of an asset, it is never a good idea to
/// do so.  This is relevant because, except in a few special cases, it is
/// not possible to encode an \em interpolation of any value greater than 
/// \em constant without providing multiple (i.e. array) data values. Therefore,
/// if there is any possibility that downstream clients might need to change
/// a Primvar's interpolation, the Primvar-creator should encode it as an
/// array rather than a scalar.
/// 
/// Why allow scalar values at all, then?  First, sometimes it brings clarity
/// to (use of) a shader's API to acknowledge that some parameters are meant
/// to be single-valued over a shaded primitive.  Second, many DCC's provide
/// far richer affordances for editing scalars than they do array values, and
/// we feel it is safer to let the content creator make the decision/tradeoff
/// of which kind of flexibility is more relevant, rather than leaving it to
/// an importer/exporter pair to interpret.
/// 
/// Also, like all attributes, Primvars can be time-sampled, and values can
/// be authored and consumed just as any other attribute.  There is currently
/// no validation that the length of value arrays matches to the size 
/// required by a gprim's topology, interpolation, and elementSize.
/// 
/// For consumer convenience, we provide GetDeclarationInfo(), which returns
/// all the type information (other than topology) needed to compute the
/// required array size, which is also all the information required to 
/// prepare the Primvar's value for consumption by a renderer.
/// 
/// \section Usd_UsdGeomPrimvar_Lifetime Lifetime Management and Primvar Validity
/// 
/// UsdGeomPrimvar has an explicit bool operator that validates that
/// the attribute IsDefined() and thus valid for querying and authoring
/// values and metadata.  This is a fairly expensive query that we do 
/// <b>not</b> cache, so if client code retains UsdGeomPrimvar objects, it should 
/// manage its object validity closely, for performance.  An ideal pattern
/// is to listen for UsdNotice::StageContentsChanged notifications, and 
/// revalidate/refetch its retained UsdGeomPrimvar s only then, and otherwise use
/// them without validity checking.
/// 
/// \section Usd_InterpolationVals Interpolation of Geometric Primitive Variables
/// In the following explanation of the meaning of the various kinds/levels
/// of Primvar interpolation, each bolded bullet gives the name of the token
/// in \ref UsdGeomTokens that provides the value.  So to set a Primvar's
/// interpolation to "varying", one would:
/// \code
/// primvar.SetInterpolation(UsdGeomTokens->varying);
/// \endcode
/// 
/// Reprinted and adapted from <a HREF="http://renderman.pixar.com/resources/current/rps/appnote.22.html#classSpecifiers">
/// the RPS documentation</a>, which contains further details, \em interpolation
/// describes how the Primvar will be interpolated over the uv parameter
/// space of a surface primitive (or curve or pointcloud).  The possible
/// values are:
/// \li <b>constant</b> One value remains constant over the entire surface 
///     primitive.
/// \li <b>uniform</b> One value remains constant for each uv patch segment of 
///     the surface primitive (which is a \em face for meshes). 
/// \li <b>varying</b> Four values are interpolated over each uv patch segment 
///     of the surface. Bilinear interpolation is used for interpolation 
///     between the four values.
/// \li <b>vertex</b> Values are interpolated between each vertex in the 
///     surface primitive. The basis function of the surface is used for 
///     interpolation between vertices.
/// \li <b>faceVarying</b> For polygons and subdivision surfaces, four values 
///     are interpolated over each face of the mesh. Bilinear interpolation 
///     is used for interpolation between the four values.
/// 
/// \section Usd_Extending_UsdObject_Classes UsdGeomPrimvar As Example of Attribute Schema
/// 
/// Just as UsdSchemaBase and its subclasses provide the pattern for how to
/// layer schema onto the generic UsdPrim object, UsdGeomPrimvar provides an
/// example of how to layer schema onto a generic UsdAttribute object.  In both
/// cases, the schema object wraps and contains the UsdObject.
/// 
/// \section Usd_UsdGeomPrimvar_Inheritance Primvar Namespace Inheritance
/// 
/// Constant interpolation primvar values can be inherited down namespace.
/// That is, a primvar value set on a prim will also apply to any child
/// prims, unless those children have their own opinions about those named
/// primvars. For complete details on how primvars inherit, see
/// \ref usdGeom_PrimvarInheritance .
/// 
/// \sa UsdGeomImageable::FindInheritablePrimvars().
typedef struct usdGeom_Primvar_t usdGeom_Primvar_t;
typedef struct usdGeom_PrimvarVector_t usdGeom_PrimvarVector_t;
/// \class UsdGeomPrimvarsAPI
/// 
/// UsdGeomPrimvarsAPI encodes geometric "primitive variables",
/// as UsdGeomPrimvar, which interpolate across a primitive's topology,
/// can override shader inputs, and inherit down namespace.
/// 
/// \section usdGeom_PrimvarFetchingAPI Which Method to Use to Retrieve Primvars
/// 
/// While creating primvars is unambiguous (CreatePrimvar()), there are quite
/// a few methods available for retrieving primvars, making it potentially
/// confusing knowing which one to use.  Here are some guidelines:
/// 
/// \li If you are populating a GUI with the primvars already available for 
/// authoring values on a prim, use GetPrimvars().
/// \li If you want all of the "useful" (e.g. to a renderer) primvars
/// available at a prim, including those inherited from ancestor prims, use
/// FindPrimvarsWithInheritance().  Note that doing so individually for many
/// prims will be inefficient.
/// \li To find a particular primvar defined directly on a prim, which may
/// or may not provide a value, use GetPrimvar().
/// \li To find a particular primvar defined on a prim or inherited from
/// ancestors, which may or may not provide a value, use 
/// FindPrimvarWithInheritance().
/// \li To *efficiently* query for primvars using the overloads of
/// FindPrimvarWithInheritance() and FindPrimvarsWithInheritance(), one
/// must first cache the results of FindIncrementallyInheritablePrimvars() for
/// each non-leaf prim on the stage. 
typedef struct usdGeom_PrimvarsAPI_t usdGeom_PrimvarsAPI_t;
/// \class UsdGeomScope
/// 
/// Scope is the simplest grouping primitive, and does not carry the
/// baggage of transformability.  Note that transforms should inherit down
/// through a Scope successfully - it is just a guaranteed no-op from a
/// transformability perspective.
typedef struct usdGeom_Scope_t usdGeom_Scope_t;
/// \class UsdGeomSphere
/// 
/// Defines a primitive sphere centered at the origin.
/// 
/// The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
/// they all pack into the same volume/bounds.
typedef struct usdGeom_Sphere_t usdGeom_Sphere_t;
/// \class UsdGeomSubset
/// 
/// Encodes a subset of a piece of geometry (i.e. a UsdGeomImageable) 
/// as a set of indices. Currently only supports encoding of face-subsets, but 
/// could be extended in the future to support subsets representing edges, 
/// segments, points etc.
/// 
/// To apply to a geometric prim, a GeomSubset prim must be the prim's direct 
/// child in namespace, and possess a concrete defining specifier (i.e. def). 
/// This restriction makes it easy and efficient to discover subsets of a prim. 
/// We might want to relax this restriction if it's common to have multiple 
/// <b>families</b> of subsets on a gprim and if it's useful to be able to 
/// organize subsets belonging to a </b>family</b> under a common scope. See 
/// 'familyName' attribute for more info on defining a family of subsets.
/// 
/// Note that a GeomSubset isn't an imageable (i.e. doesn't derive from
/// UsdGeomImageable). So, you can't author <b>visibility</b> for it or 
/// override its <b>purpose</b>.
/// 
/// Materials are bound to GeomSubsets just as they are for regular 
/// geometry using API available in UsdShade (UsdShadeMaterial::Bind).
/// 
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_Subset_t usdGeom_Subset_t;
typedef struct usdGeom_SubsetVector_t usdGeom_SubsetVector_t;
/// \class UsdGeomVisibilityAPI
/// 
/// 
/// UsdGeomVisibilityAPI introduces properties that can be used to author
/// visibility opinions.
/// 
/// \note
/// Currently, this schema only introduces the attributes that are used to
/// control purpose visibility. Later, this schema will define _all_
/// visibility-related properties and UsdGeomImageable will no longer define
/// those properties.
/// 
/// The purpose visibility attributes added by this schema,
/// _guideVisibility_, _proxyVisibility_, and _renderVisibility_ can each be
/// used to control visibility for geometry of the corresponding purpose
/// values, with the overall _visibility_ attribute acting as an
/// override. I.e., if _visibility_ evaluates to "invisible", purpose
/// visibility is invisible; otherwise, purpose visibility is determined by
/// the corresponding purpose visibility attribute.
/// 
/// Note that the behavior of _guideVisibility_ is subtly different from the
/// _proxyVisibility_ and _renderVisibility_ attributes, in that "guide"
/// purpose visibility always evaluates to either "invisible" or "visible",
/// whereas the other attributes may yield computed values of "inherited" if
/// there is no authored opinion on the attribute or inherited from an
/// ancestor. This is motivated by the fact that, in Pixar"s user workflows,
/// we have never found a need to have all guides visible in a scene by
/// default, whereas we do find that flexibility useful for "proxy" and
/// "render" geometry.
/// 
/// This schema can only be applied to UsdGeomImageable prims. The
/// UseGeomImageable schema provides API for computing the purpose visibility
/// values that result from the attributes introduced by this schema.
/// 
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdGeomTokens.
/// So to set an attribute to the value "rightHanded", use UsdGeomTokens->rightHanded
/// as the value.
typedef struct usdGeom_VisibilityAPI_t usdGeom_VisibilityAPI_t;
/// \class UsdGeomXform
/// 
/// Concrete prim schema for a transform, which implements Xformable 
typedef struct usdGeom_Xform_t usdGeom_Xform_t;
/// \class UsdGeomXformCache
/// 
/// A caching mechanism for transform matrices. For best performance, this
/// object should be reused for multiple CTM queries.
/// 
/// Instances of this type can be copied, though using Swap() may result in
/// better performance.
/// 
/// It is valid to cache prims from multiple stages in a single XformCache.
/// 
/// WARNING: this class does not automatically invalidate cached values based
/// on changes to the stage from which values were cached. Additionally, a
/// separate instance of this class should be used per-thread, calling the Get*
/// methods from multiple threads is not safe, as they mutate internal state.
typedef struct usdGeom_XformCache_t usdGeom_XformCache_t;
/// \class UsdGeomXformCommonAPI
/// 
/// This class provides API for authoring and retrieving a standard set
/// of component transformations which include a scale, a rotation, a 
/// scale-rotate pivot and a translation. The goal of the API is to enhance 
/// component-wise interchange. It achieves this by limiting the set of allowed 
/// basic ops and by specifying the order in which they are applied. In addition
/// to the basic set of ops, the 'resetXformStack' bit can also be set to 
/// indicate whether the underlying xformable resets the parent transformation 
/// (i.e. does not inherit it's parent's transformation). 
/// 
/// \sa UsdGeomXformCommonAPI::GetResetXformStack()
/// \sa UsdGeomXformCommonAPI::SetResetXformStack()
/// 
/// The operator-bool for the class will inform you whether an existing 
/// xformable is compatible with this API.
/// 
/// The scale-rotate pivot is represented by a pair of (translate, 
/// inverse-translate) xformOps around the scale and rotate operations.
/// The rotation operation can be any of the six allowed Euler angle sets.
/// \sa UsdGeomXformOp::Type. 
/// 
/// The xformOpOrder of an xformable that has all of the supported basic ops 
/// is as follows:
/// ["xformOp:translate", "xformOp:translate:pivot", "xformOp:rotateXYZ",
/// "xformOp:scale", "!invert!xformOp:translate:pivot"].
/// 
/// It is worth noting that all of the ops are optional. For example, an 
/// xformable may have only a translate or a rotate. It would still be 
/// considered as compatible with this API. Individual SetTranslate(), 
/// SetRotate(), SetScale() and SetPivot() methods are provided by this API 
/// to allow such sparse authoring.
typedef struct usdGeom_XformCommonAPI_t usdGeom_XformCommonAPI_t;
/// Return type for CreateXformOps().
/// Stores the op of each type that is present on the prim.
/// The order of members in this struct corresponds to the expected op order
/// for XformCommonAPI.
typedef struct usdGeom_XformCommonAPIOps_t usdGeom_XformCommonAPIOps_t;
/// \class UsdGeomXformable
/// 
/// Base class for all transformable prims, which allows arbitrary
/// sequences of component affine transformations to be encoded.
/// 
/// \note 
/// You may find it useful to review \ref UsdGeom_LinAlgBasics while reading
/// this class description.
/// 
/// <b>Supported Component Transformation Operations</b>
/// 
/// UsdGeomXformable currently supports arbitrary sequences of the following
/// operations, each of which can be encoded in an attribute of the proper
/// shape in any supported precision:
/// \li translate - 3D
/// \li scale     - 3D
/// \li rotateX   - 1D angle in degrees
/// \li rotateY   - 1D angle in degrees
/// \li rotateZ   - 1D angle in degrees
/// \li rotateABC - 3D where ABC can be any combination of the six principle
/// Euler Angle sets: XYZ, XZY, YXZ, YZX, ZXY, ZYX.  See
/// \ref usdGeom_rotationPackingOrder "note on rotation packing order"
/// \li orient    - 4D (quaternion)
/// \li transform - 4x4D 
/// 
/// <b>Creating a Component Transformation</b>
/// 
/// To add components to a UsdGeomXformable prim, simply call AddXformOp()
/// with the desired op type, as enumerated in \ref UsdGeomXformOp::Type,
/// and the desired precision, which is one of \ref UsdGeomXformOp::Precision.
/// Optionally, you can also provide an "op suffix" for the operator that 
/// disambiguates it from other components of the same type on the same prim.  
/// Application-specific transform schemas can use the suffixes to fill a role 
/// similar to that played by AbcGeom::XformOp's "Hint" enums for their own 
/// round-tripping logic.
/// 
/// We also provide specific "Add" API for each type, for clarity and 
/// conciseness, e.g. AddTranslateOp(), AddRotateXYZOp() etc.
/// 
/// AddXformOp() will return a UsdGeomXformOp object, which is a schema on a 
/// newly created UsdAttribute that provides convenience API for authoring
/// and computing the component transformations.  The UsdGeomXformOp can then
/// be used to author any number of timesamples and default for the op.
/// 
/// Each successive call to AddXformOp() adds an operator that will be applied
/// "more locally" than the preceding operator, just as if we were pushing
/// transforms onto a transformation stack - which is precisely what should
/// happen when the operators are consumed by a reader.
/// 
/// \note
/// If you can, please try to use the UsdGeomXformCommonAPI, which wraps
/// the UsdGeomXformable with an interface in which Op creation is taken
/// care of for you, and there is a much higher chance that the data you
/// author will be importable without flattening into other DCC's, as it
/// conforms to a fixed set of Scale-Rotate-Translate Ops.
/// 
/// \sa \ref usdGeom_xformableExamples "Using the Authoring API"
/// 
/// <b>Data Encoding and Op Ordering</b>
/// 
/// Because there is no "fixed schema" of operations, all of the attributes
/// that encode transform operations are dynamic, and are scoped in 
/// the namespace "xformOp". The second component of an attribute's name provides
/// the \em type of operation, as listed above.  An "xformOp" attribute can 
/// have additional namespace components derived from the \em opSuffix argument 
/// to the AddXformOp() suite of methods, which provides a preferred way of 
/// naming the ops such that we can have multiple "translate" ops with unique
/// attribute names. For example, in the attribute named 
/// "xformOp:translate:maya:pivot", "translate" is the type of operation and
/// "maya:pivot" is the suffix.
/// 
/// The following ordered list of attribute declarations in usda
/// define a basic Scale-Rotate-Translate with XYZ Euler angles, wherein the
/// translation is double-precision, and the remainder of the ops are single,
/// in which we will:
/// 
/// <ol>
/// <li> Scale by 2.0 in each dimension
/// <li> Rotate about the X, Y, and Z axes by 30, 60, and 90 degrees, respectively
/// <li> Translate by 100 units in the Y direction
/// </ol>
/// 
/// \code
/// float3 xformOp:rotateXYZ = (30, 60, 90)
/// float3 xformOp:scale = (2, 2, 2)
/// double3 xformOp:translate = (0, 100, 0)
/// uniform token[] xformOpOrder = [ "xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale" ]
/// \endcode
/// 
/// The attributes appear in the dictionary order in which USD, by default,
/// sorts them.  To ensure the ops are recovered and evaluated in the correct
/// order, the schema introduces the **xformOpOrder** attribute, which
/// contains the names of the op attributes, in the precise sequence in which
/// they should be pushed onto a transform stack. **Note** that the order is
/// opposite to what you might expect, given the matrix algebra described in
/// \ref UsdGeom_LinAlgBasics.  This also dictates order of op creation,
/// since each call to AddXformOp() adds a new op to the end of the
/// \b xformOpOrder array, as a new "most-local" operation.  See 
/// \ref usdGeom_xformableExamples "Example 2 below" for C++ code that could
/// have produced this USD.
/// 
/// If it were important for the prim's rotations to be independently 
/// overridable, we could equivalently (at some performance cost) encode
/// the transformation also like so:
/// \code
/// float xformOp:rotateX = 30
/// float xformOp:rotateY = 60
/// float xformOp:rotateZ = 90
/// float3 xformOp:scale = (2, 2, 2)
/// double3 xformOp:translate = (0, 100, 0)
/// uniform token[] xformOpOrder = [ "xformOp:translate", "xformOp:rotateZ", "xformOp:rotateY", "xformOp:rotateX", "xformOp:scale" ]
/// \endcode
/// 
/// Again, note that although we are encoding an XYZ rotation, the three
/// rotations appear in the **xformOpOrder** in the opposite order, with Z,
/// followed, by Y, followed by X.
/// 
/// Were we to add a Maya-style scalePivot to the above example, it might 
/// look like the following:
/// \code
/// float3 xformOp:rotateXYZ = (30, 60, 90)
/// float3 xformOp:scale = (2, 2, 2)
/// double3 xformOp:translate = (0, 100, 0)
/// double3 xformOp:translate:scalePivot
/// uniform token[] xformOpOrder = [ "xformOp:translate", "xformOp:rotateXYZ", "xformOp:translate:scalePivot", "xformOp:scale" ]
/// \endcode
/// 
/// <b>Paired "Inverted" Ops</b>
/// 
/// We have been claiming that the ordered list of ops serves as a set
/// of instructions to a transform stack, but you may have noticed in the last
/// example that there is a missing operation - the pivot for the scale op
/// needs to be applied in its inverse-form as a final (most local) op!  In the 
/// AbcGeom::Xform schema, we would have encoded an actual "final" translation
/// op whose value was authored by the exporter as the negation of the pivot's
/// value.  However, doing so would be brittle in USD, given that each op can
/// be independently overridden, and the constraint that one attribute must be
/// maintained as the negation of the other in order for successful
/// re-importation of the schema cannot be expressed in USD.
/// 
/// Our solution leverages the **xformOpOrder** member of the schema, which,
/// in addition to ordering the ops, may also contain one of two special
/// tokens that address the paired op and "stack resetting" behavior.
/// 
/// The "paired op" behavior is encoded as an "!invert!" prefix in 
/// \b xformOpOrder, as the result of an AddXformOp(isInverseOp=True) call.  
/// The \b xformOpOrder for the last example would look like:
/// \code
/// uniform token[] xformOpOrder = [ "xformOp:translate", "xformOp:rotateXYZ", "xformOp:translate:scalePivot", "xformOp:scale", "!invert!xformOp:translate:scalePivot" ]
/// \endcode
/// 
/// When asked for its value via UsdGeomXformOp::GetOpTransform(), an
/// "inverted" Op (i.e. the "inverted" half of a set of paired Ops) will fetch 
/// the value of its paired attribute and return its negation.  This works for 
/// all op types - an error will be issued if a "transform" type op is singular 
/// and cannot be inverted. When getting the authored value of an inverted op 
/// via UsdGeomXformOp::Get(), the raw, uninverted value of the associated
/// attribute is returned.
/// 
/// For the sake of robustness, <b>setting a value on an inverted op is disallowed.</b>
/// Attempting to set a value on an inverted op will result in a coding error 
/// and no value being set. 
/// 
/// <b>Resetting the Transform Stack</b>
/// 
/// The other special op/token that can appear in \em xformOpOrder is
/// \em "!resetXformStack!", which, appearing as the first element of 
/// \em xformOpOrder, indicates this prim should not inherit the transformation
/// of its namespace parent.  See SetResetXformStack()
/// 
/// <b>Expected Behavior for "Missing" Ops</b>
/// 
/// If an importer expects Scale-Rotate-Translate operations, but a prim
/// has only translate and rotate ops authored, the importer should assume
/// an identity scale.  This allows us to optimize the data a bit, if only
/// a few components of a very rich schema (like Maya's) are authored in the
/// app.
/// 
/// \anchor usdGeom_xformableExamples
/// <b>Using the C++ API</b>
/// 
/// #1. Creating a simple transform matrix encoding
/// \snippet examples.cpp CreateMatrixWithDefault
/// 
/// #2. Creating the simple SRT from the example above
/// \snippet examples.cpp CreateExampleSRT
/// 
/// #3. Creating a parameterized SRT with pivot using UsdGeomXformCommonAPI
/// \snippet examples.cpp CreateSRTWithDefaults
/// 
/// #4. Creating a rotate-only pivot transform with animated
/// rotation and translation
/// \snippet examples.cpp CreateAnimatedTransform
typedef struct usdGeom_Xformable_t usdGeom_Xformable_t;
/// \class UsdGeomXformOp
/// 
/// Schema wrapper for UsdAttribute for authoring and computing
/// transformation operations, as consumed by UsdGeomXformable schema.
/// 
/// The semantics of an op are determined primarily by its name, which allows
/// us to decode an op very efficiently.  All ops are independent attributes,
/// which must live in the "xformOp" property namespace.  The op's primary name
/// within the namespace must be one of \ref UsdGeomXformOpTypes, which
/// determines the type of transformation operation, and its secondary name 
/// (or suffix) within the namespace (which is not required to exist), can be 
/// any name that distinguishes it from other ops of the same type. Suffixes 
/// are generally imposed by higer level xform API schemas.
/// 
/// \anchor usdGeom_rotationPackingOrder
/// \note 
/// <b>On packing order of rotateABC triples</b><br>
/// The order in which the axis rotations are recorded in a Vec3* for the
/// six \em rotateABC Euler triples <b>is always the same:</b> vec[0] = X,
/// vec[1] = Y, vec[2] = Z .  The \em A, \em B, \em C in the op name dictate
/// the order in which their corresponding elements are consumed by the 
/// rotation, not how they are laid out.
typedef struct usdGeom_XformOp_t usdGeom_XformOp_t;
typedef struct usdGeom_XformOpVector_t usdGeom_XformOpVector_t;
/// \class UsdPrim
/// 
/// UsdPrim is the sole persistent scenegraph object on a UsdStage, and
/// is the embodiment of a "Prim" as described in the <em>Universal Scene
/// Description Composition Compendium</em>
/// 
/// A UsdPrim is the principal container of other types of scene description.
/// It provides API for accessing and creating all of the contained kinds
/// of scene description, which include:
/// \li UsdVariantSets - all VariantSets on the prim (GetVariantSets(), GetVariantSet())
/// \li UsdReferences - all references on the prim (GetReferences())
/// \li UsdInherits - all inherits on the prim (GetInherits())
/// \li UsdSpecializes - all specializes on the prim (GetSpecializes())
/// 
/// As well as access to the API objects for properties contained within the 
/// prim - UsdPrim as well as all of the following classes are subclasses
/// of UsdObject:
/// \li UsdProperty - generic access to all attributes and relationships.
/// A UsdProperty can be queried and cast to a UsdAttribute or UsdRelationship
/// using UsdObject::Is<>() and UsdObject::As<>(). (GetPropertyNames(), 
/// GetProperties(), GetPropertiesInNamespace(), GetPropertyOrder(),
/// SetPropertyOrder())
/// \li UsdAttribute - access to default and timesampled attribute values, as 
/// well as value resolution information, and attribute-specific metadata 
/// (CreateAttribute(), GetAttribute(), GetAttributes(), HasAttribute())
/// \li UsdRelationship - access to authoring and resolving relationships
/// to other prims and properties (CreateRelationship(), GetRelationship(), 
/// GetRelationships(), HasRelationship())
/// 
/// UsdPrim also provides access to iteration through its prim children,
/// optionally making use of the \ref primFlags.h "prim predicates facility" 
/// (GetChildren(), GetAllChildren(), GetFilteredChildren()).
/// 
/// \section Lifetime Management
/// 
/// Clients acquire UsdPrim objects, which act like weak/guarded pointers
/// to persistent objects owned and managed by their originating UsdStage.
/// We provide the following guarantees for a UsdPrim acquired via 
/// UsdStage::GetPrimAtPath() or UsdStage::OverridePrim() or 
/// UsdStage::DefinePrim():
/// \li As long as no further mutations to the structure of the UsdStage
///     are made, the UsdPrim will still be valid.  Loading and
///     Unloading are considered structural mutations.
/// \li When the UsdStage's structure \em is mutated, the thread performing
///     the mutation will receive a UsdNotice::ObjectsChanged notice
///     after the stage has been reconfigured, which provides details as to
///     what prims may have been created or destroyed, and what prims
///     may simply have changed in some structural way.
/// 
/// Prim access in "reader" threads should be limited to GetPrimAtPath(), which
/// will never cause a mutation to the Stage or its layers.
/// 
/// Please refer to \ref UsdNotice for a listing of
/// the events that could cause UsdNotice::ObjectsChanged to be emitted.
typedef struct usd_Prim_t usd_Prim_t;
/// \class UsdPrimCompositionQuery
/// 
/// Object for making optionally filtered composition queries about a prim.
/// It creates a list of strength ordering UsdPrimCompositionQueryArc that
/// can be filtered by a combination of criteria and returned.
/// 
/// \section Invalidation
/// This object does not listen for change notification.  If a consumer is
/// holding on to a UsdPrimCompositionQuery, it is their responsibility to
/// dispose of it in response to a resync change to the associated prim.
/// Failing to do so may result in incorrect values or crashes due to
/// dereferencing invalid objects.
typedef struct usd_PrimCompositionQuery_t usd_PrimCompositionQuery_t;
/// \class UsdPrimCompositionQueryArc
/// 
/// This represents a composition arc that is returned by a 
/// UsdPrimCompositionQuery. It contains the node in the composition graph that
/// is the target of this arc as well as access to information about how the 
/// arc was introduced to the composition graph.
/// 
/// \section UsdQueryRootArc Root Arc
/// If this arc's \ref GetArcType "arc type" is \ref PcpArcType "PcpArcTypeRoot",
/// then this arc represents the root node of the graph. The composition graph's
/// root arc is not an authored arc; it exists to target the root node of the 
/// graph which represents any local opinions that may be defined for the prim 
/// in the root layer stack.
typedef struct usd_PrimCompositionQueryArc_t usd_PrimCompositionQueryArc_t;
typedef struct usd_PrimCompositionQueryArcVector_t usd_PrimCompositionQueryArcVector_t;
/// Aggregate filter for filtering composition arcs by the previously
/// defined criteria.
typedef struct BBL_ALIGN(4) usd_PrimCompositionQueryFilter_t {
    int arcTypeFilter;
    int dependencyTypeFilter;
    int arcIntroducedFilter;
    int hasSpecsFilter;
} usd_PrimCompositionQueryFilter_t;

/// Class representing the builtin definition of a prim given the schemas 
/// registered in the schema registry. It provides access to the the builtin 
/// properties and metadata of a prim whose type is defined by this definition. 
/// 
/// Instances of this class can only be created by the UsdSchemaRegistry.
typedef struct usd_PrimDefinition_t usd_PrimDefinition_t;
typedef struct usd_PrimFlagsPredicate_t usd_PrimFlagsPredicate_t;
/// \class UsdPrimRange
/// 
/// An forward-iterable range that traverses a subtree of prims rooted at a
/// given prim in depth-first order.
/// 
/// In addition to depth-first order, UsdPrimRange provides the optional ability
/// to traverse in depth-first pre- and post-order wher prims appear twice in
/// the range; first before all descendants and then again immediately after all
/// descendants.  This is useful for maintaining state associated with subtrees,
/// in a stack-like fashion.  See UsdPrimRange::iterator::IsPostVisit() to
/// detect when an iterator is visiting a prim for the second time.
/// 
/// There are several constructors providing different levels of 
/// configurability; ultimately, one can provide a prim predicate for a custom
/// iteration, just as one would use UsdPrim::GetFilteredChildren() in a custom
/// recursion.
/// 
/// Why would one want to use a UsdPrimRange rather than just iterating
/// over the results of UsdPrim::GetFilteredDescendants() ?  Primarily, if
/// one of the following applies:
/// \li You need to perform pre-and-post-order processing
/// \li You may want to prune sub-trees from processing (see UsdPrimRange::iterator::PruneChildren())
/// \li You want to treat the root prim itself uniformly with its 
/// descendents (GetFilteredDescendants() will not return the root prim itself,
/// while UsdPrimRange will - see UsdPrimRange::Stage for an exception).
/// 
/// <b>Using UsdPrimRange in C++</b>
/// 
/// UsdPrimRange provides standard container-like semantics.  For example:
/// \code
/// // simple range-for iteration
/// for (UsdPrim prim: UsdPrimRange(rootPrim)) {
///     ProcessPrim(prim);
/// }
/// 
/// // using stl algorithms
/// std::vector<UsdPrim> meshes;
/// auto range = stage->Traverse();
/// std::copy_if(range.begin(), range.end(), std::back_inserter(meshes),
///              [](UsdPrim const &) { return prim.IsA<UsdGeomMesh>(); });
/// 
/// // iterator-based iterating, with subtree pruning
/// UsdPrimRange range(rootPrim);
/// for (auto iter = range.begin(); iter != range.end(); ++iter) {
///     if (UsdModelAPI(*iter).GetKind() == KindTokens->component) {
///         iter.PruneChildren();
///     }
///     else {
///         nonComponents.push_back(*iter);
///     }
/// }
/// \endcode
/// 
/// <b>Using Usd.PrimRange in python</b>
/// 
/// The python wrapping for PrimRange is python-iterable, so it can
/// used directly as the object of a "for x in..." clause; however in that
/// usage one loses access to PrimRange methods such as PruneChildren() and
/// IsPostVisit().  Simply create the iterator outside the loop to overcome
/// this limitation.  Finally, in python, prim predicates must be combined
/// with bit-wise operators rather than logical operators because the latter
/// are not overridable.
/// \code{.py}
/// # simple iteration
/// for prim in Usd.PrimRange(rootPrim):
///     ProcessPrim(prim)
/// 
/// # filtered range using iterator to invoke iterator methods
/// it = iter(Usd.PrimRange.Stage(stage, Usd.PrimIsLoaded & ~Usd.PrimIsAbstract))
/// for prim in it:
///     if Usd.ModelAPI(prim).GetKind() == Kind.Tokens.component:
///         it.PruneChildren()
///     else:
///         nonComponents.append(prim)
/// \endcode
/// 
/// Finally, since iterators in python are not directly dereferencable, we
/// provide the \em python \em only methods GetCurrentPrim() and IsValid(),
/// documented in the python help system.
typedef struct usd_PrimRange_t usd_PrimRange_t;
/// \class iterator
/// 
/// A forward iterator into a UsdPrimRange.  Iterators are valid for the
/// range they were obtained from.  An iterator \em i obtained from a range
/// \em r is not valid for a range \em c copied from \em r.
typedef struct usd_PrimRangeIterator_t usd_PrimRangeIterator_t;
typedef struct usd_PrimSiblingRange_t usd_PrimSiblingRange_t;
typedef struct usd_PrimSiblingIterator_t usd_PrimSiblingIterator_t;
typedef struct usd_PrimSubtreeRange_t usd_PrimSubtreeRange_t;
/// Class that holds the full type information for a prim. It holds the type
/// name, applied API schema names, and possibly a mapped schema type name which
/// represent a unique full type.
/// The info this holds is used to cache and provide the "real" schema type for 
/// the prim's type name regardless of whether it is a recognized prim type or 
/// not. The optional "mapped schema type name" is used to obtain a valid schema 
/// type for an unrecognized prim type name if the stage provides a fallback 
/// type for the unrecognized type. This class also provides access to the prim
/// definition that defines all the built-in properties and metadata of a prim 
/// of this type.
typedef struct usd_PrimTypeInfo_t usd_PrimTypeInfo_t;
typedef struct usd_PrimVector_t usd_PrimVector_t;
/// \class UsdClipsAPI
/// 
/// UsdClipsAPI is an API schema that provides an interface to
/// a prim's clip metadata. Clips are a "value resolution" feature that 
/// allows one to specify a sequence of usd files (clips) to be consulted, 
/// over time, as a source of varying overrides for the prims at and 
/// beneath this prim in namespace.
/// 
/// SetClipAssetPaths() establishes the set of clips that can be consulted.
/// SetClipActive() specifies the ordering of clip application over time 
/// (clips can be repeated), while SetClipTimes() specifies time-mapping
/// from stage-time to clip-time for the clip active at a given stage-time,
/// which allows for time-dilation and repetition of clips. 
/// Finally, SetClipPrimPath() determines the path within each clip that will 
/// map to this prim, i.e. the location within the clip at which we will look
/// for opinions for this prim. 
/// 
/// The clip asset paths, times and active metadata can also be specified 
/// through template clip metadata. This can be desirable when your set of 
/// assets is very large, as the template metadata is much more concise. 
/// SetClipTemplateAssetPath() establishes the asset identifier pattern of the 
/// set of clips to be consulted. SetClipTemplateStride(), 
/// SetClipTemplateEndTime(), and SetClipTemplateStartTime() specify the range 
/// in which USD will search, based on the template. From the set of resolved 
/// asset paths, times and active will be derived internally.
/// 
/// A prim may have multiple "clip sets" -- named sets of clips that each
/// have their own values for the metadata described above. For example, 
/// a prim might have a clip set named "Clips_1" that specifies some group
/// of clip asset paths, and another clip set named "Clips_2" that uses
/// an entirely different set of clip asset paths. These clip sets are 
/// composed across composition arcs, so clip sets for a prim may be
/// defined in multiple sublayers or references, for example. Individual
/// metadata for a given clip set may be sparsely overridden.
/// 
/// Important facts about clips:            
/// \li Within the layerstack in which clips are established, the           
/// opinions within the clips will be \em weaker than any local opinions
/// in the layerstack, but em stronger than varying opinions coming across
/// references and variants.            
/// \li We will never look for metadata or default opinions in clips            
/// when performing value resolution on the owning stage, since these           
/// quantities must be time-invariant.          
/// 
/// This leads to the common structure in which we reference a model asset
/// on a prim, and then author clips at the same site: the asset reference
/// will provide the topology and unvarying data for the model, while the 
/// clips will provide the time-sampled animation.
/// 
/// For further information, see \ref Usd_Page_ValueClips
typedef struct usd_ClipsAPI_t usd_ClipsAPI_t;
/// \class UsdCollectionAPI
/// 
/// This is a general purpose API schema, used to describe a 
/// collection of heterogeneous objects within the scene. "Objects" here may be 
/// prims or properties belonging to prims or other collections. It's an add-on 
/// schema that can be applied many times to a prim with different collection 
/// names. 
/// 
/// A collection allows an enumeration of a set of paths to include and a 
/// set of paths to exclude.  Whether the descendants of an included
/// path are members of a collection are decided by its expansion rule
/// (see below).  If the collection excludes paths that are not descendents
/// of included paths, the collection implicitly includes the root path
/// &lt;/&gt;.  If such a collection also includes paths that are not
/// descendants of the excluded paths, it is considered invalid, since
/// the intention is ambiguous.
/// 
/// All the properties authored by the schema are namespaced under
/// "collection:". The given name of the collection provides additional 
/// namespacing for the various per-collection properties, which include the 
/// following:
/// 
/// <ul><li><b>uniform token collection:<i>collectionName</i>:expansionRule</b> - 
/// specified how the paths that are included in the collection must be expanded 
/// to determine its members. Possible values include:
/// <ul>
/// <li><b>explicitOnly</b> - only paths in the includes rel targets and not 
/// in the excludes rel targets belong to the collection.
/// </li>
/// <li><b>expandPrims</b> - all the prims at or below the includes rel-
/// targets (and not under the excludes rel-targets) belong to the 
/// collection.  Any property paths included in the collection would, of 
/// course, also be honored. This is the default behavior as it satisfies 
/// most use cases.
/// </li>
/// <li><b>expandPrimsAndProperties</b> - like expandPrims, but also 
/// includes all properties on all matched prims.  We're still not quite 
/// sure what the use cases are for this, but you can use it to capture a 
/// whole lot of UsdObjects very concisely.
/// </li>
/// </ul>
/// </li>
/// <li><b>bool collection:<i>collectionName</i>:includeRoot</b> - boolean
/// attribute indicating whether the pseudo-root path &lt;/&gt; should
/// be counted as one of the included target paths.  The fallback is false.
/// This separate attribute is required because relationships cannot
/// directly target the root.  When expansionRule is explicitOnly, this
/// attribute is ignored.
/// <li><b>rel collection:<i>collectionName</i>:includes</b> - specifies a list 
/// of targets that are included in the collection. This can target prims or 
/// properties directly. A collection can insert the rules of another
/// collection by making its <i>includes</i> relationship target the
/// <b>collection:{collectionName}</b> property on the owning prim of the
/// collection to be included (see UsdCollectionAPI::GetCollectionAttr).
/// It is important to note that including another collection does not
/// guarantee the contents of that collection will be in the final collection;
/// instead, the rules are merged.  This means, for example, an exclude
/// entry may exclude a portion of the included collection.
/// When a collection includes one or more collections, the order in which 
/// targets are added to the includes relationship may become significant, if 
/// there are conflicting opinions about the same path. Targets that are added 
/// later are considered to be stronger than earlier targets for the same path.
/// </li>
/// <li><b>rel collection:<i>collectionName</i>:excludes</b> - specifies a list 
/// of targets that are excluded below the <b>included</b> paths in this 
/// collection. This can target prims or properties directly, but <b>cannot
/// target another collection</b>. This is to keep the membership determining 
/// logic simple, efficient and easier to reason about. Finally, it is invalid 
/// for a collection to exclude paths that are not included in it. The presence
/// of such "orphaned" excluded paths will not affect the set of paths included 
/// in the collection, but may affect the performance of querying membership of 
/// a path in the collection (see UsdCollectionAPI::MembershipQuery::IsPathIncluded) 
/// or of enumerating the objects belonging to the collection (see 
/// UsdCollectionAPI::GetIncludedObjects).
/// </li>
/// <li><b>uniform opaque collection:<i>collectionName</i></b> - opaque 
/// attribute (meaning it can never have a value) that represents the collection
/// for the purpose of allowing another collection to include it. When this
/// property is targeted by another collection's <i>includes</i> relationship,
/// the rules of this collection will be inserted into the rules of the collection
/// that includes it.
/// </li></ul>
/// 
/// <b>Implicit inclusion</b>
/// 
/// In some scenarios it is useful to express a collection that includes
/// everything except certain paths.  To support this, a collection
/// that has an exclude that is not a descendent of any include
/// will include the root path &lt;/&gt;.
/// 
/// <b>Creating collections in C++</b>
/// 
/// \snippet examples.cpp ApplyCollections
/// 
/// 
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref UsdTokens.
/// So to set an attribute to the value "rightHanded", use UsdTokens->rightHanded
/// as the value.
typedef struct usd_CollectionAPI_t usd_CollectionAPI_t;
typedef struct usd_CollectionAPIVector_t usd_CollectionAPIVector_t;
/// \class UsdCollectionMembershipQuery
/// 
/// \brief Represents a flattened view of a collection.  For more information
/// about collections, please see UsdCollectionAPI as a way to encode and
/// retrieve a collection from scene description.  A
/// UsdCollectionMembershipQuery object can be used to answer queries about
/// membership of paths in the collection efficiently.
typedef struct usd_CollectionMembershipQuery_t usd_CollectionMembershipQuery_t;
typedef struct usd_CollectionMembershipQueryPathExpansionRuleMap_t usd_CollectionMembershipQueryPathExpansionRuleMap_t;
/// \class UsdModelAPI
/// 
/// UsdModelAPI is an API schema that provides an interface to a prim's
/// model qualities, if it does, in fact, represent the root prim of a model.
/// 
/// The first and foremost model quality is its \em kind, i.e. the metadata 
/// that establishes it as a model (See KindRegistry).  UsdModelAPI provides
/// various methods for setting and querying the prim's kind, as well as
/// queries (also available on UsdPrim) for asking what category of model
/// the prim is.  See \ref Usd_ModelKind "Kind and Model-ness".
/// 
/// UsdModelAPI also provides access to a prim's \ref Usd_Model_AssetInfo "assetInfo"
/// data.  While any prim \em can host assetInfo, it is common that published
/// (referenced) assets are packaged as models, therefore it is convenient
/// to provide access to the one from the other.
/// 
/// \todo establish an _IsCompatible() override that returns IsModel()
/// \todo GetModelInstanceName()
typedef struct usd_ModelAPI_t usd_ModelAPI_t;
/// \class UsdAttribute
/// 
/// Scenegraph object for authoring and retrieving numeric, string, and array
/// valued data, sampled over time.
/// 
/// The allowed value types for UsdAttribute are dictated by the Sdf
/// ("Scene Description Foundations") core's data model, which we summarize in
/// \ref Usd_Page_Datatypes .
/// 
/// \section Usd_AttributeQualities Attribute Defining Qualities
/// 
/// In addition to its value type, an Attribute has two other defining
/// qualities:
/// \li <b>Variability</b> Expresses whether an attribute is intended to
/// have time samples (GetVariability() == \c SdfVariabilityVarying), or only
/// a default (GetVariability() == \c SdfVariabilityUniform).  For more on
/// reasoning about time samples, 
/// see \ref Usd_AttributeValueMethods "Value & Time-Sample Accessors".
/// 
/// \li <b>Custom</b> Determines whether an attribute belongs to a
/// schema (IsCustom() == \c false), or is a user-defined, custom attribute.
/// schema attributes will always be defined on a prim of the schema type,
/// ans may possess fallback values from the schema, whereas custom 
/// attributes must always first be authored in order to be defined.  Note
/// that \em custom is actually an aspect of UsdProperty, as UsdRelationship
/// can also be custom or provided by a schema.
/// 
/// \section Usd_AttributeExistence Attribute Creation and Existence
/// 
/// One can always create an attribute generically via 
/// UsdPrim::CreateAttribute(), which ensures that an attribute "is defined"
/// in the current \ref UsdEditTarget .  In order to author any metadata or
/// a default or timesample for an attribute, <em>it must first be defined</em>.
/// It is sufficient that the attribute be defined in any one of the layers
/// participating in the stage's current composition; for \em builtin 
/// attributes (those belonging to the owning prim's defining schema, i.e.
/// the most specific subclass of UsdTypedSchema for which prim.IsA<schema>()
/// will evaluate to true) there need be no authored scene description, because
/// a definition is provided by the prim's schema definition.
/// 
/// <b>Creating</b> an attribute does not imply that the attribute has a value.
/// More broadly, in the following code:
/// \code
/// if (UsdAttribute attr = prim.GetAttribute(TfToken("myAttr"))){
///    ...
/// }
/// \endcode
/// 
/// The UsdAttribute passes the bool test, because it is defined; however, 
/// inside the clause, we have no guarantee that attr has a value.
/// 
/// \section Usd_AttributeInterpolation Attribute Value Interpolation
/// 
/// UsdAttribute supports two interpolation behaviors when retrieving
/// attribute values at times where no value is explicitly authored.
/// The desired behavior may be specified via UsdStage::SetInterpolationType.
/// That behavior will be used for all calls to UsdAttribute::Get.
/// 
/// The supported interpolation types are:
/// 
/// \li <b>Held</b> Attribute values are held constant between authored
/// values.  An attribute's value will be equal to the nearest preceding
/// authored value.  If there is no preceding authored value, the value 
/// will be equal to the nearest subsequent value.
/// 
/// \li <b>Linear</b> Attribute values are linearly interpolated between
/// authored values.
/// 
/// Linear interpolation is only supported for certain data types.  See 
/// \ref USD_LINEAR_INTERPOLATION_TYPES for the list of these types.  Types 
/// that do not support linear interpolation will use held interpolation 
/// instead.
/// 
/// Linear interpolation is done element-by-element for array, vector, 
/// and matrix data types.  If linear interpolation is requested for
/// two array values with different sizes, held interpolation will
/// be used instead.
/// 
/// \section Usd_AttributeBlocking Attribute Value Blocking
/// 
/// While prims can effectively be removed from a scene by
/// \ref Usd_ActiveInactive "deactivating them," properties cannot.  However,
/// it is possible to **block an attribute's value**, thus making the attribute
/// behave as if it has a definition (and possibly metadata), but no authored
/// value.  
/// 
/// 
/// One blocks an attribute using UsdAttribute::Block(), which will block the
/// attribute in the stage's current UsdEditTarget, by authoring an
/// SdfValueBlock in the attribute's *default*, and only values authored in
/// weaker layers than the editTarget will be blocked.  If the value block is
/// the strongest authored opinion for the attribute, the HasAuthoredValue()
/// method will return *false*, and the HasValue() and Get() methods will
/// only return *true* if the attribute possesses a fallback value from the
/// prim's schema.  "Unblocking" a blocked attribute is as simple as setting
/// a *default* or timeSample value for the attribute in the same or stronger
/// layer.
/// 
/// \subsection Usd_TimeVaryingAttributeBlocks Time-varying Blocks
/// 
/// The semantics of \ref Usd_ValueClips_Overview "Value Clips" necessitate
/// the ability to selectively block an attribute's value for only some intervals
/// in its authored range of samples.  One can block an attribute's value at
/// time *t* by calling `attr.Set(SdfValueBlock, t)` When an attribute is thusly
/// "partially blocked", UsdAttribute::Get() will succeed only for those time
/// intervals whose left/earlier bracketing timeSample is **not** SdfValueBlock.
/// 
/// Due to this time-varying potential of value blocking, it may be the case 
/// that an attribute's  HasAuthoredValue() and HasValue() methods both return
/// *true* (because they do not and cannot consider time-varying blocks), but
/// Get() may yet return *false* over some intervals.
/// 
/// \section Usd_AssetPathValuedAttributes Attributes of type SdfAssetPath and UsdAttribute::Get()
/// 
/// If an attribute's value type is SdfAssetPath or SdfAssetPathArray, Get()
/// performs extra work to compute the resolved asset paths, using the layer
/// that has the strongest value opinion as the anchor for "relative" asset
/// paths.  Both the unresolved and resolved results are available through
/// SdfAssetPath::GetAssetPath() and SdfAssetPath::GetResolvedPath(),
/// respectively.
/// 
/// Clients that call Get() on many asset-path-valued attributes may wish to
/// employ an ArResolverScopedCache to improve asset path resolution
/// performance.
typedef struct usd_Attribute_t usd_Attribute_t;
/// \class UsdAttributeQuery
/// 
/// Object for efficiently making repeated queries for attribute values.
/// 
/// Retrieving an attribute's value at a particular time requires determining
/// the source of strongest opinion for that value.  Often (i.e.  unless the
/// attribute is affected by \ref Usd_Page_ValueClips "Value Clips") this
/// source does not vary over time.  UsdAttributeQuery uses this fact to
/// speed up repeated value queries by caching the source information for an
/// attribute.  It is safe to use a UsdAttributeQuery for any attribute - if
/// the attribute \em is affected by Value Clips, the performance gain will
/// just be less.
/// 
/// \section Resolve_targets Resolve targets
/// An attribute query can also be constructed for an attribute along with a 
/// UsdResolveTarget. A resolve target allows value resolution to consider only
/// a subrange of the prim stack instead of the entirety of it. All of the methods 
/// of an attribute query created with a resolve target will perform value 
/// resolution within that resolve target. This can be useful for finding the
/// value of an attribute resolved up to a particular layer or for determining
/// if a value authored on layer would be overridden by a stronger opinion.
/// 
/// \section Thread_safety Thread safety
/// This object provides the basic thread-safety guarantee.  Multiple threads
/// may call the value accessor functions simultaneously.
/// 
/// \section Invalidation
/// This object does not listen for change notification.  If a consumer is
/// holding on to a UsdAttributeQuery, it is their responsibility to dispose
/// of it in response to a resync change to the associated attribute. 
/// Failing to do so may result in incorrect values or crashes due to 
/// dereferencing invalid objects.
typedef struct usd_AttributeQuery_t usd_AttributeQuery_t;
typedef struct usd_AttributeQueryVector_t usd_AttributeQueryVector_t;
typedef struct usd_AttributeVector_t usd_AttributeVector_t;
/// \class UsdEditTarget
/// 
/// Defines a mapping from scene graph paths to Sdf spec paths in a
/// SdfLayer where edits should be directed, or up to where to perform partial
/// composition.
/// 
/// A UsdEditTarget can represent an arbitrary point in a composition graph for
/// the purposes of placing edits and resolving values.  This enables editing
/// and resolving across references, classes, variants, and payloads.
/// 
/// In the simplest case, an EditTarget represents a single layer in a stage's
/// local LayerStack.  In this case, the mapping that transforms scene graph
/// paths to spec paths in the layer is the identity function.  That is, the
/// UsdAttribute path '/World/Foo.avar' would map to the SdfPropertySpec path
/// '/World/Foo.avar'.
/// 
/// For a more complex example, suppose '/World/Foo' in 'Shot.usda' is a
/// reference to '/Model' in 'Model.usda'.  One can construct a UsdEditTarget
/// that maps scene graph paths from the 'Shot.usda' stage across the reference
/// to the appropriate paths in the 'Model.usda' layer.  For example, the
/// UsdAttribute '/World/Foo.avar' would map to the SdfPropertySpec
/// '/Model.avar'.  Paths in the stage composed at 'Shot.usda' that weren't
/// prefixed by '/World/Foo' would not have a valid mapping to 'Model.usda'.
/// 
/// EditTargets may also work for any other kind of arc or series of arcs.
/// This allows for editing across variants, classes, and payloads, or in a
/// variant on the far side of a reference, for example.
/// 
/// In addition to mapping scene paths to spec paths for editing, EditTargets
/// may also be used to identify points in the composition graph for partial
/// composition.  Though it doesn't currently exist, a UsdCompose API that takes
/// UsdEditTarget arguments may someday be provided.
/// 
/// For convenience and deployment ease, SdfLayerHandles will implicitly convert
/// to UsdEditTargets.  A UsdEditTarget constructed in this way means direct
/// opinions in a layer in a stage's local LayerStack.
typedef struct usd_EditTarget_t usd_EditTarget_t;
/// \class UsdInherits
/// 
/// A proxy class for applying listOp edits to the inherit paths list for a
/// prim.
/// 
/// All paths passed to the UsdInherits API are expected to be in the 
/// namespace of the owning prim's stage. Subroot prim inherit paths
/// will be translated from this namespace to the  namespace of the current
/// edit target, if necessary. If a path cannot be translated, a coding error 
/// will be issued and no changes will be made. Root prim inherit paths will 
/// not be translated.
typedef struct usd_Inherits_t usd_Inherits_t;
typedef struct usd_MetadataValueMap_t usd_MetadataValueMap_t;
/// \class UsdObject
/// 
/// Base class for Usd scenegraph objects, providing common API.
/// 
/// The commonality between the three types of scenegraph objects in Usd
/// (\ref UsdPrim, \ref UsdAttribute, \ref UsdRelationship) is that they can
/// all have metadata.  Other objects in the API (\ref UsdReferences, 
/// \ref UsdVariantSets, etc.) simply \em are kinds of metadata.
/// 
/// UsdObject's API primarily provides schema for interacting with the metadata
/// common to all the scenegraph objects, as well as generic access to metadata.
/// 
/// section Usd_UsdObject_Lifetime Lifetime Management and Object Validity
/// 
/// Every derived class of UsdObject supports explicit detection of object
/// validity through an \em explicit-bool operator, so client code should always 
/// be able use objects safely, even across edits to the owning UsdStage. 
/// UsdObject classes also perform some level of validity checking upon every 
/// use, in order to facilitate debugging of unsafe code, although we reserve 
/// the right to activate that behavior only in debug builds, if it becomes 
/// compelling to do so for performance reasons.  This per-use checking will 
/// cause a fatal error upon failing the inline validity check, with an error 
/// message describing the namespace location of the dereferenced object on its
/// owning UsdStage.
typedef struct usd_Object_t usd_Object_t;
typedef struct usd_ObjectSet_t usd_ObjectSet_t;
/// \class UsdPayloads
/// 
/// UsdPayloads provides an interface to authoring and introspecting payloads.
/// Payloads behave the same as Usd references except that payloads can be 
/// optionally loaded. 
typedef struct usd_Payloads_t usd_Payloads_t;
/// \class UsdProperty
/// 
/// Base class for UsdAttribute and UsdRelationship scenegraph objects.
/// 
/// UsdProperty has a bool conversion operator that validates that the property
/// IsDefined() and thus valid for querying and authoring values and metadata.
/// This is a fairly expensive query that we do <b>not</b> cache, so if client
/// code retains UsdProperty objects it should manage its object validity
/// closely for performance.  An ideal pattern is to listen for
/// UsdNotice::StageContentsChanged notifications, and revalidate/refetch
/// retained UsdObjects only then and otherwise use them without validity
/// checking.
typedef struct usd_Property_t usd_Property_t;
typedef struct usd_PropertyVector_t usd_PropertyVector_t;
/// \class UsdReferences
/// 
/// UsdReferences provides an interface to authoring and introspecting
/// references in Usd.
/// 
/// References are the primary operator for "encapsulated aggregation" of
/// scene description. \em aggregation means that references let us
/// build up rich scenes by composing scene description recorded in a (most
/// often) different layer.  A scene can reference the same layer many times at
/// different locations in a scene's namespace.  Referenced scene description
/// can be overridden in the referencing (or stronger) layers, allowing each
/// instance of the reference to be directly customized/overridden.
/// \em Encapsulated means that regardless of how much scene description is in
/// the referenced layer, only the scene description under and composed from
/// (via other composition arcs in the referenced layer) the targeted prim
/// will be composed into the aggregate scene.  Multiple references to the
/// same layer will result in the layer being opened and retained in memory
/// only once, although each referencing prim will compose unique
/// \ref PcpPrimIndex "prim indices" for the tree rooted at the referenced prim.
/// 
/// \section Usd_References Important Qualities and Effective Use of References
/// 
/// \li Any prim can host zero, one or multiple references 
/// 
/// \li References are \ref SdfListOp "list editable"; that is, they compose
/// differently than ordinary properties and metadata.  In any given
/// LayerStack, each authored reference operation at the same SdfPath
/// location in each layer (i.e. on the same prim) will compose into an
/// aggregate result by adding to, removing from, or replacing "weaker"
/// references.
/// 
/// \li References can target the same LayerStack in which they are authored,
/// as long as doing so does not introduce a cycle in the composition graph.
/// See \ref Usd_Internal_References
/// 
/// \li The \c identifier component of a reference in the provided API
/// can be a resolvable asset-path to some external layer, empty, in which case 
/// the reference targets the root layer of the LayerStack containing the 
/// referencing layer, or the identifier of an existing anonymous, in-memory-only
/// SdfLayer.  Care should be exercised in the latter case: calling Export() on 
/// an anonymous layer to serialize it to a file will not attempt to replace 
/// any references to anonymous layers with references to file-backed layers.
/// 
/// \li Opinions brought in by reference on an ancestor prim are weaker than
/// opinions brought in by references on a descendant prim.
/// 
/// \subsection Usd_DefaultPrim_References Expressing references without prim paths
/// 
/// References may omit the target prim path if the referenced layer has the
/// 'defaultPrim' metadata set.  In this case, the reference targets the
/// 'defaultPrim' in the referenced layer. A layer's defaultPrim can be
/// authored and accessed on a UsdStage whose root layer is the layer in
/// question: see UsdStage::GetDefaultPrim() and UsdStage::SetDefaultPrim().
/// One can also author defaultPrim directly on an SdfLayer - see
/// SdfLayer::GetDefaultPrim(), SdfLayer::SetDefaultPrim().
/// 
/// \subsection Usd_Internal_References Expressing "internal" references to the containing LayerStack
/// 
/// References may omit the identifier specifying the referenced layer.  This
/// creates an "internal" reference. During composition, the referenced layer 
/// will be resolved to the root layer of the LayerStack containing the 
/// layer where the reference was authored.  See AddInternalReference().
/// 
/// \subsection Usd_Subroot_References Referencing sub-root prims
/// 
/// References may target any prim in a layer. In the simplest and most
/// common case, a root prim in a layer will be referenced. However, 
/// referencing sub-root prims can be useful in a variety of other cases;
/// for example, a user might organize prims into a meaningful hierarchy
/// in a layer for display purposes, then use sub-root references to
/// reference a selection from that hierarchy into a scene.
/// 
/// Sub-root references have subtle behaviors with respect to opinions
/// and composition arcs authored on ancestors of the referenced prim.
/// Users should carefully consider this when deciding whether to use
/// sub-root references. These issues can be avoided by not authoring
/// any properties or metadata on ancestors of prims that are meant to
/// be referenced.
/// 
/// Consider the following example:
/// 
/// \code
/// * shot.usda                                 | * asset.usda
///                                             |
/// #usda 1.0                                   | #usda 1.0
///                                             |
/// over "Class"                                | class "Class"
/// {                                           | {
///     over "B"                                | }
///     {                                       |
///         over "Model"                        | def "A" (
///         {                                   |    inherits = </Class>
///             int a = 3                       | )
///         }                                   | {
///     }                                       |     token purpose = "render"
/// }                                           |
///                                             |     def "B" (
/// over "A"                                    |        variantSets = "type"
/// {                                           |        variants = {
///     over "B" (                              |             string type = "a"
///         # variant selection won't be used   |        }
///         variants = {                        |     )
///             string type = "b"               |     {
///         }                                   |         variantSet "type" = {
///     )                                       |             "a" {
///     {                                       |                 def "Model"
///     }                                       |                 {
/// }                                           |                     int a = 1
///                                             |                 }
/// def "ReferencedModel" (                     |             }
///     references = @./asset.usda@</A/B/Model> |             "b" {
/// )                                           |                 def "Model"
/// {                                           |                 {
/// }                                           |                     int a = 2
///                                             |                 }
///                                             |             }
///                                             |         }
///                                             |     }
///                                             | }
/// \endcode
/// 
/// * Property and metadata opinions on the ancestors of the referenced prim
///   *are not* present in the composed stage and will never contribute to any
///   computations. In this example, the opinion for the attribute /A.purpose 
///   in asset.usda will never be visible in the UsdStage for shot.usda.
/// 
/// * Property and metadata opinions due to ancestral composition arcs
///   *are* present in the composed stage. In this example, the attribute
///   /Class/B/Model.a in shot.usda will be present in the UsdStage for
///   shot.usda, even though the inherit arc is authored on an ancestor
///   of the referenced prim.
/// 
/// * A consequence of these rules is that users might not be able to 
///   override ancestral variant selections that affect the referenced prim.
///   In this example, the Model prim being referenced comes from the 
///   variant selection {type=a} on prim /A/B in asset.usda. The {type=b}
///   variant cannot be selected in shot.usda, even if prims with the
///   same hierarchy happen to exist there. There are various workarounds
///   for this; in this example, the {type=b} variant selection could be
///   authored on /Class/B/Model in shot.usda instead because of the
///   inherit arc that was established on prim /A.
/// 
/// \subsection Usd_Failing_References Reasons why adding a reference may fail, why adding a reference may succeed but still generate errors, and what it all means
/// 
/// AddReference() and SetReferences() can each fail for a number of
/// reasons.  If one of the specified prim targets for one of the references
/// is not a prim, we will generate an error, fail to author any scene
/// description, and return \c false.  If anything goes wrong in attempting
/// to write the reference, we also return false, and the reference will also
/// remain unauthored.  Otherwise, if the reference was successfully
/// authored, we will return \c true.  <b>A successful reference authoring
/// operation may still generate composition errors!</b> Just because the
/// reference you specified was syntactically correct and therefore
/// successfully authored, does not imply it was meaningful. If you wish to
/// ensure that the reference you are about to author will be meaningfully
/// consumable by your stage, you are strongly encouraged to <b>ensure it
/// will resolve to an actual file by using
/// UsdStage::ResolveIdentifierToEditTarget() before authoring the
/// reference.</b>
/// 
/// When adding an internal reference, the given prim path is expected to 
/// be in the namespace of the owning prim's stage. Sub-root prim paths
/// will be translated from this namespace to the namespace of the
/// current edit target, if necessary. If a path cannot be translated,
/// a coding error will be issued and no changes will be made. Non-sub-root
/// paths will not be translated.
/// 
/// Immediately upon successful authoring of the reference (before returning
/// from AddReference(), RemoveReference(), ClearReferences(), or
/// SetReferences()), the UsdStage on which the reference was authored will
/// recompose the subtree rooted at the prim hosting the reference.  If the
/// provided identifier does not resolve to a layer that is already opened or
/// that can be opened in the usd format, \em or if the provided primPath is
/// not an actual prim in that layer, the stage's recomposition will
/// fail, and pass on composition errors to the client.
typedef struct usd_References_t usd_References_t;
/// \class UsdRelationship
/// 
/// A UsdRelationship creates dependencies between scenegraph objects by 
/// allowing a prim to \em target other prims, attributes, or relationships.
/// 
/// \section usd_relationship_chars Relationship Characteristics
/// 
/// A UsdRelationship is a pointer to other objects, which are named by their
/// scenegraph paths.  When authoring relationships, the \em target parameters
/// should be scenegraph paths in the composed namespace of the UsdStage into
/// which you are authoring.  If your edits are targeted to a different
/// layer, across various composition arcs (because you specified a non-default
/// \ref UsdEditTarget), the target's path will be automatically translated
/// into the proper namespace.
/// 
/// A single UsdRelationship can target multiple other objects, which can be 
/// of UsdPrim, UsdAttribute, or UsdRelationship type.  UsdRelationship
/// participates in "list editing", which means that stronger layers in a
/// composed scene can add, remove, or reorder targets authored on the
/// relationship in weaker layers \em without stomping the weaker opinions,
/// although stomping behavior is still possible, via SetTargets().
/// 
/// An authored relationship creates a dependency of the targeting prim on
/// the targeted prim(s).  We consider these dependencies to be "load
/// dependencies", which means that when we load the targeting prim's
/// "load group", we will also load the targeted prims' load groups, to ensure
/// that all the data required to render the model containing the targeting
/// prim is composed and available.
/// 
/// Like UsdAttribute, UsdRelationship objects are meant to be ephemeral,
/// live on the stack, and be cheap to refetch from their owning UsdPrim.
/// 
/// Unlike UsdAttribute s, which can either be uniform over all time
/// or vary in value over time, UsdRelationship is <b>always uniform</b>.
/// 
/// \section usd_relationship_restrictions Relationship Restrictions
/// 
/// When authoring relationship targets in a stage's local LayerStack,
/// all target paths are legal (Note we may restrict this prior to launch
/// to only allowing targeting of already-extant scenegraph objects).  However,
/// a relationship target that is legal in a local LayerStack may become
/// unreachable when the stage's root layer is \em referenced into an 
/// aggregate, and will cause an error when attempting to load/compose
/// the aggregate.
/// 
/// This can happen because references encapsulate just the tree whose root
/// is targeted in the reference - no other scene description in the
/// referenced layer will be composed into the aggregate.  So if some
/// descendant prim of the referenced root targets a relationship to another
/// tree in the same layer, that relationship would dangle, and the client
/// will error in GetTargets() or GetForwardedTargets().
/// 
/// Authoring targets to objects within prototypes is not allowed, since
/// prototype prims do not have a stable identity across runs.  Consumers must 
/// author targets to the object within an instance instead.
/// 
/// Relationships authored in a descendent prim of a referenced prim may not
/// target the referenced prim itself or any of its immediate child properties
/// if the referencing prim is instanceable.  Allowing this would break the
/// ability for this relationship to be instanced and shared by multiple
/// instances -- it would force consumers of relationships within prototypes
/// to resolve targets in the context of each of that prototype's instances.
/// 
/// \section usd_relationship_forwarding Relationship Forwarding
/// 
/// Because a relationship can target another relationship, we can and do
/// provide the ability to resolve chained or \em forwarded relationships.
/// This can be useful in several situations, including:
/// 
/// \li Combining relationships with VariantSets to create demultiplexers.
///     A prim can host a relationship that serves as a "binding post" for
///     other prims to target.  The prim also hosts a "bindingVariant"
///     UsdVariantSet whose variants each modulate the target of the
///     binding-post relationship.  We can now change the \em forwarded target 
///     of all prims targeting the binding-post by simply switching the
///     bindingVariant VariantSet.  We will work through this example in
///     the USD reference manual.
/// \li Defining a relationship as part of a model's interface (so that it can
///     be targeted in model hierarchy with no models loaded), which, inside
///     the model's payload, forwards to prims useful to a client, the set of
///     which may vary depending on the model's configured VariantSets.
typedef struct usd_Relationship_t usd_Relationship_t;
typedef struct usd_RelationshipVector_t usd_RelationshipVector_t;
/// \class UsdResolveInfo
/// 
/// Container for information about the source of an attribute's value, i.e.
/// the 'resolved' location of the attribute.
/// 
/// For more details, see \ref Usd_ValueResolution.
typedef struct usd_ResolveInfo_t usd_ResolveInfo_t;
/// \class UsdResolveTarget
/// 
/// Defines a subrange of nodes and layers within a prim's prim index to 
/// consider when performing value resolution for the prim's attributes.
/// A resolve target can then be passed to UsdAttributeQuery during its 
/// construction to have all of the queries made by the UsdAttributeQuery use
/// the resolve target's subrange for their value resolution.
/// 
/// Resolve targets can be created via methods on UsdPrimCompositionQueryArc to
/// to limit value resolution to a subrange of the prim's composed specs that 
/// are \ref UsdPrimCompositionQueryArc::MakeResolveTargetUpTo "no stronger that arc", 
/// or a subrange of specs that is 
/// \ref UsdPrimCompositionQueryArc::MakeResolveTargetStrongerThan "strictly stronger than that arc" 
/// (optionally providing a particular layer within the arc's layer stack to 
/// further limit the range of specs). 
/// 
/// Alternatively, resolve targets can also be created via methods on UsdPrim
/// that can limit value resolution to either 
/// \ref UsdPrim::MakeResolveTargetUpToEditTarget "up to" or 
/// \ref UsdPrim::MakeResolveTargetStrongerThanEditTarget "stronger than" 
/// the spec that would be edited when setting a value for the prim using the
/// given UsdEditTarget.
/// 
/// Unlike UsdEditTarget, a UsdResolveTarget is only relevant to the prim it
/// is created for and can only be used in a UsdAttributeQuery for attributes 
/// on this prim.
/// 
/// \section Invalidation
/// This object does not listen for change notification.  If a consumer is
/// holding on to a UsdResolveTarget, it is their responsibility to dispose
/// of it in response to a resync change to the associated prim. 
/// Failing to do so may result in incorrect values or crashes due to 
/// dereferencing invalid objects.
typedef struct usd_ResolveTarget_t usd_ResolveTarget_t;
/// \class UsdSpecializes
/// 
/// A proxy class for applying listOp edits to the specializes list for a
/// prim.
/// 
/// All paths passed to the UsdSpecializes API are expected to be in the 
/// namespace of the owning prim's stage. Subroot prim specializes paths  
/// will be translated from this namespace to the namespace of the current 
/// edit target, if necessary. If a path cannot be translated, a coding error 
/// will be issued and no changes will be made. Root prim specializes paths 
/// will not be translated.
typedef struct usd_Specializes_t usd_Specializes_t;
/// \class UsdVariantSet
/// 
/// A UsdVariantSet represents a single VariantSet in USD
/// (e.g. modelingVariant or shadingVariant), which can have multiple
/// variations that express different sets of opinions about the scene
/// description rooted at the prim that defines the VariantSet.
/// 
/// (More detailed description of variants to follow)
typedef struct usd_VariantSet_t usd_VariantSet_t;
/// \class UsdVariantSets
/// 
/// UsdVariantSets represents the collection of
/// \ref UsdVariantSet "VariantSets" that are present on a UsdPrim.
/// 
/// A UsdVariantSets object, retrieved from a prim via 
/// UsdPrim::GetVariantSets(), provides the API for interrogating and modifying
/// the composed list of VariantSets active defined on the prim, and also
/// the facility for authoring a VariantSet \em selection for any of those
/// VariantSets.
typedef struct usd_VariantSets_t usd_VariantSets_t;
/// \class UsdStage
/// 
/// The outermost container for scene description, which owns and presents
/// composed prims as a scenegraph, following the composition recipe
/// recursively described in its associated "root layer".
/// 
/// USD derives its persistent-storage scalability by combining and reusing
/// simple compositions into richer aggregates using referencing and layering
/// with sparse overrides.  Ultimately, every composition (i.e. "scene") is
/// identifiable by its root layer, i.e. the <tt>.usd</tt> file, and a scene
/// is instantiated in an application on a UsdStage that presents a composed
/// view of the scene's root layer.  Each simple composition referenced into
/// a larger composition could be presented on its own UsdStage, at the same
/// (or not) time that it is participating in the larger composition on its
/// own UsdStage; all of the underlying layers will be shared by the two
/// stages, while each maintains its own scenegraph of composed prims.
/// 
/// A UsdStage has sole ownership over the UsdPrim 's with which it is populated,
/// and retains \em shared ownership (with other stages and direct clients of
/// SdfLayer's, via the Sdf_LayerRegistry that underlies all SdfLayer creation
/// methods) of layers.  It provides roughly five categories of API that
/// address different aspects of scene management:
/// 
/// - \ref Usd_lifetimeManagement "Stage lifetime management" methods for
/// constructing and initially populating a UsdStage from an existing layer
/// file, or one that will be created as a result, in memory or on the 
/// filesystem.
/// - \ref Usd_workingSetManagement "Load/unload working set management" methods
/// that allow you to specify which \ref Usd_Payloads "payloads" should be
/// included and excluded from the stage's composition.
/// - \ref Usd_variantManagement "Variant management" methods to manage
/// policy for which variant to use when composing prims that provide
/// a named variant set, but do not specify a selection.
/// - \ref Usd_primManagement "Prim access, creation, and mutation" methods
/// that allow you to find, create, or remove a prim identified by a path on
/// the stage.  This group also provides methods for efficiently traversing the
/// prims on the stage.
/// - \ref Usd_layerManagement "Layers and EditTargets" methods provide access
/// to the layers in the stage's <em>root LayerStack</em> (i.e. the root layer
/// and all of its recursive sublayers), and the ability to set a UsdEditTarget
/// into which all subsequent mutations to objects associated with the stage
/// (e.g. prims, properties, etc) will go.
/// - \ref Usd_stageSerialization "Serialization" methods for "flattening" a
/// composition (to varying degrees), and exporting a completely flattened
/// view of the stage to a string or file.  These methods can be very useful
/// for targeted asset optimization and debugging, though care should be
/// exercized with large scenes, as flattening defeats some of the benefits of
/// referenced scene description, and may produce very large results, 
/// especially in file formats that do not support data de-duplication, like
/// the usda text format!
/// 
/// \section Usd_SessionLayer Stage Session Layers
/// 
/// Each UsdStage can possess an optional "session layer".  The purpose of
/// a session layer is to hold ephemeral edits that modify a UsdStage's contents
/// or behavior in a way that is useful to the client, but should not be
/// considered as permanent mutations to be recorded upon export.  A very 
/// common use of session layers is to make variant selections, to pick a
/// specific LOD or shading variation, for example.  The session layer is
/// also frequently used to override the visibility of geometry 
/// and assets in the scene.  A session layer, if present, contributes to a 
/// UsdStage's identity, for purposes of stage-caching, etc. 
/// 
/// To edit content in a session layer, get the layer's edit target using 
/// stage->GetEditTargetForLocalLayer(stage->GetSessionLayer()) and set that
/// target in the stage by calling SetEditTarget() or creating a UsdEditContext.
typedef struct usd_Stage_t usd_Stage_t;
/// \class UsdStageCache
/// 
/// A strongly concurrency safe collection of UsdStageRefPtr s, enabling
/// sharing across multiple clients and threads.  See UsdStageCacheContext for
/// typical use cases finding UsdStage s in a cache and publishing UsdStage s to
/// a cache.
/// 
/// UsdStageCache is strongly thread safe: all operations other than
/// construction and destruction may be performed concurrently.
/// 
/// Clients typically populate and fetch UsdStage s in caches by binding a
/// UsdStageCacheContext object to a cache, then using the UsdStage::Open() API.
/// See UsdStageCacheContext for more details.  Clients may also populate and
/// fetch directly via UsdStageCache::Insert(), UsdStageCache::Find(),
/// UsdStageCache::FindOneMatching(), and UsdStageCache::FindAllMatching()
/// API.
/// 
/// Caches provide a mechanism that associates a lightweight key,
/// UsdStageCache::Id, with a cached stage.  A UsdStageCache::Id can be
/// converted to and from long int and string.  This can be useful for
/// communicating within a third party application that cannot transmit
/// arbitrary C++ objects.  See UsdStageCache::GetId().
/// 
/// Clients may iterate all cache elements using UsdStageCache::GetAllStages()
/// and remove elements with UsdStageCache::Erase(),
/// UsdStageCache::EraseAll(), and UsdStageCache::Clear().
/// 
/// Note that this class is a regular type: it can be copied and assigned at
/// will.  It is not a singleton.  Also, since it holds a collection of
/// UsdStageRefPtr objects, copying it does not create new UsdStage instances,
/// it merely copies the RefPtrs.
/// 
/// Enabling the USD_STAGE_CACHE TF_DEBUG code will issue debug output for
/// UsdStageCache Find/Insert/Erase/Clear operations.  Also see
/// UsdStageCache::SetDebugName() and UsdStageCache::GetDebugName().
typedef struct usd_StageCache_t usd_StageCache_t;
/// \class Id
/// 
/// A lightweight identifier that may be used to identify a
/// particular cached stage within a UsdStageCache.  An identifier may be
/// converted to and from long int and string, to facilitate use within
/// restricted contexts.
/// 
/// Id objects are only valid with the stage from which they were obtained.
/// It never makes sense to use an Id with a stage other than the one it was
/// obtained from.
typedef struct BBL_ALIGN(4) usd_StageCacheId_t {
    char _bbl_opaque[4];
} usd_StageCacheId_t;

/// \class UsdStageLoadRules
/// 
/// This class represents rules that govern payload inclusion on UsdStages.
/// 
/// Rules are represented as pairs of SdfPath and a Rule enum value, one of
/// AllRule, OnlyRule, and NoneRule.  To understand how rules apply to
/// particular paths, see UsdStageLoadRules::GetEffectiveRuleForPath().
/// 
/// Convenience methods for manipulating rules by typical 'Load' and 'Unload'
/// operations are provided in UsdStageLoadRules::LoadWithoutDescendants(),
/// UsdStageLoadRules::LoadWithDescendants(), UsdStageLoadRules::Unload().
/// 
/// For finer-grained rule crafting, see AddRule().
/// 
/// Remove redundant rules that do not change the effective load state with
/// UsdStageLoadRules::Minimize().
typedef struct usd_StageLoadRules_t usd_StageLoadRules_t;
typedef struct usd_PathStageLoadRulesRulePair_t usd_PathStageLoadRulesRulePair_t;
typedef struct usd_PathStageLoadRulesRulePairVector_t usd_PathStageLoadRulesRulePairVector_t;
/// \class UsdStagePopulationMask
/// 
/// This class represents a mask that may be applied to a UsdStage to limit the
/// set of UsdPrim s it populates.  This is useful in cases where clients have a
/// large scene but only wish to view or query a single or a handful of objects.
/// For example, suppose we have a city block with buildings, cars, crowds of
/// people, and a couple of main characters.  Some tasks might only require
/// looking at a single main character and perhaps a few props.  We can create a
/// population mask with the paths to the character and props of interest and
/// open a UsdStage with that mask.  Usd will avoid populating the other objects
/// in the scene, saving time and memory.  See UsdStage::OpenMasked() for more.
/// 
/// A mask is defined by a set of SdfPath s with the following qualities: they
/// are absolute prim paths (or the absolute root path), and no path in the set
/// is an ancestor path of any other path in the set other than itself.  For
/// example, the set of paths ['/a/b', '/a/c', '/x/y'] is a valid mask, but the
/// set of paths ['/a/b', '/a/b/c', '/x/y'] is redundant, since '/a/b' is an
/// ancestor of '/a/b/c'.  The path '/a/b/c' may be removed.  The GetUnion() and
/// Add() methods ensure that no redundant paths are added.
/// 
/// Default-constructed UsdStagePopulationMask s are considered empty
/// (IsEmpty()) and include no paths.  A population mask containing
/// SdfPath::AbsoluteRootPath() includes all paths.
typedef struct usd_StagePopulationMask_t usd_StagePopulationMask_t;
typedef struct usd_StageRefPtr_t usd_StageRefPtr_t;
typedef struct usd_StageRefPtrVector_t usd_StageRefPtrVector_t;
typedef struct usd_StageWeakPtr_t usd_StageWeakPtr_t;
/// \class UsdTimeCode
/// 
/// Represent a time value, which may be either numeric, holding a double
/// value, or a sentinel value UsdTimeCode::Default().
/// 
/// A UsdTimeCode does \em not represent an 
/// <a href="https://en.wikipedia.org/wiki/SMPTE_timecode">SMPTE timecode</a>,
/// although we may, in future, support conversion functions between the two.
/// Instead, UsdTimeCode is an abstraction that acknowledges that in the 
/// principal domains of use for USD, there are many different ways of encoding 
/// time, and USD must be able to capture and translate between all of them for
/// interchange, retaining as much intent of the authoring application as 
/// possible.
/// 
/// A UsdTimeCode is therefore a unitless, generic time measurement that serves 
/// as the ordinate for time-sampled data in USD files.  A client of USD relies 
/// on the UsdStage (which in turn consults metadata authored in its root layer)
/// to define the mapping of TimeCodes to units like seconds and frames. 
/// 
/// \sa UsdStage::GetStartTimeCode()
/// \sa UsdStage::GetEndTimeCode()
/// \sa UsdStage::GetTimeCodesPerSecond()
/// \sa UsdStage::GetFramesPerSecond()
/// 
/// As described in \ref Usd_ValueResolution , USD optionally provides an
/// unvarying, 'default' value for every attribute.  UsdTimeCode embodies a time
/// value that can either be a floating-point sample time, or the default.
/// 
/// All UsdAttribute and derived API that requires a time parameter defaults
/// to UsdTimeCode::Default() if the parameter is left unspecified, and 
/// auto-constructs from a floating-point argument.
/// 
/// UsdTimeCode::EarliestTime() is provided to aid clients who wish
/// to retrieve the first authored timesample for any attribute.
typedef struct BBL_ALIGN(8) usd_TimeCode_t {
    char _bbl_opaque[8];
} usd_TimeCode_t;

typedef struct usd_TimeCodeVector_t usd_TimeCodeVector_t;
/// Provides a container which may hold any type, and provides introspection
/// and iteration over array types.  See \a VtIsArray for more info.
/// 
/// \section VtValue_Casting Held-type Conversion with VtValue::Cast
/// 
/// VtValue provides a suite of "Cast" methods that convert or create a
/// VtValue holding a requested type (via template parameter, typeid, or
/// type-matching to another VtValue) from the type of the currently-held
/// value.  Clients can add conversions between their own types using the
/// RegisterCast(), RegisterSimpleCast(), and
/// RegisterSimpleBidirectionalCast() methods.  Conversions from plugins can
/// be guaranteed to be registered before they are needed by registering them
/// from within a
/// \code
/// TF_REGISTRY_FUNCTION(VtValue) {
/// }
/// \endcode
/// block.
/// 
/// \subsection VtValue_builtin_conversions Builtin Type Conversion
/// 
/// Conversions between most of the basic "value types" that are intrinsically
/// convertible are builtin, including all numeric types (including Gf's \c
/// half), std::string/TfToken, GfVec* (for vecs of the same dimension), and
/// VtArray<T> for floating-point POD and GfVec of the preceding.
/// 
/// \subsection VtValue_numeric_conversion Numeric Conversion Safety
/// 
/// The conversions between all scalar numeric types are performed with range
/// checks such as provided by boost::numeric_cast(), and will fail, returning
/// an empty VtValue if the source value is out of range of the destination
/// type.
/// 
/// Conversions between GfVec and other compound-numeric types provide no more
/// or less safety or checking than the conversion constructors of the types
/// themselves.  This includes VtArray, even VtArray<T> for T in scalar types
/// that are range-checked when held singly.
typedef struct vt_Value_t vt_Value_t;
typedef struct vt_TokenArray_t vt_TokenArray_t;
typedef struct vt_BoolArray_t vt_BoolArray_t;
typedef struct vt_IntArray_t vt_IntArray_t;
typedef struct vt_FloatArray_t vt_FloatArray_t;
typedef struct vt_DoubleArray_t vt_DoubleArray_t;
/// \class VtDictionary
/// 
/// A map with string keys and VtValue values.
/// 
/// VtDictionary converts to and from a python dictionary as long
/// as each element contains either
///   - another VtDictionary  (converts to a nested dictionary)
///   - std::vector<VtValue>  (converts to a nested list)
///   - VtValue with one of the supported Vt Types.
/// 
/// For a list of functions that can manipulate VtDictionary objects, see the  
/// \link group_vtdict_functions VtDictionary Functions \endlink group page .
typedef struct vt_Dictionary_t vt_Dictionary_t;



/** functions */

int ar_ResolverContext_dtor(ar_ResolverContext_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec2fArray_data(gf_Vec2fArray_t* _this, gf_Vec2f_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec2fArray_data_const(gf_Vec2fArray_t const* _this, gf_Vec2f_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec2fArray_size(gf_Vec2fArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec2fArray_op_index(gf_Vec2fArray_t* _this, size_t index, gf_Vec2f_t* _result);

/// Allows usage of [i].
int gf_Vec2fArray_op_index_const(gf_Vec2fArray_t const* _this, size_t index, gf_Vec2f_t* _result);

int gf_Vec2fArray_new(gf_Vec2fArray_t** _result);

int gf_Vec2fArray_dtor(gf_Vec2fArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec3fArray_data(gf_Vec3fArray_t* _this, gf_Vec3f_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec3fArray_data_const(gf_Vec3fArray_t const* _this, gf_Vec3f_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec3fArray_size(gf_Vec3fArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec3fArray_op_index(gf_Vec3fArray_t* _this, size_t index, gf_Vec3f_t* _result);

/// Allows usage of [i].
int gf_Vec3fArray_op_index_const(gf_Vec3fArray_t const* _this, size_t index, gf_Vec3f_t* _result);

int gf_Vec3fArray_new(gf_Vec3fArray_t** _result);

int gf_Vec3fArray_dtor(gf_Vec3fArray_t* _this);

int gf_Vec3fArrayVector_data(gf_Vec3fArrayVector_t* _this, gf_Vec3fArray_t** _result);

int gf_Vec3fArrayVector_data_const(gf_Vec3fArrayVector_t const* _this, gf_Vec3fArray_t const** _result);

int gf_Vec3fArrayVector_empty(gf_Vec3fArrayVector_t const* _this, bool* _result);

int gf_Vec3fArrayVector_size(gf_Vec3fArrayVector_t const* _this, size_t* _result);

int gf_Vec3fArrayVector_max_size(gf_Vec3fArrayVector_t const* _this, size_t* _result);

int gf_Vec3fArrayVector_reserve(gf_Vec3fArrayVector_t* _this, size_t const _Newcapacity);

int gf_Vec3fArrayVector_capacity(gf_Vec3fArrayVector_t const* _this, size_t* _result);

int gf_Vec3fArrayVector_clear(gf_Vec3fArrayVector_t* _this);

int gf_Vec3fArrayVector_push_back(gf_Vec3fArrayVector_t* _this, gf_Vec3fArray_t const* _Val);

int gf_Vec3fArrayVector_pop_back(gf_Vec3fArrayVector_t* _this);

int gf_Vec3fArrayVector_resize(gf_Vec3fArrayVector_t* _this, size_t const _Newsize);

int gf_Vec3fArrayVector_resize_with(gf_Vec3fArrayVector_t* _this, size_t const _Newsize, gf_Vec3fArray_t const* _Val);

int gf_Vec3fArrayVector_op_index(gf_Vec3fArrayVector_t const* _this, size_t const _Pos, gf_Vec3fArray_t const** _result);

int gf_Vec3fArrayVector_default(gf_Vec3fArrayVector_t** _result);

int gf_Vec3fArrayVector_dtor(gf_Vec3fArrayVector_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec4fArray_data(gf_Vec4fArray_t* _this, gf_Vec4f_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec4fArray_data_const(gf_Vec4fArray_t const* _this, gf_Vec4f_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec4fArray_size(gf_Vec4fArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec4fArray_op_index(gf_Vec4fArray_t* _this, size_t index, gf_Vec4f_t* _result);

/// Allows usage of [i].
int gf_Vec4fArray_op_index_const(gf_Vec4fArray_t const* _this, size_t index, gf_Vec4f_t* _result);

int gf_Vec4fArray_new(gf_Vec4fArray_t** _result);

int gf_Vec4fArray_dtor(gf_Vec4fArray_t* _this);

int gf_Vec4fVector_data(gf_Vec4fVector_t* _this, gf_Vec4f_t** _result);

int gf_Vec4fVector_data_const(gf_Vec4fVector_t const* _this, gf_Vec4f_t const** _result);

int gf_Vec4fVector_empty(gf_Vec4fVector_t const* _this, bool* _result);

int gf_Vec4fVector_size(gf_Vec4fVector_t const* _this, size_t* _result);

int gf_Vec4fVector_max_size(gf_Vec4fVector_t const* _this, size_t* _result);

int gf_Vec4fVector_reserve(gf_Vec4fVector_t* _this, size_t const _Newcapacity);

int gf_Vec4fVector_capacity(gf_Vec4fVector_t const* _this, size_t* _result);

int gf_Vec4fVector_clear(gf_Vec4fVector_t* _this);

int gf_Vec4fVector_push_back(gf_Vec4fVector_t* _this, gf_Vec4f_t const* _Val);

int gf_Vec4fVector_pop_back(gf_Vec4fVector_t* _this);

int gf_Vec4fVector_resize(gf_Vec4fVector_t* _this, size_t const _Newsize);

int gf_Vec4fVector_resize_with(gf_Vec4fVector_t* _this, size_t const _Newsize, gf_Vec4f_t const* _Val);

int gf_Vec4fVector_op_index(gf_Vec4fVector_t const* _this, size_t const _Pos, gf_Vec4f_t* _result);

int gf_Vec4fVector_default(gf_Vec4fVector_t** _result);

int gf_Vec4fVector_dtor(gf_Vec4fVector_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec2hArray_data(gf_Vec2hArray_t* _this, gf_Vec2h_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec2hArray_data_const(gf_Vec2hArray_t const* _this, gf_Vec2h_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec2hArray_size(gf_Vec2hArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec2hArray_op_index(gf_Vec2hArray_t* _this, size_t index, gf_Vec2h_t* _result);

/// Allows usage of [i].
int gf_Vec2hArray_op_index_const(gf_Vec2hArray_t const* _this, size_t index, gf_Vec2h_t* _result);

int gf_Vec2hArray_new(gf_Vec2hArray_t** _result);

int gf_Vec2hArray_dtor(gf_Vec2hArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec3hArray_data(gf_Vec3hArray_t* _this, gf_Vec3h_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec3hArray_data_const(gf_Vec3hArray_t const* _this, gf_Vec3h_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec3hArray_size(gf_Vec3hArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec3hArray_op_index(gf_Vec3hArray_t* _this, size_t index, gf_Vec3h_t* _result);

/// Allows usage of [i].
int gf_Vec3hArray_op_index_const(gf_Vec3hArray_t const* _this, size_t index, gf_Vec3h_t* _result);

int gf_Vec3hArray_new(gf_Vec3hArray_t** _result);

int gf_Vec3hArray_dtor(gf_Vec3hArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec4hArray_data(gf_Vec4hArray_t* _this, gf_Vec4h_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec4hArray_data_const(gf_Vec4hArray_t const* _this, gf_Vec4h_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec4hArray_size(gf_Vec4hArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec4hArray_op_index(gf_Vec4hArray_t* _this, size_t index, gf_Vec4h_t* _result);

/// Allows usage of [i].
int gf_Vec4hArray_op_index_const(gf_Vec4hArray_t const* _this, size_t index, gf_Vec4h_t* _result);

int gf_Vec4hArray_new(gf_Vec4hArray_t** _result);

int gf_Vec4hArray_dtor(gf_Vec4hArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec2dArray_data(gf_Vec2dArray_t* _this, gf_Vec2d_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec2dArray_data_const(gf_Vec2dArray_t const* _this, gf_Vec2d_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec2dArray_size(gf_Vec2dArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec2dArray_op_index(gf_Vec2dArray_t* _this, size_t index, gf_Vec2d_t* _result);

/// Allows usage of [i].
int gf_Vec2dArray_op_index_const(gf_Vec2dArray_t const* _this, size_t index, gf_Vec2d_t* _result);

int gf_Vec2dArray_new(gf_Vec2dArray_t** _result);

int gf_Vec2dArray_dtor(gf_Vec2dArray_t* _this);

int gf_Vec3dVector_data(gf_Vec3dVector_t* _this, gf_Vec3d_t** _result);

int gf_Vec3dVector_data_const(gf_Vec3dVector_t const* _this, gf_Vec3d_t const** _result);

int gf_Vec3dVector_empty(gf_Vec3dVector_t const* _this, bool* _result);

int gf_Vec3dVector_size(gf_Vec3dVector_t const* _this, size_t* _result);

int gf_Vec3dVector_max_size(gf_Vec3dVector_t const* _this, size_t* _result);

int gf_Vec3dVector_reserve(gf_Vec3dVector_t* _this, size_t const _Newcapacity);

int gf_Vec3dVector_capacity(gf_Vec3dVector_t const* _this, size_t* _result);

int gf_Vec3dVector_clear(gf_Vec3dVector_t* _this);

int gf_Vec3dVector_push_back(gf_Vec3dVector_t* _this, gf_Vec3d_t const* _Val);

int gf_Vec3dVector_pop_back(gf_Vec3dVector_t* _this);

int gf_Vec3dVector_resize(gf_Vec3dVector_t* _this, size_t const _Newsize);

int gf_Vec3dVector_resize_with(gf_Vec3dVector_t* _this, size_t const _Newsize, gf_Vec3d_t const* _Val);

int gf_Vec3dVector_op_index(gf_Vec3dVector_t const* _this, size_t const _Pos, gf_Vec3d_t* _result);

int gf_Vec3dVector_default(gf_Vec3dVector_t** _result);

int gf_Vec3dVector_dtor(gf_Vec3dVector_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec3dArray_data(gf_Vec3dArray_t* _this, gf_Vec3d_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec3dArray_data_const(gf_Vec3dArray_t const* _this, gf_Vec3d_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec3dArray_size(gf_Vec3dArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec3dArray_op_index(gf_Vec3dArray_t* _this, size_t index, gf_Vec3d_t* _result);

/// Allows usage of [i].
int gf_Vec3dArray_op_index_const(gf_Vec3dArray_t const* _this, size_t index, gf_Vec3d_t* _result);

int gf_Vec3dArray_new(gf_Vec3dArray_t** _result);

int gf_Vec3dArray_dtor(gf_Vec3dArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec4dArray_data(gf_Vec4dArray_t* _this, gf_Vec4d_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec4dArray_data_const(gf_Vec4dArray_t const* _this, gf_Vec4d_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec4dArray_size(gf_Vec4dArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec4dArray_op_index(gf_Vec4dArray_t* _this, size_t index, gf_Vec4d_t* _result);

/// Allows usage of [i].
int gf_Vec4dArray_op_index_const(gf_Vec4dArray_t const* _this, size_t index, gf_Vec4d_t* _result);

int gf_Vec4dArray_new(gf_Vec4dArray_t** _result);

int gf_Vec4dArray_dtor(gf_Vec4dArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec2iArray_data(gf_Vec2iArray_t* _this, gf_Vec2i_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec2iArray_data_const(gf_Vec2iArray_t const* _this, gf_Vec2i_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec2iArray_size(gf_Vec2iArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec2iArray_op_index(gf_Vec2iArray_t* _this, size_t index, gf_Vec2i_t* _result);

/// Allows usage of [i].
int gf_Vec2iArray_op_index_const(gf_Vec2iArray_t const* _this, size_t index, gf_Vec2i_t* _result);

int gf_Vec2iArray_new(gf_Vec2iArray_t** _result);

int gf_Vec2iArray_dtor(gf_Vec2iArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec3iArray_data(gf_Vec3iArray_t* _this, gf_Vec3i_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec3iArray_data_const(gf_Vec3iArray_t const* _this, gf_Vec3i_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec3iArray_size(gf_Vec3iArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec3iArray_op_index(gf_Vec3iArray_t* _this, size_t index, gf_Vec3i_t* _result);

/// Allows usage of [i].
int gf_Vec3iArray_op_index_const(gf_Vec3iArray_t const* _this, size_t index, gf_Vec3i_t* _result);

int gf_Vec3iArray_new(gf_Vec3iArray_t** _result);

int gf_Vec3iArray_dtor(gf_Vec3iArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Vec4iArray_data(gf_Vec4iArray_t* _this, gf_Vec4i_t** _result);

/// Return a const pointer to this array's data.
int gf_Vec4iArray_data_const(gf_Vec4iArray_t const* _this, gf_Vec4i_t const** _result);

/// Return the total number of elements in this array.
int gf_Vec4iArray_size(gf_Vec4iArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Vec4iArray_op_index(gf_Vec4iArray_t* _this, size_t index, gf_Vec4i_t* _result);

/// Allows usage of [i].
int gf_Vec4iArray_op_index_const(gf_Vec4iArray_t const* _this, size_t index, gf_Vec4i_t* _result);

int gf_Vec4iArray_new(gf_Vec4iArray_t** _result);

int gf_Vec4iArray_dtor(gf_Vec4iArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Matrix2dArray_data(gf_Matrix2dArray_t* _this, gf_Matrix2d_t** _result);

/// Return a const pointer to this array's data.
int gf_Matrix2dArray_data_const(gf_Matrix2dArray_t const* _this, gf_Matrix2d_t const** _result);

/// Return the total number of elements in this array.
int gf_Matrix2dArray_size(gf_Matrix2dArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Matrix2dArray_op_index(gf_Matrix2dArray_t* _this, size_t index, gf_Matrix2d_t* _result);

/// Allows usage of [i].
int gf_Matrix2dArray_op_index_const(gf_Matrix2dArray_t const* _this, size_t index, gf_Matrix2d_t* _result);

int gf_Matrix2dArray_new(gf_Matrix2dArray_t** _result);

int gf_Matrix2dArray_dtor(gf_Matrix2dArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Matrix3dArray_data(gf_Matrix3dArray_t* _this, gf_Matrix3d_t** _result);

/// Return a const pointer to this array's data.
int gf_Matrix3dArray_data_const(gf_Matrix3dArray_t const* _this, gf_Matrix3d_t const** _result);

/// Return the total number of elements in this array.
int gf_Matrix3dArray_size(gf_Matrix3dArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Matrix3dArray_op_index(gf_Matrix3dArray_t* _this, size_t index, gf_Matrix3d_t* _result);

/// Allows usage of [i].
int gf_Matrix3dArray_op_index_const(gf_Matrix3dArray_t const* _this, size_t index, gf_Matrix3d_t* _result);

int gf_Matrix3dArray_new(gf_Matrix3dArray_t** _result);

int gf_Matrix3dArray_dtor(gf_Matrix3dArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Matrix4dArray_data(gf_Matrix4dArray_t* _this, gf_Matrix4d_t** _result);

/// Return a const pointer to this array's data.
int gf_Matrix4dArray_data_const(gf_Matrix4dArray_t const* _this, gf_Matrix4d_t const** _result);

/// Return the total number of elements in this array.
int gf_Matrix4dArray_size(gf_Matrix4dArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Matrix4dArray_op_index(gf_Matrix4dArray_t* _this, size_t index, gf_Matrix4d_t* _result);

/// Allows usage of [i].
int gf_Matrix4dArray_op_index_const(gf_Matrix4dArray_t const* _this, size_t index, gf_Matrix4d_t* _result);

int gf_Matrix4dArray_new(gf_Matrix4dArray_t** _result);

int gf_Matrix4dArray_dtor(gf_Matrix4dArray_t* _this);

int gf_Matrix4dArrayVector_data(gf_Matrix4dArrayVector_t* _this, gf_Matrix4dArray_t** _result);

int gf_Matrix4dArrayVector_data_const(gf_Matrix4dArrayVector_t const* _this, gf_Matrix4dArray_t const** _result);

int gf_Matrix4dArrayVector_empty(gf_Matrix4dArrayVector_t const* _this, bool* _result);

int gf_Matrix4dArrayVector_size(gf_Matrix4dArrayVector_t const* _this, size_t* _result);

int gf_Matrix4dArrayVector_max_size(gf_Matrix4dArrayVector_t const* _this, size_t* _result);

int gf_Matrix4dArrayVector_reserve(gf_Matrix4dArrayVector_t* _this, size_t const _Newcapacity);

int gf_Matrix4dArrayVector_capacity(gf_Matrix4dArrayVector_t const* _this, size_t* _result);

int gf_Matrix4dArrayVector_clear(gf_Matrix4dArrayVector_t* _this);

int gf_Matrix4dArrayVector_push_back(gf_Matrix4dArrayVector_t* _this, gf_Matrix4dArray_t const* _Val);

int gf_Matrix4dArrayVector_pop_back(gf_Matrix4dArrayVector_t* _this);

int gf_Matrix4dArrayVector_resize(gf_Matrix4dArrayVector_t* _this, size_t const _Newsize);

int gf_Matrix4dArrayVector_resize_with(gf_Matrix4dArrayVector_t* _this, size_t const _Newsize, gf_Matrix4dArray_t const* _Val);

int gf_Matrix4dArrayVector_op_index(gf_Matrix4dArrayVector_t const* _this, size_t const _Pos, gf_Matrix4dArray_t const** _result);

int gf_Matrix4dArrayVector_default(gf_Matrix4dArrayVector_t** _result);

int gf_Matrix4dArrayVector_dtor(gf_Matrix4dArrayVector_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Matrix2fArray_data(gf_Matrix2fArray_t* _this, gf_Matrix2f_t** _result);

/// Return a const pointer to this array's data.
int gf_Matrix2fArray_data_const(gf_Matrix2fArray_t const* _this, gf_Matrix2f_t const** _result);

/// Return the total number of elements in this array.
int gf_Matrix2fArray_size(gf_Matrix2fArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Matrix2fArray_op_index(gf_Matrix2fArray_t* _this, size_t index, gf_Matrix2f_t* _result);

/// Allows usage of [i].
int gf_Matrix2fArray_op_index_const(gf_Matrix2fArray_t const* _this, size_t index, gf_Matrix2f_t* _result);

int gf_Matrix2fArray_new(gf_Matrix2fArray_t** _result);

int gf_Matrix2fArray_dtor(gf_Matrix2fArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Matrix3fArray_data(gf_Matrix3fArray_t* _this, gf_Matrix3f_t** _result);

/// Return a const pointer to this array's data.
int gf_Matrix3fArray_data_const(gf_Matrix3fArray_t const* _this, gf_Matrix3f_t const** _result);

/// Return the total number of elements in this array.
int gf_Matrix3fArray_size(gf_Matrix3fArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Matrix3fArray_op_index(gf_Matrix3fArray_t* _this, size_t index, gf_Matrix3f_t* _result);

/// Allows usage of [i].
int gf_Matrix3fArray_op_index_const(gf_Matrix3fArray_t const* _this, size_t index, gf_Matrix3f_t* _result);

int gf_Matrix3fArray_new(gf_Matrix3fArray_t** _result);

int gf_Matrix3fArray_dtor(gf_Matrix3fArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_Matrix4fArray_data(gf_Matrix4fArray_t* _this, gf_Matrix4f_t** _result);

/// Return a const pointer to this array's data.
int gf_Matrix4fArray_data_const(gf_Matrix4fArray_t const* _this, gf_Matrix4f_t const** _result);

/// Return the total number of elements in this array.
int gf_Matrix4fArray_size(gf_Matrix4fArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_Matrix4fArray_op_index(gf_Matrix4fArray_t* _this, size_t index, gf_Matrix4f_t* _result);

/// Allows usage of [i].
int gf_Matrix4fArray_op_index_const(gf_Matrix4fArray_t const* _this, size_t index, gf_Matrix4f_t* _result);

int gf_Matrix4fArray_new(gf_Matrix4fArray_t** _result);

int gf_Matrix4fArray_dtor(gf_Matrix4fArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_QuatdArray_data(gf_QuatdArray_t* _this, gf_Quatd_t** _result);

/// Return a const pointer to this array's data.
int gf_QuatdArray_data_const(gf_QuatdArray_t const* _this, gf_Quatd_t const** _result);

/// Return the total number of elements in this array.
int gf_QuatdArray_size(gf_QuatdArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_QuatdArray_op_index(gf_QuatdArray_t* _this, size_t index, gf_Quatd_t* _result);

/// Allows usage of [i].
int gf_QuatdArray_op_index_const(gf_QuatdArray_t const* _this, size_t index, gf_Quatd_t* _result);

int gf_QuatdArray_new(gf_QuatdArray_t** _result);

int gf_QuatdArray_dtor(gf_QuatdArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_QuatfArray_data(gf_QuatfArray_t* _this, gf_Quatf_t** _result);

/// Return a const pointer to this array's data.
int gf_QuatfArray_data_const(gf_QuatfArray_t const* _this, gf_Quatf_t const** _result);

/// Return the total number of elements in this array.
int gf_QuatfArray_size(gf_QuatfArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_QuatfArray_op_index(gf_QuatfArray_t* _this, size_t index, gf_Quatf_t* _result);

/// Allows usage of [i].
int gf_QuatfArray_op_index_const(gf_QuatfArray_t const* _this, size_t index, gf_Quatf_t* _result);

int gf_QuatfArray_new(gf_QuatfArray_t** _result);

int gf_QuatfArray_dtor(gf_QuatfArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int gf_QuathArray_data(gf_QuathArray_t* _this, gf_Quath_t** _result);

/// Return a const pointer to this array's data.
int gf_QuathArray_data_const(gf_QuathArray_t const* _this, gf_Quath_t const** _result);

/// Return the total number of elements in this array.
int gf_QuathArray_size(gf_QuathArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int gf_QuathArray_op_index(gf_QuathArray_t* _this, size_t index, gf_Quath_t* _result);

/// Allows usage of [i].
int gf_QuathArray_op_index_const(gf_QuathArray_t const* _this, size_t index, gf_Quath_t* _result);

int gf_QuathArray_new(gf_QuathArray_t** _result);

int gf_QuathArray_dtor(gf_QuathArray_t* _this);

/// Minimum value
int gf_Interval_GetMin(gf_Interval_t const* _this, double* _result);

/// Maximum value
int gf_Interval_GetMax(gf_Interval_t const* _this, double* _result);

/// Width of the interval.
/// An empty interval has size 0.
int gf_Interval_GetSize(gf_Interval_t const* _this, double* _result);

int gf_Interval_default(gf_Interval_t* _result);

/// Sets the axis-aligned box and transformation matrix.
int gf_BBox3d_Set(gf_BBox3d_t* _this, gf_Range3d_t const* box, gf_Matrix4d_t const* matrix);

/// Sets the transformation matrix only.  The axis-aligned box is not
/// modified.
int gf_BBox3d_SetMatrix(gf_BBox3d_t* _this, gf_Matrix4d_t const* matrix);

/// Sets the range of the axis-aligned box only.  The transformation
/// matrix is not modified.
int gf_BBox3d_SetRange(gf_BBox3d_t* _this, gf_Range3d_t const* box);

int gf_BBox3d_from_range_and_transform(gf_BBox3d_t** _result);

int gf_BBox3d_from_range(gf_BBox3d_t** _result);

int gf_BBox3d_new(gf_BBox3d_t** _result);

int gf_BBox3d_dtor(gf_BBox3d_t* _this);

/// Sets the transform of the filmback in world space to \p val. 
int gf_Camera_SetTransform(gf_Camera_t* _this, gf_Matrix4d_t const* val);

/// Sets the clipping range in world units.
int gf_Camera_SetClippingRange(gf_Camera_t* _this, gf_Range1f_t const* val);

/// Sets additional arbitrarily oriented clipping planes.
/// A vector (a,b,c,d) encodes a clipping plane that clips off points
/// (x,y,z) with
/// 
///        a * x + b * y + c * z + d * 1 < 0
/// 
/// where (x,y,z) are the coordinates in the camera's space.
int gf_Camera_SetClippingPlanes(gf_Camera_t* _this, gf_Vec4fVector_t const* val);

/// Sets the lens aperture, unitless.
int gf_Camera_SetFStop(gf_Camera_t* _this, float const val);

/// Sets the focus distance in world units.
int gf_Camera_SetFocusDistance(gf_Camera_t* _this, float const val);

/// Sets the focal length in tenths of a world unit (e.g., mm if the world
/// unit is assumed to be cm).
int gf_Camera_SetFocalLength(gf_Camera_t* _this, float const val);

/// Sets the width of the projector aperture in tenths of a world unit
/// (e.g., mm if the world unit is assumed to be cm).
int gf_Camera_SetHorizontalAperture(gf_Camera_t* _this, float const val);

/// Sets the horizontal offset of the projector aperture in tenths of a
/// world unit (e.g., mm if the world unit is assumed to be cm).
int gf_Camera_SetHorizontalApertureOffset(gf_Camera_t* _this, float const val);

/// Sets the height of the projector aperture in tenths of a world unit
/// (e.g., mm if the world unit is assumed to be cm).
int gf_Camera_SetVerticalAperture(gf_Camera_t* _this, float const val);

/// Sets the vertical offset of the projector aperture in tenths of a
/// world unit (e.g., mm if the world unit is assumed to be cm).
int gf_Camera_SetVerticalApertureOffset(gf_Camera_t* _this, float const val);

/// Returns the transform of the filmback in world space.  This is
/// exactly the transform specified via SetTransform().
int gf_Camera_GetTransform(gf_Camera_t const* _this, gf_Matrix4d_t* _result);

/// Returns the clipping range in world units.
int gf_Camera_GetClippingRange(gf_Camera_t const* _this, gf_Range1f_t* _result);

/// Returns additional clipping planes.
int gf_Camera_GetClippingPlanes(gf_Camera_t const* _this, gf_Vec4fVector_t const** _result);

/// Returns the lens aperture.
int gf_Camera_GetFStop(gf_Camera_t const* _this, float* _result);

/// Returns the focus distance in world units.
int gf_Camera_GetFocusDistance(gf_Camera_t const* _this, float* _result);

/// Returns the focal length in tenths of a world unit (e.g., mm if the
/// world unit is assumed to be cm).
int gf_Camera_GetFocalLength(gf_Camera_t const* _this, float* _result);

/// Returns the width of the projector aperture in tenths of a world unit
/// (e.g., mm if the world unit is assumed to be cm).
int gf_Camera_GetHorizontalAperture(gf_Camera_t const* _this, float* _result);

/// Returns the horizontal offset of the projector aperture in tenths of a
/// world unit (e.g., mm if the world unit is assumed to be cm).
/// In particular, an offset is necessary when writing out a stereo camera
/// with finite convergence distance as two cameras.
int gf_Camera_GetHorizontalApertureOffset(gf_Camera_t const* _this, float* _result);

/// Returns the height of the projector aperture in tenths of a world unit
/// (e.g., mm if the world unit is assumed to be cm).
int gf_Camera_GetVerticalAperture(gf_Camera_t const* _this, float* _result);

/// Returns the vertical offset of the projector aperture in tenths of a
/// world unit (e.g., mm if the world unit is assumed to be cm).
int gf_Camera_GetVerticalApertureOffset(gf_Camera_t const* _this, float* _result);

/// Returns the horizontal or vertical field of view in degrees.
int gf_Camera_GetFieldOfView(gf_Camera_t const* _this, int direction, float* _result);

/// Returns the computed, world-space camera frustum.  The frustum
/// will always be that of a Y-up, -Z-looking camera.
int gf_Camera_GetFrustum(gf_Camera_t const* _this, gf_Frustum_t* _result);

/// Sets the frustum to be projective with the given \p aspectRatio
/// and horizontal, respectively, vertical field of view \p fieldOfView
/// (similar to gluPerspective when direction = FOVVertical).
/// 
/// Do not pass values for \p horionztalAperture unless you care about
/// DepthOfField.
int gf_Camera_SetPerspectiveFromAspectRatioAndFieldOfView(gf_Camera_t* _this, float aspectRatio, float fieldOfView, int direction, float horizontalAperture);

/// Sets the frustum to be orthographic such that it has the given
/// \p aspectRatio and such that the orthographic width, respectively,
/// orthographic height (in cm) is equal to \p orthographicSize
/// (depending on direction).
int gf_Camera_SetOrthographicFromAspectRatioAndSize(gf_Camera_t* _this, float aspectRatio, float orthographicSize, int direction);

/// Sets the camera from a view and projection matrix.
/// 
/// Note that the projection matrix does only determine the ratio
/// of aperture to focal length, so there is a choice which defaults
/// to 50mm (or more accurately, 50 tenths of a world unit).
int gf_Camera_SetFromViewAndProjectionMatrix(gf_Camera_t* _this, gf_Matrix4d_t const* viewMatrix, gf_Matrix4d_t const* projMatix, float const focalLength);

int gf_Camera_new(gf_Matrix4d_t const* transform, int projection, float horizontalAperture, float verticalAperture, float horizontalApertureOffset, float verticalApertureOffset, float focalLength, gf_Range1f_t clippingRange, gf_Vec4fVector_t const* clippingPlanes, float fStop, float focusDistance, gf_Camera_t** _result);

int gf_Camera_dtor(gf_Camera_t* _this);

/// Sets up the frustum in a manner similar to gluPerspective().
/// 
/// It sets the projection type to \c GfFrustum::Perspective and
/// sets the window specification so that:
/// 
/// If \a isFovVertical is true, the resulting symmetric frustum encloses
/// an angle of \p fieldOfView degrees in the vertical direction, with \p
/// aspectRatio used to figure the angle in the horizontal direction.
/// 
/// If \a isFovVertical is false, the resulting symmetric frustum encloses
/// an angle of \p fieldOfView degrees in the horizontal direction, with
/// \p aspectRatio used to figure the angle in the vertical direction.
/// 
/// The near and far distances are specified as well. The window
/// coordinates are computed as follows:
/// 
/// \li if isFovVertical:
///     \li top    = tan(fieldOfView / 2)
///     \li right  = top * aspectRatio
/// \li if NOT isFovVertical:
///     \li right    = tan(fieldOfView / 2)
///     \li top  = right / aspectRation
/// \li bottom = -top
/// \li left   = -right
/// \li near   = nearDistance
/// \li far    = farDistance
int gf_Frustum_SetPerspective(gf_Frustum_t* _this, double fieldOfView, bool isFovVertical, double aspectRatio, double nearDistance, double farDistance);

/// Returns the current frustum in the format used by \c SetPerspective().
/// If the current frustum is not a perspective projection, this returns
/// \c false and leaves the parameters untouched.
int gf_Frustum_GetPerspective(gf_Frustum_t const* _this, bool isFovVertical, double* fieldOfView, double* aspectRatio, double* nearDistance, double* farDistance, bool* _result);

/// Returns the horizontal or vertical fov of the frustum. The fov of the
/// frustum is not necessarily the same value as displayed in the viewer.
/// The displayed fov is a function of the focal length or FOV avar. The
/// frustum's fov may be different due to things like lens breathing.
/// 
/// If the frustum is not of type \c GfFrustum::Perspective, the returned
/// FOV will be 0.0.
/// 
/// \note The default value for \c isFovVertical is false so calling \c
/// GetFOV without an argument will return the horizontal field of view
/// which is compatible with menv2x's old GfFrustum::GetFOV routine.
int gf_Frustum_GetFOV(gf_Frustum_t* _this, bool isFovVertical, double* _result);

/// Returns the current frustum in the format used by \c
/// SetOrthographic(). If the current frustum is not an orthographic
/// projection, this returns \c false and leaves the parameters untouched.
int gf_Frustum_GetOrthographic(gf_Frustum_t const* _this, double* left, double* right, double* bottom, double* top, double* nearPlane, double* farPlane, bool* _result);

/// Sets up the frustum in a manner similar to \c glOrtho().
/// 
/// Sets the projection to \c GfFrustum::Orthographic and sets the window
/// and near/far specifications based on the given values.
int gf_Frustum_SetOrthographic(gf_Frustum_t* _this, double left, double right, double bottom, double top, double nearPlane, double farPlane);

/// Modifies the frustum to tightly enclose a sphere with the given center
/// and radius, using the current view direction. The planes of the
/// frustum are adjusted as necessary. The given amount of slack is added
/// to the sphere's radius is used around the sphere to avoid boundary
/// problems.
int gf_Frustum_FitToSphere(gf_Frustum_t* _this, gf_Vec3d_t const* center, double radius, double slack);

/// Transforms the frustum by the given matrix.
/// 
/// The transformation matrix is applied as follows: the position and the
/// direction vector are transformed with the given matrix. Then the
/// length of the new direction vector is used to rescale the near and far
/// plane and the view distance. Finally, the points that define the
/// reference plane are transformed by the matrix. This method assures
/// that the frustum will not be sheared or perspective-projected.
/// 
/// \note Note that this definition means that the transformed frustum
/// does not preserve scales very well. Do \em not use this function to
/// transform a frustum that is to be used for precise operations such as
/// intersection testing.
int gf_Frustum_Transform(gf_Frustum_t* _this, gf_Matrix4d_t const* matrix, gf_Frustum_t** _result);

/// Returns the normalized world-space view direction vector, which is
/// computed by rotating the -z axis by the frustum's rotation.
int gf_Frustum_ComputeViewDirection(gf_Frustum_t const* _this, gf_Vec3d_t* _result);

/// Computes the view frame defined by this frustum. The frame consists of
/// the view direction, up vector and side vector, as shown in this
/// diagram.
/// 
/// \code
///            up
///            ^   ^
///            |  / 
///            | / view
///            |/
///            +- - - - > side
/// \endcode
int gf_Frustum_ComputeViewFrame(gf_Frustum_t const* _this, gf_Vec3d_t* side, gf_Vec3d_t* up, gf_Vec3d_t* view);

/// Computes and returns the world-space look-at point from the eye point
/// (position), view direction (rotation), and view distance.
int gf_Frustum_ComputeLookAtPoint(gf_Frustum_t const* _this, gf_Vec3d_t* _result);

/// Returns a matrix that represents the viewing transformation for this
/// frustum.  That is, it returns the matrix that converts points from
/// world space to eye (frustum) space.
int gf_Frustum_ComputeViewMatrix(gf_Frustum_t const* _this, gf_Matrix4d_t* _result);

/// Returns a matrix that represents the inverse viewing transformation
/// for this frustum.  That is, it returns the matrix that converts points
/// from eye (frustum) space to world space.
int gf_Frustum_ComputeViewInverse(gf_Frustum_t const* _this, gf_Matrix4d_t* _result);

/// Returns a GL-style projection matrix corresponding to the frustum's
/// projection.
int gf_Frustum_ComputeProjectionMatrix(gf_Frustum_t const* _this, gf_Matrix4d_t* _result);

/// Returns the aspect ratio of the frustum, defined as the width of the
/// window divided by the height. If the height is zero or negative, this
/// returns 0.
int gf_Frustum_ComputeAspectRatio(gf_Frustum_t const* _this, double* _result);

/// Returns the world-space corners of the frustum as a vector of 8
/// points, ordered as:
/// \li Left bottom near
/// \li Right bottom near
/// \li Left top near
/// \li Right top near
/// \li Left bottom far
/// \li Right bottom far
/// \li Left top far
/// \li Right top far
int gf_Frustum_ComputeCorners(gf_Frustum_t const* _this, gf_Vec3dVector_t* _result);

/// Returns the world-space corners of the intersection of the frustum
/// with a plane parallel to the near/far plane at distance d from the
/// apex, ordered as:
/// \li Left bottom
/// \li Right bottom
/// \li Left top
/// \li Right top
/// In particular, it gives the partial result of ComputeCorners when given
/// near or far distance.
int gf_Frustum_ComputeCornersAtDistance(gf_Frustum_t const* _this, double d, gf_Vec3dVector_t* _result);

/// Returns a frustum that is a narrowed-down version of this frustum. The
/// new frustum has the same near and far planes, but the other planes are
/// adjusted to be centered on \p windowPos with the new width and height
/// obtained from the existing width and height by multiplying by \p size[0]
/// and \p size[1], respectively.  Finally, the new frustum is clipped
/// against this frustum so that it is completely contained in the existing
/// frustum.
/// 
/// \p windowPos is given in normalized coords (-1 to +1 in both dimensions).
/// \p size is given as a scalar (0 to 1 in both dimensions).
/// 
/// If the \p windowPos or \p size given is outside these ranges, it may
/// result in returning a collapsed frustum.
/// 
/// This method is useful for computing a volume to use for interactive
/// picking.
int gf_Frustum_ComputeNarrowedFrustum(gf_Frustum_t const* _this, gf_Vec2d_t const* windowPos, gf_Vec2d_t const* size, gf_Frustum_t* _result);

/// Builds and returns a \c GfRay that connects the viewpoint to the given
/// 3d point in worldspace.
/// 
/// Contrasted with ComputePickRay(), this method returns a ray whose
/// origin is the eyepoint, while that method returns a ray whose origin
/// is on the near plane.
int gf_Frustum_ComputeRay_to_point(gf_Frustum_t const* _this, gf_Vec3d_t const* worldSpacePos, gf_Ray_t* _result);

/// Builds and returns a \c GfRay that starts at the viewpoint and extends
/// through the given \a windowPos given in normalized coords (-1 to +1 in
/// both dimensions) window position.
/// 
/// Contrasted with ComputePickRay(), this method returns a ray whose
/// origin is the eyepoint, while that method returns a ray whose origin
/// is on the near plane.
int gf_Frustum_ComputeRay_from_screen(gf_Frustum_t const* _this, gf_Vec2d_t const* windowPos, gf_Ray_t* _result);

/// Builds and returns a \c GfRay that can be used for picking that
/// connects the viewpoint to the given 3d point in worldspace.
int gf_Frustum_ComputePickRay_to_point(gf_Frustum_t const* _this, gf_Vec3d_t const* worldSpacePos, gf_Ray_t* _result);

/// Builds and returns a \c GfRay that can be used for picking at the
/// given normalized (-1 to +1 in both dimensions) window position.
/// 
/// Contrasted with ComputeRay(), that method returns a ray whose origin
/// is the eyepoint, while this method returns a ray whose origin is on
/// the near plane.
int gf_Frustum_ComputePickRay_from_screen(gf_Frustum_t const* _this, gf_Vec2d_t const* windowPos, gf_Ray_t* _result);

/// Sets the position of the frustum in world space.
int gf_Frustum_SetPosition(gf_Frustum_t* _this, gf_Vec3d_t const* position);

/// Returns the position of the frustum in world space.
int gf_Frustum_GetPosition(gf_Frustum_t const* _this, gf_Vec3d_t* _result);

/// Returns the orientation of the frustum in world space as a rotation to
/// apply to the -z axis.
int gf_Frustum_GetRotation(gf_Frustum_t const* _this, gf_Rotation_t* _result);

/// Sets the orientation of the frustum in world space as a rotation to
/// apply to the default frame: looking along the -z axis with the +y axis
/// as "up".
int gf_Frustum_SetRotation(gf_Frustum_t* _this, gf_Rotation_t const* rotation);

/// Sets the position and rotation of the frustum from a camera matrix
/// (always from a y-Up camera). The resulting frustum's transform will
/// always represent a right-handed and orthonormal coordinate sytem
/// (scale, shear, and projection are removed from the given \p
/// camToWorldXf).
int gf_Frustum_SetPositionAndRotationFromMatrix(gf_Frustum_t* _this, gf_Matrix4d_t const* camToWorldXf);

/// Sets the window rectangle in the reference plane that defines the
/// left, right, top, and bottom planes of the frustum.
int gf_Frustum_SetWindow(gf_Frustum_t* _this, gf_Range2d_t const* window);

/// Returns the window rectangle in the reference plane.
int gf_Frustum_GetWindow(gf_Frustum_t const* _this, gf_Range2d_t* _result);

/// Sets the near/far interval.
int gf_Frustum_SetNearFar(gf_Frustum_t* _this, gf_Range1d_t const* nearFar);

/// Returns the near/far interval.
int gf_Frustum_GetNearFar(gf_Frustum_t const* _this, gf_Range1d_t* _result);

/// Sets the view distance.
int gf_Frustum_SetViewDistance(gf_Frustum_t* _this, double viewDistance);

/// Returns the view distance.
int gf_Frustum_GetViewDistance(gf_Frustum_t const* _this, double* _result);

/// Sets the projection type.
int gf_Frustum_SetProjectionType(gf_Frustum_t* _this, int projectionType);

/// Returns the projection type.
int gf_Frustum_GetProjectionType(gf_Frustum_t const* _this, int* _result);

/// Returns the depth of the reference plane.
int gf_Frustum_GetReferencePlaneDepth(double* _result);

/// Returns true if the given axis-aligned bbox is inside or intersecting
/// the frustum. Otherwise, it returns false. Useful when doing picking or
/// frustum culling.
int gf_Frustum_Intersects_box(gf_Frustum_t const* _this, gf_BBox3d_t const* bbox, bool* _result);

/// Returns true if the given point is inside or intersecting the frustum.
/// Otherwise, it returns false. 
int gf_Frustum_Intersects_point(gf_Frustum_t const* _this, gf_Vec3d_t const* point, bool* _result);

/// Returns \c true if the line segment formed by the given points is
/// inside or intersecting the frustum.  Otherwise, it returns false.
int gf_Frustum_Intersects_line(gf_Frustum_t const* _this, gf_Vec3d_t const* p0, gf_Vec3d_t const* p1, bool* _result);

/// Returns \c true if the triangle formed by the given points is inside
/// or intersecting the frustum.  Otherwise, it returns false.
int gf_Frustum_Intersects_triangle(gf_Frustum_t const* _this, gf_Vec3d_t const* p0, gf_Vec3d_t const* p1, gf_Vec3d_t const* p2, bool* _result);

/// Returns \c true if the bbox volume intersects the view volume given by
/// the view-projection matrix, erring on the side of false positives for
/// efficiency.
/// 
/// This method is intended for cases where a GfFrustum is not available
/// or when the view-projection matrix yields a view volume that is not
/// expressable as a GfFrustum.
/// 
/// Because it errs on the side of false positives, it is suitable for
/// early-out tests such as draw or intersection culling.
int gf_Frustum_IntersectsViewVolume(gf_BBox3d_t const* bbox, gf_Matrix4d_t const* vpMat, bool* _result);

int gf_Frustum_from_transform(gf_Frustum_t** _result);

int gf_Frustum_from_position_and_rotation(gf_Frustum_t** _result);

int gf_Frustum_new(gf_Frustum_t** _result);

int gf_Frustum_dtor(gf_Frustum_t* _this);

/// Returns the starting point of the segment.
int gf_Ray_GetStartPoint(gf_Ray_t const* _this, gf_Vec3d_t* _result);

/// Returns the direction vector of the segment. This is not guaranteed to
/// be unit length.
int gf_Ray_GetDirection(gf_Ray_t const* _this, gf_Vec3d_t* _result);

/// Returns the point that is \p distance units from the starting point
/// along the direction vector, expressed in parametic distance.
int gf_Ray_GetPoint(gf_Ray_t const* _this, double distance, gf_Vec3d_t* _result);

int js_Array_data(js_Array_t* _this, js_Value_t** _result);

int js_Array_data_const(js_Array_t const* _this, js_Value_t const** _result);

int js_Array_empty(js_Array_t const* _this, bool* _result);

int js_Array_size(js_Array_t const* _this, size_t* _result);

int js_Array_max_size(js_Array_t const* _this, size_t* _result);

int js_Array_reserve(js_Array_t* _this, size_t const _Newcapacity);

int js_Array_capacity(js_Array_t const* _this, size_t* _result);

int js_Array_clear(js_Array_t* _this);

int js_Array_push_back(js_Array_t* _this, js_Value_t const* _Val);

int js_Array_pop_back(js_Array_t* _this);

int js_Array_resize(js_Array_t* _this, size_t const _Newsize);

int js_Array_resize_with(js_Array_t* _this, size_t const _Newsize, js_Value_t const* _Val);

int js_Array_op_index(js_Array_t const* _this, size_t const _Pos, js_Value_t const** _result);

int js_Array_default(js_Array_t** _result);

int js_Array_dtor(js_Array_t* _this);

int js_Object_dtor(js_Object_t* _this);

/// Returns the object held by this value. If this value is not holding an
/// object, this method raises a coding error and an empty object is
/// returned.
int js_Value_GetJsObject(js_Value_t const* _this, js_Object_t const** _result);

/// Returns the array held by this value. If this value is not holding an
/// array, this method raises a coding error and an empty array is
/// returned.
int js_Value_GetJsArray(js_Value_t const* _this, js_Array_t const** _result);

/// Returns the bool held by this value. If this value is not holding a
/// bool, this method raises a coding error and false is returned.
int js_Value_GetBool(js_Value_t const* _this, bool* _result);

/// Returns the integer held by this value. If this value is not holding
/// an int, this method raises a coding error and zero is returned. If the
/// value is holding a 64-bit integer larger than the platform int may
/// hold, the value is truncated.
int js_Value_GetInt(js_Value_t const* _this, int* _result);

/// Returns the 64-bit integer held by this value. If this value is not
/// holding a 64-bit integer, this method raises a coding error and zero
/// is returned.
int js_Value_GetInt64(js_Value_t const* _this, int64_t* _result);

/// Returns the 64-bit unsigned integer held by this value. If this value
/// is not holding a 64-bit unsigned integer, this method raises a coding
/// error and zero is returned.
int js_Value_GetUInt64(js_Value_t const* _this, uint64_t* _result);

/// Returns the double held by this value. If this value is not holding a
/// double, this method raises a coding error and zero is returned.
int js_Value_GetReal(js_Value_t const* _this, double* _result);

/// Returns true if this value is holding an object type.
int js_Value_IsObject(js_Value_t const* _this, bool* _result);

/// Returns true if this value is holding an array type.
int js_Value_IsArray(js_Value_t const* _this, bool* _result);

/// Returns true if this value is holding a boolean type.
int js_Value_IsBool(js_Value_t const* _this, bool* _result);

/// Returns true if this value is holding an integer type.
int js_Value_IsInt(js_Value_t const* _this, bool* _result);

/// Returns true if this value is holding a 64-bit unsigned integer.
int js_Value_IsUInt64(js_Value_t const* _this, bool* _result);

/// Returns true if this value is holding a real type.
int js_Value_IsReal(js_Value_t const* _this, bool* _result);

int js_Value_from_double(js_Value_t** _result);

int js_Value_from_uint64_t(js_Value_t** _result);

int js_Value_from_int64_t(js_Value_t** _result);

int js_Value_from_int(js_Value_t** _result);

int js_Value_from_bool(js_Value_t** _result);

int js_Value_from_string(js_Value_t** _result);

int js_Value_from_array(js_Value_t** _result);

int js_Value_from_object(js_Value_t** _result);

int js_Value_new(js_Value_t** _result);

int js_Value_dtor(js_Value_t* _this);

/// Return true if this map function is the null function.
/// For a null function, MapSourceToTarget() always returns an empty path.
int pcp_MapFunction_IsNull(pcp_MapFunction_t const* _this, bool* _result);

/// Return true if the map function is the identity function.
/// The identity function has an identity path mapping and time offset.
int pcp_MapFunction_IsIdentity(pcp_MapFunction_t const* _this, bool* _result);

/// Return true if the map function uses the identity path mapping.
/// If true, MapSourceToTarget() always returns the path unchanged.
/// However, this map function may have a non-identity time offset.
int pcp_MapFunction_IsIdentityPathMapping(pcp_MapFunction_t const* _this, bool* _result);

/// Return true if the map function maps the absolute root path to the
/// absolute root path, false otherwise.
int pcp_MapFunction_HasRootIdentity(pcp_MapFunction_t const* _this, bool* _result);

/// Map a path in the source namespace to the target.
/// If the path is not in the domain, returns an empty path.
int pcp_MapFunction_MapSourceToTarget(pcp_MapFunction_t const* _this, sdf_Path_t const* path, sdf_Path_t* _result);

/// Map a path in the target namespace to the source.
/// If the path is not in the co-domain, returns an empty path.
int pcp_MapFunction_MapTargetToSource(pcp_MapFunction_t const* _this, sdf_Path_t const* path, sdf_Path_t* _result);

/// Compose this map over the given map function.
/// The result will represent the application of f followed by
/// the application of this function.
int pcp_MapFunction_Compose(pcp_MapFunction_t const* _this, pcp_MapFunction_t const* f, pcp_MapFunction_t* _result);

/// Compose this map function over a hypothetical map function that has an
/// identity path mapping and \p offset.  This is equivalent to building
/// such a map function and invoking Compose(), but is faster.
int pcp_MapFunction_ComposeOffset(pcp_MapFunction_t const* _this, sdf_LayerOffset_t const* newOffset, pcp_MapFunction_t* _result);

/// Return the inverse of this map function.
/// This returns a true inverse \p inv: for any path p in this function's
/// domain that it maps to p', inv(p') -> p.
int pcp_MapFunction_GetInverse(pcp_MapFunction_t const* _this, pcp_MapFunction_t* _result);

/// The set of path mappings, from source to target.
int pcp_MapFunction_GetSourceToTargetMap(pcp_MapFunction_t const* _this, pcp_MapFunctionPathMap_t* _result);

/// The time offset of the mapping.
int pcp_MapFunction_GetTimeOffset(pcp_MapFunction_t const* _this, sdf_LayerOffset_t const** _result);

/// Returns a string representation of this mapping for debugging
/// purposes.
int pcp_MapFunction_GetString(pcp_MapFunction_t const* _this, std_String_t* _result);

/// Return a size_t hash for this map function.
int pcp_MapFunction_Hash(pcp_MapFunction_t const* _this, size_t* _result);

/// Constructs a map function with the given arguments.
/// Returns a null map function on error (see IsNull()).
/// 
/// \param sourceToTargetMap The map from source paths to target paths.
/// \param offset The time offset to apply from source to target.
int pcp_MapFunction_Create(pcp_MapFunctionPathMap_t const* sourceToTargetMap, sdf_LayerOffset_t const* offset, pcp_MapFunction_t* _result);

/// Construct an identity map function.
int pcp_MapFunction_Identity(pcp_MapFunction_t const** _result);

/// Returns an identity path mapping.
int pcp_MapFunction_IdentityPathMap(pcp_MapFunctionPathMap_t const** _result);

int pcp_MapFunction_default(pcp_MapFunction_t** _result);

int pcp_MapFunction_dtor(pcp_MapFunction_t* _this);

int pcp_NodeRef_dtor(pcp_NodeRef_t* _this);

int pcp_MapFunctionPathMap_dtor(pcp_MapFunctionPathMap_t* _this);

int pcp_PrimIndex_dtor(pcp_PrimIndex_t* _this);

int pcp_VariantFallbackMap_dtor(pcp_VariantFallbackMap_t* _this);

/// Returns \c true if allowed, otherwise fills \p whyNot if not \c NULL
/// and returns \c false.
int sdf_Allowed_IsAllowed(sdf_Allowed_t const* _this, std_String_t* whyNot, bool* _result);

int sdf_Allowed_from_bool_and_string(sdf_Allowed_t** _result);

int sdf_Allowed_from_string(sdf_Allowed_t** _result);

int sdf_Allowed_from_bool(sdf_Allowed_t** _result);

int sdf_Allowed_new(sdf_Allowed_t** _result);

int sdf_Allowed_dtor(sdf_Allowed_t* _this);

int sdf_AssetPath_new(sdf_AssetPath_t** _result);

int sdf_AssetPath_dtor(sdf_AssetPath_t* _this);

int sdf_AssetPathArray_dtor(sdf_AssetPathArray_t* _this);

/// Constructs a new prim attribute instance.
/// 
/// Creates and returns a new attribute for the given prim.
/// The \p owner will own the newly created attribute.
int sdf_AttributeSpec_New(sdf_PrimSpecHandle_t const* owner, std_String_t const* name, sdf_ValueTypeName_t const* typeName, int variability, bool custom, sdf_AttributeSpecHandle_t* _result);

/// Returns \c true if any connection paths are set on this attribute.
int sdf_AttributeSpec_HasConnectionPaths(sdf_AttributeSpec_t const* _this, bool* _result);

/// Clears the connection paths for this attribute.
int sdf_AttributeSpec_ClearConnectionPaths(sdf_AttributeSpec_t* _this);

/// Returns the allowed tokens metadata for this attribute.
/// Consumers may use this metadata to define a set of predefined
/// options for this attribute's value. However, this metadata is
/// purely advisory. It is up to the consumer to perform any
/// validation against this set of tokens, if desired.
int sdf_AttributeSpec_GetAllowedTokens(sdf_AttributeSpec_t const* _this, vt_TokenArray_t* _result);

/// Returns true if allowed tokens metadata is set for this attribute.
int sdf_AttributeSpec_HasAllowedTokens(sdf_AttributeSpec_t const* _this, bool* _result);

/// Sets the allowed tokens metadata for this attribute.
int sdf_AttributeSpec_SetAllowedTokens(sdf_AttributeSpec_t* _this, vt_TokenArray_t const* allowedTokens);

/// Returns a proxy for editing the attribute's connection paths.
/// 
/// The returned proxy, which is an SdfListEditorProxy, modifies the
/// SdfListOp that represents this attribute's connections.
int sdf_AttributeSpec_GetConnectionPathList(sdf_AttributeSpec_t const* _this, sdf_InheritsProxy_t* _result);

/// Clears the allowed tokens metadata for this attribute.
int sdf_AttributeSpec_ClearAllowedTokens(sdf_AttributeSpec_t* _this);

/// Returns the display unit of the attribute.
int sdf_AttributeSpec_GetDisplayUnit(sdf_AttributeSpec_t const* _this, tf_Enum_t* _result);

/// Sets the display unit of the attribute.
int sdf_AttributeSpec_SetDisplayUnit(sdf_AttributeSpec_t* _this, tf_Enum_t const* displayUnit);

/// Returns true if a display unit is set for this attribute.
int sdf_AttributeSpec_HasDisplayUnit(sdf_AttributeSpec_t const* _this, bool* _result);

/// Clears the display unit of the attribute.
int sdf_AttributeSpec_ClearDisplayUnit(sdf_AttributeSpec_t* _this);

/// Returns the color-space in which a color or texture valued attribute 
/// is authored.
int sdf_AttributeSpec_GetColorSpace(sdf_AttributeSpec_t const* _this, tf_Token_t* _result);

/// Sets the color-space in which a color or texture valued attribute is 
/// authored.
int sdf_AttributeSpec_SetColorSpace(sdf_AttributeSpec_t* _this, tf_Token_t const* colorSpace);

/// Returns true if this attribute has a colorSpace value authored.
int sdf_AttributeSpec_HasColorSpace(sdf_AttributeSpec_t const* _this, bool* _result);

/// Clears the colorSpace metadata value set on this attribute.
int sdf_AttributeSpec_ClearColorSpace(sdf_AttributeSpec_t* _this);

/// Returns the roleName for this attribute's typeName.
/// 
/// If the typeName has no roleName, return empty token.
int sdf_AttributeSpec_GetRoleName(sdf_AttributeSpec_t const* _this, tf_Token_t* _result);

/// Returns the owner prim or relationship of this property.
int sdf_AttributeSpec_GetOwner(sdf_AttributeSpec_t const* _this, sdf_SpecHandle_t* _result);

/// Returns the property's custom data.
/// 
/// The default value for custom data is an empty dictionary.
/// 
/// Custom data is for use by plugins or other non-tools supplied
/// extensions that need to be able to store data attached to arbitrary
/// scene objects.  Note that if the only objects you want to store data
/// on are prims, using custom attributes is probably a better choice.
/// But if you need to possibly store this data on attributes or
/// relationships or as annotations on reference arcs, then custom data
/// is an appropriate choice.
int sdf_AttributeSpec_GetCustomData(sdf_AttributeSpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Returns the asset info dictionary for this property.
/// 
/// The default value is an empty dictionary. 
/// 
/// The asset info dictionary is used to annotate SdfAssetPath-valued 
/// attributes pointing to the root-prims of assets (generally organized 
/// as models) with various data related to asset management. For example, 
/// asset name, root layer identifier, asset version etc.
/// 
/// \note It is only valid to author assetInfo on attributes that are of 
/// type SdfAssetPath.
int sdf_AttributeSpec_GetAssetInfo(sdf_AttributeSpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Sets a property custom data entry.
/// 
/// If \p value is empty, then this removes the given custom data entry.
int sdf_AttributeSpec_SetCustomData(sdf_AttributeSpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Sets a asset info entry for this property.
/// 
/// If \p value is empty, then this removes the given asset info entry.
/// 
/// \sa GetAssetInfo()
int sdf_AttributeSpec_SetAssetInfo(sdf_AttributeSpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Returns the displayGroup string for this property spec.
/// 
/// The default value for displayGroup is empty string.
int sdf_AttributeSpec_GetDisplayGroup(sdf_AttributeSpec_t const* _this, std_String_t* _result);

/// Sets the displayGroup string for this property spec.
int sdf_AttributeSpec_SetDisplayGroup(sdf_AttributeSpec_t* _this, std_String_t const* value);

/// Returns the displayName string for this property spec.
/// 
/// The default value for displayName is empty string.
int sdf_AttributeSpec_GetDisplayName(sdf_AttributeSpec_t const* _this, std_String_t* _result);

/// Sets the displayName string for this property spec.
int sdf_AttributeSpec_SetDisplayName(sdf_AttributeSpec_t* _this, std_String_t const* value);

/// Returns the documentation string for this property spec.
/// 
/// The default value for documentation is empty string.
int sdf_AttributeSpec_GetDocumentation(sdf_AttributeSpec_t const* _this, std_String_t* _result);

/// Sets the documentation string for this property spec.
int sdf_AttributeSpec_SetDocumentation(sdf_AttributeSpec_t* _this, std_String_t const* value);

/// Returns whether this property spec will be hidden in browsers.
/// 
/// The default value for hidden is false.
int sdf_AttributeSpec_GetHidden(sdf_AttributeSpec_t const* _this, bool* _result);

/// Sets whether this property spec will be hidden in browsers.
int sdf_AttributeSpec_SetHidden(sdf_AttributeSpec_t* _this, bool value);

/// Returns the property's permission restriction.
/// 
/// The default value for permission is SdfPermissionPublic.
int sdf_AttributeSpec_GetPermission(sdf_AttributeSpec_t const* _this, int* _result);

/// Sets the property's permission restriction.
int sdf_AttributeSpec_SetPermission(sdf_AttributeSpec_t* _this, int value);

/// Returns the prefix string for this property spec.
/// 
/// The default value for prefix is "".
int sdf_AttributeSpec_GetPrefix(sdf_AttributeSpec_t const* _this, std_String_t* _result);

/// Sets the prefix string for this property spec.
int sdf_AttributeSpec_SetPrefix(sdf_AttributeSpec_t* _this, std_String_t const* value);

/// Returns the suffix string for this property spec.
/// 
/// The default value for suffix is "".
int sdf_AttributeSpec_GetSuffix(sdf_AttributeSpec_t const* _this, std_String_t* _result);

/// Sets the suffix string for this property spec.
int sdf_AttributeSpec_SetSuffix(sdf_AttributeSpec_t* _this, std_String_t const* value);

/// Returns the property's symmetric peer.
/// 
/// The default value for the symmetric peer is an empty string.
int sdf_AttributeSpec_GetSymmetricPeer(sdf_AttributeSpec_t const* _this, std_String_t* _result);

/// Sets the property's symmetric peer.
/// 
/// If \p peerName is empty, then this removes any symmetric peer for the
/// given property.
int sdf_AttributeSpec_SetSymmetricPeer(sdf_AttributeSpec_t* _this, std_String_t const* peerName);

/// Returns the property's symmetry arguments.
/// 
/// The default value for symmetry arguments is an empty dictionary.
int sdf_AttributeSpec_GetSymmetryArguments(sdf_AttributeSpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Sets a property symmetry argument.
/// 
/// If \p value is empty, then this removes the argument with the given
/// \p name.
int sdf_AttributeSpec_SetSymmetryArgument(sdf_AttributeSpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Returns the property's symmetry function.
/// 
/// The default value for the symmetry function is an empty token.
int sdf_AttributeSpec_GetSymmetryFunction(sdf_AttributeSpec_t const* _this, tf_Token_t* _result);

/// Sets the property's symmetry function.
/// 
/// If \p functionName is empty, then this removes any symmetry function
/// for the given property.
int sdf_AttributeSpec_SetSymmetryFunction(sdf_AttributeSpec_t* _this, tf_Token_t const* functionName);

/// Returns the entire set of time samples.
int sdf_AttributeSpec_GetTimeSampleMap(sdf_AttributeSpec_t const* _this, sdf_TimeSampleMap_t* _result);

/// Returns the TfType representing the value type this property holds.
int sdf_AttributeSpec_GetValueType(sdf_AttributeSpec_t const* _this, tf_Type_t* _result);

/// Returns the name of the value type that this property holds.
/// 
/// Returns the typename used to represent the types of value held by
/// this attribute.
int sdf_AttributeSpec_GetTypeName(sdf_AttributeSpec_t const* _this, sdf_ValueTypeName_t* _result);

/// Returns the attribute's default value.
/// 
/// If it doesn't have a default value, an empty VtValue is returned.
int sdf_AttributeSpec_GetDefaultValue(sdf_AttributeSpec_t const* _this, vt_Value_t* _result);

/// Sets the attribute's default value.
/// 
/// Returns true if successful, false otherwise.  Fails if \p defaultValue
/// has wrong type.
int sdf_AttributeSpec_SetDefaultValue(sdf_AttributeSpec_t* _this, vt_Value_t const* defaultValue, bool* _result);

/// Returns true if a default value is set for this attribute.
int sdf_AttributeSpec_HasDefaultValue(sdf_AttributeSpec_t const* _this, bool* _result);

/// Clear the attribute's default value.
int sdf_AttributeSpec_ClearDefaultValue(sdf_AttributeSpec_t* _this);

/// Returns the comment string for this property spec.
/// 
/// The default value for comment is "".
int sdf_AttributeSpec_GetComment(sdf_AttributeSpec_t const* _this, std_String_t* _result);

/// Sets the comment string for this property spec.
int sdf_AttributeSpec_SetComment(sdf_AttributeSpec_t* _this, std_String_t const* value);

/// Returns true if this spec declares a custom property
int sdf_AttributeSpec_IsCustom(sdf_AttributeSpec_t const* _this, bool* _result);

/// Sets whether this spec declares a custom property
int sdf_AttributeSpec_SetCustom(sdf_AttributeSpec_t* _this, bool custom);

/// Returns the variability of the property.
/// 
/// An attribute's variability may be \c Varying (the default),
/// \c Uniform, \c Config, or \c Computed.
/// 
/// A relationship's variability may be \c Varying or \c Uniform (the
/// default)
/// 
/// <ul>
///     <li>\c Varying attributes may be directly authored, animated and
///         affected by \p Actions.  They are the most flexible.
///         Varying relationships can have a default and an anim spline,
///         in addition to a list of targets.
/// 
///     <li>\c Uniform attributes may be authored only with non-animated
///         values (default values).  They cannot be affected by \p Actions,
///         but they can be connected to other Uniform attributes.
///         Uniform relationships have a list of targets but do not have
///         default or anim spline values.
/// 
///     <li>\c Config attributes are the same as Uniform except that a Prim
///         can choose to alter its collection of built-in properties based
///         on the values of its Config attributes.
/// 
///     <li>\c Computed attributes may not be authored in scene description.
///         Prims determine the values of their Computed attributes through
///         Prim-specific computation.  They may not be connected.
/// </ul>
int sdf_AttributeSpec_GetVariability(sdf_AttributeSpec_t const* _this, int* _result);

/// Returns true if this PropertySpec has no significant data other than
/// just what is necessary for instantiation.
/// 
/// For example, "double foo" has only required fields, but "double foo = 3"
/// has more than just what is required.
/// 
/// This is similar to IsInert except that IsInert will always return false 
/// even for properties that have only required fields; PropertySpecs are 
/// never considered inert because even a spec with only required fields 
/// will cause instantiation of on-demand properties.
int sdf_AttributeSpec_HasOnlyRequiredFields(sdf_AttributeSpec_t const* _this, bool* _result);

/// Returns the property's name.
int sdf_AttributeSpec_GetName(sdf_AttributeSpec_t const* _this, std_String_t const** _result);

/// Returns the property's name, as a token.
int sdf_AttributeSpec_GetNameToken(sdf_AttributeSpec_t const* _this, tf_Token_t* _result);

/// Returns true if setting the property spec's name to \p newName
/// will succeed.
/// 
/// Returns false if it won't, and sets \p whyNot with a string
/// describing why not.
int sdf_AttributeSpec_CanSetName(sdf_AttributeSpec_t const* _this, std_String_t const* newName, std_String_t* whyNot, bool* _result);

/// Sets the property's name.
/// 
/// A Prim's properties must be unique by name. Setting the
/// name to the same name as an existing property is an error.
/// 
/// Setting \p validate to false, will skip validation of the newName
/// (that is, CanSetName will not be called).
int sdf_AttributeSpec_SetName(sdf_AttributeSpec_t* _this, std_String_t const* newName, bool validate, bool* _result);

/// Returns true if the given name is considered a valid name for a
/// property.  A valid name is not empty, and does not use invalid
/// characters (such as '/', '[', or '.').
int sdf_AttributeSpec_IsValidName(std_String_t const* name, bool* _result);

/// Returns the SdfSchemaBase for the layer that owns this spec.
int sdf_AttributeSpec_GetSchema(sdf_AttributeSpec_t const* _this, sdf_SchemaBase_t const** _result);

/// Returns the SdfSpecType specifying the spec type this object
/// represents.
int sdf_AttributeSpec_GetSpecType(sdf_AttributeSpec_t const* _this, int* _result);

/// Returns true if this object is invalid or expired.
int sdf_AttributeSpec_IsDormant(sdf_AttributeSpec_t const* _this, bool* _result);

/// Returns the layer that this object belongs to.
int sdf_AttributeSpec_GetLayer(sdf_AttributeSpec_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the scene path of this object.
int sdf_AttributeSpec_GetPath(sdf_AttributeSpec_t const* _this, sdf_Path_t* _result);

/// Returns whether this object's layer can be edited.
int sdf_AttributeSpec_PermissionToEdit(sdf_AttributeSpec_t const* _this, bool* _result);

/// Returns the full list of info keys currently set on this object.
/// \note This does not include fields that represent names of children.
int sdf_AttributeSpec_ListInfoKeys(sdf_AttributeSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns the list of metadata info keys for this object.
/// 
/// This is not the complete list of keys, it is only those that
/// should be considered to be metadata by inspectors or other 
/// presentation UI.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_AttributeSpec_GetMetaDataInfoKeys(sdf_AttributeSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns this metadata key's displayGroup.
int sdf_AttributeSpec_GetMetaDataDisplayGroup(sdf_AttributeSpec_t const* _this, tf_Token_t const* key, tf_Token_t* _result);

/// Gets the value for the given metadata key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_AttributeSpec_GetInfo(sdf_AttributeSpec_t const* _this, tf_Token_t const* key, vt_Value_t* _result);

/// Sets the value for the given metadata key.
/// 
/// It is an error to pass a value that is not the correct type for
/// that given key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_AttributeSpec_SetInfo(sdf_AttributeSpec_t* _this, tf_Token_t const* key, vt_Value_t const* value);

/// Sets the value for \p entryKey to \p value within the dictionary 
///        with the given metadata key \p dictionaryKey
int sdf_AttributeSpec_SetInfoDictionaryValue(sdf_AttributeSpec_t* _this, tf_Token_t const* dictionaryKey, tf_Token_t const* entryKey, vt_Value_t const* value);

/// Returns whether there is a setting for the scene spec info 
/// with the given key.
/// 
/// When asked for a value for one of its scene spec info, a valid value
/// will always be returned. But if this API returns \b false for a scene
/// spec info, the value of that info will be the defined default value.
/// 
/// When dealing with a composedLayer, it is not necessary to worry about
/// whether a scene spec info "has a value" because the composed layer will
/// always have a valid value, even if it is the default.
/// 
/// A spec may or may not have an expressed value for some of its
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_AttributeSpec_HasInfo(sdf_AttributeSpec_t const* _this, tf_Token_t const* key, bool* _result);

/// Clears the value for scene spec info with the given \a key.
/// 
/// After calling this, HasInfo() will return \b false.
/// To make HasInfo() return \b true just set a value for that
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_AttributeSpec_ClearInfo(sdf_AttributeSpec_t* _this, tf_Token_t const* key);

/// Returns the data type for the info with the given \a key.
int sdf_AttributeSpec_GetTypeForInfo(sdf_AttributeSpec_t const* _this, tf_Token_t const* key, tf_Type_t* _result);

/// Returns the fallback for the info with the given \a key.
int sdf_AttributeSpec_GetFallbackForInfo(sdf_AttributeSpec_t const* _this, tf_Token_t const* key, vt_Value_t const** _result);

/// Returns whether this object has no significant data.
/// 
/// "Significant" here means that the object contributes opinions to
/// a scene. If this spec has any child scenegraph objects (e.g.,
/// prim or property spec), it will be considered significant even if
/// those child objects are not.
/// However, if \p ignoreChildren is \c true, these child objects
/// will be ignored. 
int sdf_AttributeSpec_IsInert(sdf_AttributeSpec_t const* _this, bool ignoreChildren, bool* _result);

/// Returns all fields with values.
int sdf_AttributeSpec_ListFields(sdf_AttributeSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns \c true if the spec has a non-empty value with field
/// name \p name.
int sdf_AttributeSpec_HasField(sdf_AttributeSpec_t const* _this, tf_Token_t const* name, bool* _result);

/// Returns a field value by name.
int sdf_AttributeSpec_GetField(sdf_AttributeSpec_t const* _this, tf_Token_t const* name, vt_Value_t* _result);

/// Sets a field value as a boxed VtValue.
int sdf_AttributeSpec_SetField(sdf_AttributeSpec_t* _this, tf_Token_t const* name, vt_Value_t const* value, bool* _result);

/// \name Comparison operators
/// @{
int sdf_AttributeSpec_op_eq(sdf_AttributeSpec_t const* _this, sdf_Spec_t const* rhs, bool* _result);

int sdf_AttributeSpec_dtor(sdf_AttributeSpec_t* _this);

int sdf_AttributeSpecHandle_dtor(sdf_AttributeSpecHandle_t* _this);

int sdf_AttributeSpecHandleVector_data(sdf_AttributeSpecHandleVector_t* _this, sdf_AttributeSpecHandle_t** _result);

int sdf_AttributeSpecHandleVector_data_const(sdf_AttributeSpecHandleVector_t const* _this, sdf_AttributeSpecHandle_t const** _result);

int sdf_AttributeSpecHandleVector_empty(sdf_AttributeSpecHandleVector_t const* _this, bool* _result);

int sdf_AttributeSpecHandleVector_size(sdf_AttributeSpecHandleVector_t const* _this, size_t* _result);

int sdf_AttributeSpecHandleVector_max_size(sdf_AttributeSpecHandleVector_t const* _this, size_t* _result);

int sdf_AttributeSpecHandleVector_reserve(sdf_AttributeSpecHandleVector_t* _this, size_t const _Newcapacity);

int sdf_AttributeSpecHandleVector_capacity(sdf_AttributeSpecHandleVector_t const* _this, size_t* _result);

int sdf_AttributeSpecHandleVector_clear(sdf_AttributeSpecHandleVector_t* _this);

int sdf_AttributeSpecHandleVector_push_back(sdf_AttributeSpecHandleVector_t* _this, sdf_AttributeSpecHandle_t const* _Val);

int sdf_AttributeSpecHandleVector_pop_back(sdf_AttributeSpecHandleVector_t* _this);

int sdf_AttributeSpecHandleVector_resize(sdf_AttributeSpecHandleVector_t* _this, size_t const _Newsize);

int sdf_AttributeSpecHandleVector_resize_with(sdf_AttributeSpecHandleVector_t* _this, size_t const _Newsize, sdf_AttributeSpecHandle_t const* _Val);

int sdf_AttributeSpecHandleVector_op_index(sdf_AttributeSpecHandleVector_t const* _this, size_t const _Pos, sdf_AttributeSpecHandle_t const** _result);

int sdf_AttributeSpecHandleVector_default(sdf_AttributeSpecHandleVector_t** _result);

int sdf_AttributeSpecHandleVector_dtor(sdf_AttributeSpecHandleVector_t* _this);

int sdf_AttributeSpecView_dtor(sdf_AttributeSpecView_t* _this);

/// Add a namespace edit.
int sdf_BatchNamespaceEdit_Add(sdf_BatchNamespaceEdit_t* _this, sdf_NamespaceEdit_t const* edit);

/// Add a namespace edit.
int sdf_BatchNamespaceEdit_Add_from_paths(sdf_BatchNamespaceEdit_t* _this, sdf_Path_t const* currentPath, sdf_Path_t const* newPath, int index);

/// Returns the edits.
int sdf_BatchNamespaceEdit_GetEdits(sdf_BatchNamespaceEdit_t const* _this, sdf_NamespaceEditVector_t const** _result);

int sdf_BatchNamespaceEdit_new(sdf_BatchNamespaceEdit_t** _result);

int sdf_BatchNamespaceEdit_dtor(sdf_BatchNamespaceEdit_t* _this);

int sdf_ChangeBlock_new(sdf_ChangeBlock_t** _result);

int sdf_ChangeBlock_dtor(sdf_ChangeBlock_t* _this);

int sdf_ChangeList_GetEntryList(sdf_ChangeList_t const* _this, sdf_ChangeListEntryList_t const** _result);

int sdf_ChangeList_GetEntry(sdf_ChangeList_t const* _this, sdf_Path_t const* param00, sdf_ChangeListEntry_t const** _result);

int sdf_ChangeList_FindEntry(sdf_ChangeList_t const* _this, sdf_Path_t const* param00, sdf_PathChangeListEntryPair_t const** _result);

int sdf_ChangeList_new(sdf_ChangeList_t** _result);

int sdf_ChangeList_dtor(sdf_ChangeList_t* _this);

int sdf_ChangeListEntry_new(sdf_ChangeListEntry_t** _result);

int sdf_ChangeListEntry_dtor(sdf_ChangeListEntry_t* _this);

int sdf_PathChangeListEntryPair_dtor(sdf_PathChangeListEntryPair_t* _this);

int sdf_ChangeListEntryList_dtor(sdf_ChangeListEntryList_t* _this);

int sdf_DictionaryProxy_dtor(sdf_DictionaryProxy_t* _this);

/// Returns the schema for this format.
int sdf_FileFormat_GetSchema(sdf_FileFormat_t const* _this, sdf_SchemaBase_t const** _result);

/// Returns the format identifier.
int sdf_FileFormat_GetFormatId(sdf_FileFormat_t const* _this, tf_Token_t const** _result);

/// Returns the target for this file format.
int sdf_FileFormat_GetTarget(sdf_FileFormat_t const* _this, tf_Token_t const** _result);

/// Returns the cookie to be used when writing files with this format.
int sdf_FileFormat_GetFileCookie(sdf_FileFormat_t const* _this, std_String_t const** _result);

/// Returns the current version of this file format.
int sdf_FileFormat_GetVersionString(sdf_FileFormat_t const* _this, tf_Token_t const** _result);

/// Returns true if this file format is the primary format for the 
/// extensions it handles.
int sdf_FileFormat_IsPrimaryFormatForExtensions(sdf_FileFormat_t const* _this, bool* _result);

/// Returns a list of extensions that this format supports.
int sdf_FileFormat_GetFileExtensions(sdf_FileFormat_t const* _this, std_StringVector_t const** _result);

/// Returns the primary file extension for this format. This is the
/// extension that is reported for layers using this file format.
int sdf_FileFormat_GetPrimaryFileExtension(sdf_FileFormat_t const* _this, std_String_t const** _result);

/// Returns true if \p extension matches one of the extensions returned by
/// GetFileExtensions.
int sdf_FileFormat_IsSupportedExtension(sdf_FileFormat_t const* _this, std_String_t const* extension, bool* _result);

/// Returns true if this file format is a package containing other
/// assets.
int sdf_FileFormat_IsPackage(sdf_FileFormat_t const* _this, bool* _result);

/// Returns the path of the "root" layer contained in the package
/// layer at \p resolvedPath produced by this file format. If this 
/// file format is not a package, returns the empty string.
/// 
/// The package root layer is the layer in the package layer that 
/// is used when that package is opened via SdfLayer.
int sdf_FileFormat_GetPackageRootLayerPath(sdf_FileFormat_t const* _this, std_String_t const* resolvedPath, std_String_t* _result);

/// Return true if this file format prefers to skip reloading anonymous
/// layers.
int sdf_FileFormat_ShouldSkipAnonymousReload(sdf_FileFormat_t const* _this, bool* _result);

/// Returns true if anonymous layer identifiers should be passed to Read 
/// when a layer is opened or reloaded.
/// 
/// Anonymous layers will not have an asset backing and thus for most
/// file formats there is nothing that can be read for an anonymous layer. 
/// However, there are file formats that use Read to generate dynamic layer 
/// content without reading any data from the resolved asset associated with
/// the layer's identifier. 
/// 
/// For these types of file formats it is useful to be able to open 
/// anonymous layers and allow Read to populate them to avoid requiring a
/// placeholder asset to exist just so Read can populate the layer.
int sdf_FileFormat_ShouldReadAnonymousLayers(sdf_FileFormat_t const* _this, bool* _result);

/// Reads scene description from the asset specified by \p resolvedPath
/// into the detached layer \p layer. After reading is completed,
/// \p layer must be detached from any underlying storage.
/// 
/// \p metadataOnly is a flag that asks for only the layer metadata
/// to be read in, which can be much faster if that is all that is
/// required.  Note that this is just a hint: some FileFormat readers
/// may disregard this flag and still fully populate the layer contents.
/// 
/// Returns true if the asset is successfully read into \p layer,
/// false if the the asset could not be read or if the resulting
/// layer is not detached.
int sdf_FileFormat_ReadDetached(sdf_FileFormat_t const* _this, sdf_Layer_t* layer, std_String_t const* resolvedPath, bool metadataOnly, bool* _result);

/// Returns the set of resolved paths to external asset file dependencies 
/// for the given \p layer. These are additional dependencies, specific to 
/// the file format, that are needed when generating the layer's contents
/// and would not otherwise be discoverable through composition dependencies
/// (i.e. sublayers, references, and payloads). 
/// 
/// The default implementation returns an empty set. Derived file formats 
/// that depend on external assets to read and generate layer content 
/// should implement this function to return the external asset paths.
/// 
/// \sa SdfLayer::GetExternalAssetDependencies
/// \sa SdfLayer::Reload
int sdf_FileFormat_GetExternalAssetDependencies(sdf_FileFormat_t const* _this, sdf_Layer_t const* layer, std_StringSet_t* _result);

/// Returns true if this file format supports reading.
/// This is a convenience method for invoking \ref FormatSupportsReading
/// with this format's extension and target
int sdf_FileFormat_SupportsReading(sdf_FileFormat_t const* _this, bool* _result);

/// This is a convenience method for invoking \ref FormatSupportsWriting
/// with this format's extension and target
int sdf_FileFormat_SupportsWriting(sdf_FileFormat_t const* _this, bool* _result);

/// This is a convenience method for invoking \ref FormatSupportsEditing
/// with this format's extension and target
int sdf_FileFormat_SupportsEditing(sdf_FileFormat_t const* _this, bool* _result);

/// Returns the file extension for path or file name \p s, without the
/// leading dot character.
int sdf_FileFormat_GetFileExtension(std_String_t const* s, std_String_t* _result);

/// Returns a set containing the extension(s) corresponding to 
/// all registered file formats.
int sdf_FileFormat_FindAllFileFormatExtensions(std_StringSet_t* _result);

/// Returns a set containing the extension(s) corresponding to
/// all registered file formats that derive from \p baseType.
/// 
/// \p baseType must derive from SdfFileFormat.
int sdf_FileFormat_FindAllDerivedFileFormatExtensions(tf_Type_t const* baseType, std_StringSet_t* _result);

/// Returns true if the file format for the supplied \p extension and
/// \p target pair supports reading.
/// This method will not load the plugin that provides the specified 
/// file format.
/// If the extension and target pair is invalid, this method will
/// return false.
/// \sa FormatSupportsWriting \sa FormatSupportsEditing
int sdf_FileFormat_FormatSupportsReading(std_String_t const* extension, std_String_t const* target, bool* _result);

/// Returns true if the file format for the supplied \p extension and 
/// \p target pair supports writing.
/// This method will not load the plugin that provides the specified 
/// file format.
/// If the extension and target pair is invalid, this method will return
/// false.
/// \sa FormatSupportsReading \sa FormatSupportsEditing
int sdf_FileFormat_FormatSupportsWriting(std_String_t const* extension, std_String_t const* target, bool* _result);

/// Returns true if the file format for the supplied \p extension and 
/// \p target pair supports editing.
/// This method will not load the plugin that provides the specified 
/// file format.
/// If the extension and target pair is invalid, this method will return
/// false.
/// \sa FormatSupportsReading \sa FormatSupportsWriting
int sdf_FileFormat_FormatSupportsEditing(std_String_t const* extension, std_String_t const* target, bool* _result);

/// Returns true if \p file can be read by this format.
int sdf_FileFormat_CanRead(sdf_FileFormat_t const* _this, std_String_t const* file, bool* _result);

/// Reads scene description from the asset specified by \p resolvedPath
/// into the layer \p layer.
/// 
/// \p metadataOnly is a flag that asks for only the layer metadata
/// to be read in, which can be much faster if that is all that is
/// required.  Note that this is just a hint: some FileFormat readers
/// may disregard this flag and still fully populate the layer contents.
/// 
/// Returns true if the asset is successfully read into \p layer,
/// false otherwise.
int sdf_FileFormat_Read(sdf_FileFormat_t const* _this, sdf_Layer_t* layer, std_String_t const* resolvedPath, bool metadataOnly, bool* _result);

/// Writes the content in \p layer into the file at \p filePath. If the
/// content is successfully written, this method returns true. Otherwise,
/// false is returned and errors are posted. The default implementation
/// returns false.
int sdf_FileFormat_WriteToFile(sdf_FileFormat_t const* _this, sdf_Layer_t const* layer, std_String_t const* filePath, std_String_t const* comment, sdf_LayerFileFormatArguments_t const* args, bool* _result);

/// Reads data in the string \p str into the layer \p layer. If
/// the file is successfully read, this method returns true. Otherwise,
/// false is returned and errors are posted.
int sdf_FileFormat_ReadFromString(sdf_FileFormat_t const* _this, sdf_Layer_t* layer, std_String_t const* str, bool* _result);

/// Writes the content in \p layer to the string \p str. This function
/// should write a textual representation of \p layer to the stream
/// that can be read back in via ReadFromString.
int sdf_FileFormat_WriteToString(sdf_FileFormat_t const* _this, sdf_Layer_t const* layer, std_String_t* str, std_String_t const* comment, bool* _result);

int sdf_InheritsProxy_dtor(sdf_InheritsProxy_t* _this);

int sdf_LayerFileFormatArguments_dtor(sdf_LayerFileFormatArguments_t* _this);

/// \deprecated 
/// Use GetCompositionAssetDependencies instead.
int sdf_Layer_GetExternalReferences(sdf_Layer_t const* _this, std_StringSet_t* _result);

/// \deprecated 
/// Use UpdateCompositionAssetDependency instead.
int sdf_Layer_UpdateExternalReference(sdf_Layer_t* _this, std_String_t const* oldAssetPath, std_String_t const* newAssetPath, bool* _result);

/// Return paths of all assets this layer depends on due to composition 
/// fields.
/// 
/// This includes the paths of all layers referred to by reference, 
/// payload, and sublayer fields in this layer. This function only returns 
/// direct composition dependencies of this layer, i.e. it does not recurse 
/// to find composition dependencies from its dependent layer assets.
int sdf_Layer_GetCompositionAssetDependencies(sdf_Layer_t const* _this, std_StringSet_t* _result);

/// Updates the asset path of a composation dependency in this layer.
/// 
/// If \p newAssetPath is supplied, the update works as "rename", updating
/// any occurrence of \p oldAssetPath to \p newAssetPath in all reference,
/// payload, and sublayer fields.
/// 
/// If \p newAssetPath is not given, this update behaves as a "delete", 
/// removing all occurrences of \p oldAssetPath from all reference, payload,
/// and sublayer fields.
int sdf_Layer_UpdateCompositionAssetDependency(sdf_Layer_t* _this, std_String_t const* oldAssetPath, std_String_t const* newAssetPath, bool* _result);

/// Returns a set of resolved paths to all external asset dependencies
/// the layer needs to generate its contents. These are additional asset 
/// dependencies that are determined by the layer's 
/// \ref SdfFileFormat::GetExternalAssetDependencies "file format" and
/// will be consulted during Reload() when determining if the layer needs 
/// to be reloaded. This specifically does not include dependencies related 
/// to composition, i.e. this will not include assets from references, 
/// payloads, and sublayers.
int sdf_Layer_GetExternalAssetDependencies(sdf_Layer_t const* _this, std_StringSet_t* _result);

/// Return the spec type for \a path. This returns SdfSpecTypeUnknown if no
/// spec exists at \a path.
int sdf_Layer_GetSpecType(sdf_Layer_t const* _this, sdf_Path_t const* path, int* _result);

/// Return whether a spec exists at \a path.
int sdf_Layer_HasSpec(sdf_Layer_t const* _this, sdf_Path_t const* path, bool* _result);

/// Return the names of all the fields that are set at \p path.
int sdf_Layer_ListFields(sdf_Layer_t const* _this, sdf_Path_t const* path, tf_TokenVector_t* _result);

/// Return whether a value exists for the given \a path and \a fieldName.
/// Optionally returns the value if it exists.
int sdf_Layer_HasField(sdf_Layer_t const* _this, sdf_Path_t const* path, tf_Token_t const* fieldName, vt_Value_t* value, bool* _result);

/// Return whether a value exists for the given \a path and \a fieldName and
/// \a keyPath.  The \p keyPath is a ':'-separated path addressing an
/// element in sub-dictionaries.  Optionally returns the value if it exists.
int sdf_Layer_HasFieldDictKey(sdf_Layer_t const* _this, sdf_Path_t const* path, tf_Token_t const* fieldName, tf_Token_t const* keyPath, vt_Value_t* value, bool* _result);

/// Return the value for the given \a path and \a fieldName. Returns an
/// empty value if none is set.
int sdf_Layer_GetField(sdf_Layer_t const* _this, sdf_Path_t const* path, tf_Token_t const* fieldName, vt_Value_t* _result);

/// Return the value for the given \a path and \a fieldName at \p
/// keyPath. Returns an empty value if none is set.  The \p keyPath is a
/// ':'-separated path addressing an element in sub-dictionaries.
int sdf_Layer_GetFieldDictValueByKey(sdf_Layer_t const* _this, sdf_Path_t const* path, tf_Token_t const* fieldName, tf_Token_t const* keyPath, vt_Value_t* _result);

/// Set the value of the given \a path and \a fieldName.
int sdf_Layer_SetField(sdf_Layer_t* _this, sdf_Path_t const* path, tf_Token_t const* fieldName, vt_Value_t const* value);

/// Set the value of the given \a path and \a fieldName.  The \p keyPath is a
/// ':'-separated path addressing an element in sub-dictionaries.
int sdf_Layer_SetFieldDictValueByKey(sdf_Layer_t* _this, sdf_Path_t const* path, tf_Token_t const* fieldName, tf_Token_t const* keyPath, vt_Value_t const* value);

/// Remove the field at \p path and \p fieldName, if one exists.
int sdf_Layer_EraseField(sdf_Layer_t* _this, sdf_Path_t const* path, tf_Token_t const* fieldName);

/// Remove the field at \p path and \p fieldName and \p keyPath, if one
/// exists.  The \p keyPath is a ':'-separated path addressing an
/// element in sub-dictionaries.
int sdf_Layer_EraseFieldDictValueByKey(sdf_Layer_t* _this, sdf_Path_t const* path, tf_Token_t const* fieldName, tf_Token_t const* keyPath);

/// Returns the color configuration asset-path for this layer.
/// 
/// The default value is an empty asset-path.
int sdf_Layer_GetColorConfiguration(sdf_Layer_t const* _this, sdf_AssetPath_t* _result);

/// Sets the color configuration asset-path for this layer.
int sdf_Layer_SetColorConfiguration(sdf_Layer_t* _this, sdf_AssetPath_t const* colorConfiguration);

/// Returns true if color configuration metadata is set in this layer.
/// \sa GetColorConfiguration(), SetColorConfiguration()
int sdf_Layer_HasColorConfiguration(sdf_Layer_t const* _this, bool* _result);

/// Clears the color configuration metadata authored in this layer. 
/// \sa HasColorConfiguration(), SetColorConfiguration()
int sdf_Layer_ClearColorConfiguration(sdf_Layer_t* _this);

/// Returns the color management system used to interpret the color 
/// configuration asset-path authored in this layer.
/// 
/// The default value is an empty token, which implies that the clients 
/// will have to determine the color management system from the color 
/// configuration asset path (i.e. from its file extension), if it's 
/// specified. 
int sdf_Layer_GetColorManagementSystem(sdf_Layer_t const* _this, tf_Token_t* _result);

/// Sets the color management system used to interpret the color 
/// configuration asset-path authored this layer.
int sdf_Layer_SetColorManagementSystem(sdf_Layer_t* _this, tf_Token_t const* cms);

/// Returns true if colorManagementSystem metadata is set in this layer.
/// \sa GetColorManagementSystem(), SetColorManagementSystem()
int sdf_Layer_HasColorManagementSystem(sdf_Layer_t const* _this, bool* _result);

/// Clears the 'colorManagementSystem' metadata authored in this layer. 
/// \sa HascolorManagementSystem(), SetColorManagementSystem()
int sdf_Layer_ClearColorManagementSystem(sdf_Layer_t* _this);

/// Returns the comment string for this layer.
/// 
/// The default value for comment is "".
int sdf_Layer_GetComment(sdf_Layer_t const* _this, std_String_t* _result);

/// Sets the comment string for this layer.
int sdf_Layer_SetComment(sdf_Layer_t* _this, std_String_t const* comment);

/// Return the defaultPrim metadata for this layer.  This field
/// indicates the name of which root prim should be targeted by a reference
/// or payload to this layer that doesn't specify a prim path.
/// 
/// The default value is the empty token.
int sdf_Layer_GetDefaultPrim(sdf_Layer_t const* _this, tf_Token_t* _result);

/// Set the default prim metadata for this layer.  The root prim with this
/// name will be targeted by a reference or a payload to this layer that
/// doesn't specify a prim path.  Note that this must be a root prim
/// <b>name</b> not a path.  E.g. "rootPrim" rather than "/rootPrim".  See
/// GetDefaultPrim().
int sdf_Layer_SetDefaultPrim(sdf_Layer_t* _this, tf_Token_t const* name);

/// Return true if the default prim metadata is set in this layer.  See
/// GetDefaultPrim() and SetDefaultPrim().
int sdf_Layer_HasDefaultPrim(sdf_Layer_t* _this, bool* _result);

/// Clear the default prim metadata for this layer.  See GetDefaultPrim()
/// and SetDefaultPrim().
int sdf_Layer_ClearDefaultPrim(sdf_Layer_t* _this);

/// Returns the documentation string for this layer.
/// 
/// The default value for documentation is "".
int sdf_Layer_GetDocumentation(sdf_Layer_t const* _this, std_String_t* _result);

/// Sets the documentation string for this layer.
int sdf_Layer_SetDocumentation(sdf_Layer_t* _this, std_String_t const* documentation);

/// Returns the layer's start timeCode.
/// 
/// The start and end timeCodes of a layer represent the suggested playback 
/// range.  However, time-varying content is not limited to the timeCode range 
/// of the layer.
/// 
/// The default value for startTimeCode is 0.
int sdf_Layer_GetStartTimeCode(sdf_Layer_t const* _this, double* _result);

/// Sets the layer's start timeCode.
int sdf_Layer_SetStartTimeCode(sdf_Layer_t* _this, double startTimecode);

/// Returns true if the layer has a startTimeCode opinion.
int sdf_Layer_HasStartTimeCode(sdf_Layer_t const* _this, bool* _result);

/// Clear the startTimeCode opinion.
int sdf_Layer_ClearStartTimeCode(sdf_Layer_t* _this);

/// Returns the layer's end timeCode.
/// The start and end timeCode of a layer represent a suggested playback range.  
/// However, time-varying content is not limited to the timeCode range of the 
/// layer.
/// 
/// The default value for endTimeCode is 0.
int sdf_Layer_GetEndTimeCode(sdf_Layer_t const* _this, double* _result);

/// Sets the layer's end timeCode.
int sdf_Layer_SetEndTimeCode(sdf_Layer_t* _this, double endTimeCode);

/// Returns true if the layer has an endTimeCode opinion.
int sdf_Layer_HasEndTimeCode(sdf_Layer_t const* _this, bool* _result);

/// Clear the endTimeCode opinion.
int sdf_Layer_ClearEndTimeCode(sdf_Layer_t* _this);

/// Returns the layer's timeCodes per second.
/// 
/// Scales the time ordinate for samples contained in the file to seconds.  
/// If timeCodesPerSecond is 24, then a sample at time ordinate 24 should 
/// be viewed exactly one second after the sample at time ordinate 0.
/// 
/// If this layer doesn't have an authored value for timeCodesPerSecond, but
/// it does have an authored value for framesPerSecond, this method will
/// return the value of framesPerSecond.  This "dynamic fallback" allows
/// layers to lock framesPerSecond and timeCodesPerSecond to the same value
/// by specifying only framesPerSecond.
/// 
/// The default value of timeCodesPerSecond, used only if there is no 
/// authored value for either timeCodesPerSecond or framesPerSecond, is 24.
int sdf_Layer_GetTimeCodesPerSecond(sdf_Layer_t const* _this, double* _result);

/// Sets the layer's timeCodes per second
int sdf_Layer_SetTimeCodesPerSecond(sdf_Layer_t* _this, double timeCodesPerSecond);

/// Returns true if the layer has a timeCodesPerSecond opinion.
int sdf_Layer_HasTimeCodesPerSecond(sdf_Layer_t const* _this, bool* _result);

/// Clear the timeCodesPerSecond opinion.
int sdf_Layer_ClearTimeCodesPerSecond(sdf_Layer_t* _this);

/// Returns the layer's frames per second.
/// 
/// This makes an advisory statement about how the contained data can be 
/// most usefully consumed and presented.  It's primarily an indication of 
/// the expected playback rate for the data, but a timeline editing tool 
/// might also want to use this to decide how to scale and label its 
/// timeline.  
/// 
/// The default  value for framesPerSecond is 24.
int sdf_Layer_GetFramesPerSecond(sdf_Layer_t const* _this, double* _result);

/// Sets the layer's frames per second
int sdf_Layer_SetFramesPerSecond(sdf_Layer_t* _this, double framesPerSecond);

/// Returns true if the layer has a frames per second opinion.
int sdf_Layer_HasFramesPerSecond(sdf_Layer_t const* _this, bool* _result);

/// Clear the framesPerSecond opinion.
int sdf_Layer_ClearFramesPerSecond(sdf_Layer_t* _this);

/// Returns the layer's frame precision.
int sdf_Layer_GetFramePrecision(sdf_Layer_t const* _this, int* _result);

/// Sets the layer's frame precision.
int sdf_Layer_SetFramePrecision(sdf_Layer_t* _this, int framePrecision);

/// Returns true if the layer has a frames precision opinion.
int sdf_Layer_HasFramePrecision(sdf_Layer_t const* _this, bool* _result);

/// Clear the framePrecision opinion.
int sdf_Layer_ClearFramePrecision(sdf_Layer_t* _this);

/// Returns the layer's owner.
int sdf_Layer_GetOwner(sdf_Layer_t const* _this, std_String_t* _result);

/// Sets the layer's owner.
int sdf_Layer_SetOwner(sdf_Layer_t* _this, std_String_t const* owner);

/// Returns true if the layer has an owner opinion.
int sdf_Layer_HasOwner(sdf_Layer_t const* _this, bool* _result);

/// Clear the owner opinion.
int sdf_Layer_ClearOwner(sdf_Layer_t* _this);

/// Returns the layer's session owner.
/// Note: This should only be used by session layers.
int sdf_Layer_GetSessionOwner(sdf_Layer_t const* _this, std_String_t* _result);

/// Sets the layer's session owner.
/// Note: This should only be used by session layers.
int sdf_Layer_SetSessionOwner(sdf_Layer_t* _this, std_String_t const* owner);

/// Returns true if the layer has a session owner opinion.
int sdf_Layer_HasSessionOwner(sdf_Layer_t const* _this, bool* _result);

int sdf_Layer_ClearSessionOwner(sdf_Layer_t* _this);

/// Returns true if the layer's sublayers are expected to have owners.
int sdf_Layer_GetHasOwnedSubLayers(sdf_Layer_t const* _this, bool* _result);

/// Sets whether the layer's sublayers are expected to have owners.
int sdf_Layer_SetHasOwnedSubLayers(sdf_Layer_t* _this, bool param00);

/// Returns the CustomLayerData dictionary associated with this layer.
/// 
/// This is a dictionary is custom metadata that is associated with
/// this layer. It allows users to encode any set of information for
/// human or program consumption.
int sdf_Layer_GetCustomLayerData(sdf_Layer_t const* _this, vt_Dictionary_t* _result);

/// Sets the CustomLayerData dictionary associated with this layer.
int sdf_Layer_SetCustomLayerData(sdf_Layer_t* _this, vt_Dictionary_t const* value);

/// Returns true if CustomLayerData is authored on the layer.
int sdf_Layer_HasCustomLayerData(sdf_Layer_t const* _this, bool* _result);

/// Clears out the CustomLayerData dictionary associated with this layer.
int sdf_Layer_ClearCustomLayerData(sdf_Layer_t* _this);

/// Returns the expression variables dictionary authored on this layer.
/// See \ref Sdf_Page_VariableExpressions for more details.
int sdf_Layer_GetExpressionVariables(sdf_Layer_t const* _this, vt_Dictionary_t* _result);

/// Sets the expression variables dictionary for this layer.
int sdf_Layer_SetExpressionVariables(sdf_Layer_t* _this, vt_Dictionary_t const* expressionVars);

/// Returns true if expression variables are authored on this layer.
int sdf_Layer_HasExpressionVariables(sdf_Layer_t const* _this, bool* _result);

/// Clears the expression variables dictionary authored on this layer.
int sdf_Layer_ClearExpressionVariables(sdf_Layer_t* _this);

/// Returns a proxy for this layer's sublayers.
/// 
/// Sub-layers are the weaker layers directly included by this layer.
/// They're in order from strongest to weakest and they're all weaker
/// than this layer.
/// 
/// Edits through the proxy changes the sublayers.  If this layer does
/// not have any sublayers the proxy is empty.
/// 
/// Sub-layer paths are asset paths, and thus must contain valid asset path
/// characters (UTF-8 without C0 and C1 controls).  See SdfAssetPath for
/// more details.
int sdf_Layer_GetSubLayerPaths(sdf_Layer_t const* _this, sdf_SubLayerProxy_t* _result);

/// Sets the paths of the layer's sublayers.
int sdf_Layer_SetSubLayerPaths(sdf_Layer_t* _this, std_StringVector_t const* newPaths);

/// Returns the number of sublayer paths (and offsets).
int sdf_Layer_GetNumSubLayerPaths(sdf_Layer_t const* _this, size_t* _result);

/// Inserts new sublayer path at the given index.
/// 
/// The default index of -1 means to insert at the end.
int sdf_Layer_InsertSubLayerPath(sdf_Layer_t* _this, std_String_t const* path, int index);

/// Removes sublayer path at the given index.
int sdf_Layer_RemoveSubLayerPath(sdf_Layer_t* _this, int index);

/// Returns the layer offsets for all the subLayer paths.
int sdf_Layer_GetSubLayerOffsets(sdf_Layer_t const* _this, sdf_LayerOffsetVector_t* _result);

/// Returns the layer offset for the subLayer path at the given index.
int sdf_Layer_GetSubLayerOffset(sdf_Layer_t const* _this, int index, sdf_LayerOffset_t* _result);

/// Sets the layer offset for the subLayer path at the given index.
int sdf_Layer_SetSubLayerOffset(sdf_Layer_t* _this, sdf_LayerOffset_t const* offset, int index);

/// Returns the layer's pseudo-root prim.
/// 
/// The layer's root prims are namespace children of the pseudo-root.
/// The pseudo-root exists to make the namespace hierarchy a tree
/// instead of a forest.  This simplifies the implementation of
/// some algorithms.
/// 
/// A layer always has a pseudo-root prim.
int sdf_Layer_GetPseudoRoot(sdf_Layer_t const* _this, sdf_PrimSpecHandle_t* _result);

/// Returns the object at the given \p path.
/// 
/// There is no distinction between an absolute and relative path
/// at the SdLayer level.
/// 
/// Returns \c NULL if there is no object at \p path.
int sdf_Layer_GetObjectAtPath(sdf_Layer_t* _this, sdf_Path_t const* path, sdf_SpecHandle_t* _result);

/// Returns the prim at the given \p path.
/// 
/// Returns \c NULL if there is no prim at \p path.
/// This is simply a more specifically typed version of
/// \c GetObjectAtPath().
int sdf_Layer_GetPrimAtPath(sdf_Layer_t* _this, sdf_Path_t const* path, sdf_PrimSpecHandle_t* _result);

/// Returns a property at the given \p path.
/// 
/// Returns \c NULL if there is no property at \p path.
/// This is simply a more specifically typed version of
/// \c GetObjectAtPath().
int sdf_Layer_GetPropertyAtPath(sdf_Layer_t* _this, sdf_Path_t const* path, sdf_PropertySpecHandle_t* _result);

/// Returns an attribute at the given \p path.
/// 
/// Returns \c NULL if there is no attribute at \p path.
/// This is simply a more specifically typed version of
/// \c GetObjectAtPath().
int sdf_Layer_GetAttributeAtPath(sdf_Layer_t* _this, sdf_Path_t const* path, sdf_AttributeSpecHandle_t* _result);

/// Returns a relationship at the given \p path.
/// 
/// Returns \c NULL if there is no relationship at \p path.
/// This is simply a more specifically typed version of
/// \c GetObjectAtPath().
int sdf_Layer_GetRelationshipAtPath(sdf_Layer_t* _this, sdf_Path_t const* path, sdf_RelationshipSpecHandle_t* _result);

/// Returns true if the caller is allowed to modify the layer and 
/// false otherwise.  A layer may have to perform some action to acquire 
/// permission to be edited.
int sdf_Layer_PermissionToEdit(sdf_Layer_t const* _this, bool* _result);

/// Returns true if the caller is allowed to save the layer to its 
/// existing fileName and false otherwise.
int sdf_Layer_PermissionToSave(sdf_Layer_t const* _this, bool* _result);

/// Sets permission to edit.
int sdf_Layer_SetPermissionToEdit(sdf_Layer_t* _this, bool allow);

/// Sets permission to save.
int sdf_Layer_SetPermissionToSave(sdf_Layer_t* _this, bool allow);

/// Check if a batch of namespace edits will succeed.  This returns
/// \c SdfNamespaceEditDetail::Okay if they will succeed as a batch,
/// \c SdfNamespaceEditDetail::Unbatched if the edits will succeed but
/// will be applied unbatched, and \c SdfNamespaceEditDetail::Error
/// if they will not succeed.  No edits will be performed in any case.
/// 
/// If \p details is not \c NULL and the method does not return \c Okay
/// then details about the problems will be appended to \p details.  A
/// problem may cause the method to return early, so \p details may not
/// list every problem.
/// 
/// Note that Sdf does not track backpointers so it's unable to fix up
/// targets/connections to namespace edited objects.  Clients must fix
/// those to prevent them from falling off.  In addition, this method
/// will report failure if any relational attribute with a target to
/// a namespace edited object is subsequently edited (in the same
/// batch).  Clients should perform edits on relational attributes
/// first.
/// 
/// Clients may wish to report unbatch details to the user to confirm
/// that the edits should be applied unbatched.  This will give the
/// user a chance to correct any problems that cause batching to fail
/// and try again.
int sdf_Layer_CanApply(sdf_Layer_t const* _this, sdf_BatchNamespaceEdit_t const* param00, sdf_NamespaceEditDetailVector_t* details, int* _result);

/// Performs a batch of namespace edits.  Returns \c true on success
/// and \c false on failure.  On failure, no namespace edits will have
/// occurred.
int sdf_Layer_Apply(sdf_Layer_t* _this, sdf_BatchNamespaceEdit_t const* param00, bool* _result);

/// Returns \c true if the layer is dirty, i.e. has changed from
/// its persistent representation.
int sdf_Layer_IsDirty(sdf_Layer_t const* _this, bool* _result);

/// \name Time-sample API
/// @{
int sdf_Layer_ListAllTimeSamples(sdf_Layer_t const* _this, std_DoubleSet_t* _result);

int sdf_Layer_ListTimeSamplesForPath(sdf_Layer_t const* _this, sdf_Path_t const* path, std_DoubleSet_t* _result);

int sdf_Layer_GetBracketingTimeSamplesForPath(sdf_Layer_t* _this, sdf_Path_t const* path, double time, double* tLower, double* tUpper, bool* _result);

int sdf_Layer_GetBracketingTimeSamples(sdf_Layer_t* _this, double time, double* tLower, double* tUpper, bool* _result);

int sdf_Layer_GetNumTimeSamplesForPath(sdf_Layer_t const* _this, sdf_Path_t const* path, size_t* _result);

int sdf_Layer_QueryTimeSample(sdf_Layer_t const* _this, sdf_Path_t const* path, double time, vt_Value_t* value, bool* _result);

int sdf_Layer_SetTimeSample(sdf_Layer_t* _this, sdf_Path_t const* path, double time, vt_Value_t const* value);

int sdf_Layer_EraseTimeSample(sdf_Layer_t* _this, sdf_Path_t const* path, double time);

int sdf_Layer_DumpLayerInfo();

int sdf_Layer_dtor(sdf_Layer_t* _this);

int sdf_LayerHandle_dtor(sdf_LayerHandle_t* _this);

int sdf_LayerHandleVector_data(sdf_LayerHandleVector_t* _this, sdf_LayerHandle_t** _result);

int sdf_LayerHandleVector_data_const(sdf_LayerHandleVector_t const* _this, sdf_LayerHandle_t const** _result);

int sdf_LayerHandleVector_empty(sdf_LayerHandleVector_t const* _this, bool* _result);

int sdf_LayerHandleVector_size(sdf_LayerHandleVector_t const* _this, size_t* _result);

int sdf_LayerHandleVector_max_size(sdf_LayerHandleVector_t const* _this, size_t* _result);

int sdf_LayerHandleVector_reserve(sdf_LayerHandleVector_t* _this, size_t const _Newcapacity);

int sdf_LayerHandleVector_capacity(sdf_LayerHandleVector_t const* _this, size_t* _result);

int sdf_LayerHandleVector_clear(sdf_LayerHandleVector_t* _this);

int sdf_LayerHandleVector_push_back(sdf_LayerHandleVector_t* _this, sdf_LayerHandle_t const* _Val);

int sdf_LayerHandleVector_pop_back(sdf_LayerHandleVector_t* _this);

int sdf_LayerHandleVector_resize(sdf_LayerHandleVector_t* _this, size_t const _Newsize);

int sdf_LayerHandleVector_resize_with(sdf_LayerHandleVector_t* _this, size_t const _Newsize, sdf_LayerHandle_t const* _Val);

int sdf_LayerHandleVector_op_index(sdf_LayerHandleVector_t const* _this, size_t const _Pos, sdf_LayerHandle_t const** _result);

int sdf_LayerHandleVector_default(sdf_LayerHandleVector_t** _result);

int sdf_LayerHandleVector_dtor(sdf_LayerHandleVector_t* _this);

/// Returns the time offset.
int sdf_LayerOffset_GetOffset(sdf_LayerOffset_t const* _this, double* _result);

/// Returns the time scale factor.
int sdf_LayerOffset_GetScale(sdf_LayerOffset_t const* _this, double* _result);

/// Sets the time offset.
int sdf_LayerOffset_SetOffset(sdf_LayerOffset_t* _this, double newOffset);

/// Sets the time scale factor.
int sdf_LayerOffset_SetScale(sdf_LayerOffset_t* _this, double newScale);

/// Returns \c true if this is an identity transformation, with
/// an offset of 0.0 and a scale of 1.0.
int sdf_LayerOffset_IsIdentity(sdf_LayerOffset_t const* _this, bool* _result);

/// Returns \c true if this offset is valid, i.e. both the offset and
/// scale are finite (not infinite or NaN).  Note that a valid layer
/// offset's inverse may be invalid.
int sdf_LayerOffset_IsValid(sdf_LayerOffset_t const* _this, bool* _result);

/// Gets the inverse offset, which performs the opposite transformation.
int sdf_LayerOffset_GetInverse(sdf_LayerOffset_t const* _this, sdf_LayerOffset_t* _result);

/// Returns whether the offsets are equal.
int sdf_LayerOffset_op_eq(sdf_LayerOffset_t const* _this, sdf_LayerOffset_t const* rhs, bool* _result);

/// Returns whether this offset is less than another.  The meaning
/// of less than is somewhat arbitrary.
int sdf_LayerOffset_op_lt(sdf_LayerOffset_t const* _this, sdf_LayerOffset_t const* rhs, bool* _result);

/// Composes this with the offset \e rhs, such that the resulting
/// offset is equivalent to first applying \e rhs and then \e *this.
int sdf_LayerOffset_apply(sdf_LayerOffset_t const* _this, sdf_LayerOffset_t const* rhs, sdf_LayerOffset_t* _result);

/// Applies the offset to the given value.
int sdf_LayerOffset_apply_to_double(sdf_LayerOffset_t const* _this, double rhs, double* _result);

/// Applies the offset to the given value.
int sdf_LayerOffset_apply_to_timecode(sdf_LayerOffset_t const* _this, sdf_TimeCode_t const* rhs, sdf_TimeCode_t* _result);

int sdf_LayerOffset_new(double offset, double scale, sdf_LayerOffset_t** _result);

int sdf_LayerOffset_dtor(sdf_LayerOffset_t* _this);

int sdf_LayerOffsetVector_data(sdf_LayerOffsetVector_t* _this, sdf_LayerOffset_t** _result);

int sdf_LayerOffsetVector_data_const(sdf_LayerOffsetVector_t const* _this, sdf_LayerOffset_t const** _result);

int sdf_LayerOffsetVector_empty(sdf_LayerOffsetVector_t const* _this, bool* _result);

int sdf_LayerOffsetVector_size(sdf_LayerOffsetVector_t const* _this, size_t* _result);

int sdf_LayerOffsetVector_max_size(sdf_LayerOffsetVector_t const* _this, size_t* _result);

int sdf_LayerOffsetVector_reserve(sdf_LayerOffsetVector_t* _this, size_t const _Newcapacity);

int sdf_LayerOffsetVector_capacity(sdf_LayerOffsetVector_t const* _this, size_t* _result);

int sdf_LayerOffsetVector_clear(sdf_LayerOffsetVector_t* _this);

int sdf_LayerOffsetVector_push_back(sdf_LayerOffsetVector_t* _this, sdf_LayerOffset_t const* _Val);

int sdf_LayerOffsetVector_pop_back(sdf_LayerOffsetVector_t* _this);

int sdf_LayerOffsetVector_resize(sdf_LayerOffsetVector_t* _this, size_t const _Newsize);

int sdf_LayerOffsetVector_resize_with(sdf_LayerOffsetVector_t* _this, size_t const _Newsize, sdf_LayerOffset_t const* _Val);

int sdf_LayerOffsetVector_op_index(sdf_LayerOffsetVector_t const* _this, size_t const _Pos, sdf_LayerOffset_t const** _result);

int sdf_LayerOffsetVector_default(sdf_LayerOffsetVector_t** _result);

int sdf_LayerOffsetVector_dtor(sdf_LayerOffsetVector_t* _this);

int sdf_LayerRefPtr_dtor(sdf_LayerRefPtr_t* _this);

/// Returns the layer handle this tree node represents.
int sdf_LayerTree_GetLayer(sdf_LayerTree_t const* _this, sdf_LayerHandle_t const** _result);

/// Returns the cumulative layer offset from the root of the tree.
int sdf_LayerTree_GetOffset(sdf_LayerTree_t const* _this, sdf_LayerOffset_t const** _result);

/// Returns the children of this tree node.
int sdf_LayerTree_GetChildTrees(sdf_LayerTree_t const* _this, sdf_LayerTreeHandleVector_t const** _result);

int sdf_LayerTree_dtor(sdf_LayerTree_t* _this);

int sdf_LayerTreeHandle_dtor(sdf_LayerTreeHandle_t* _this);

int sdf_LayerTreeHandleVector_data(sdf_LayerTreeHandleVector_t* _this, sdf_LayerTreeHandle_t** _result);

int sdf_LayerTreeHandleVector_data_const(sdf_LayerTreeHandleVector_t const* _this, sdf_LayerTreeHandle_t const** _result);

int sdf_LayerTreeHandleVector_empty(sdf_LayerTreeHandleVector_t const* _this, bool* _result);

int sdf_LayerTreeHandleVector_size(sdf_LayerTreeHandleVector_t const* _this, size_t* _result);

int sdf_LayerTreeHandleVector_max_size(sdf_LayerTreeHandleVector_t const* _this, size_t* _result);

int sdf_LayerTreeHandleVector_reserve(sdf_LayerTreeHandleVector_t* _this, size_t const _Newcapacity);

int sdf_LayerTreeHandleVector_capacity(sdf_LayerTreeHandleVector_t const* _this, size_t* _result);

int sdf_LayerTreeHandleVector_clear(sdf_LayerTreeHandleVector_t* _this);

int sdf_LayerTreeHandleVector_push_back(sdf_LayerTreeHandleVector_t* _this, sdf_LayerTreeHandle_t const* _Val);

int sdf_LayerTreeHandleVector_pop_back(sdf_LayerTreeHandleVector_t* _this);

int sdf_LayerTreeHandleVector_resize(sdf_LayerTreeHandleVector_t* _this, size_t const _Newsize);

int sdf_LayerTreeHandleVector_resize_with(sdf_LayerTreeHandleVector_t* _this, size_t const _Newsize, sdf_LayerTreeHandle_t const* _Val);

int sdf_LayerTreeHandleVector_op_index(sdf_LayerTreeHandleVector_t const* _this, size_t const _Pos, sdf_LayerTreeHandle_t const** _result);

int sdf_LayerTreeHandleVector_default(sdf_LayerTreeHandleVector_t** _result);

int sdf_LayerTreeHandleVector_dtor(sdf_LayerTreeHandleVector_t* _this);

int sdf_StringListOp_HasKeys(sdf_StringListOp_t const* _this, bool* _result);

int sdf_StringListOp_IsExplicit(sdf_StringListOp_t const* _this, bool* _result);

int sdf_StringListOp_GetExplicitItems(sdf_StringListOp_t const* _this, std_StringVector_t const** _result);

int sdf_StringListOp_GetAddedItems(sdf_StringListOp_t const* _this, std_StringVector_t const** _result);

int sdf_StringListOp_GetPrependedItems(sdf_StringListOp_t const* _this, std_StringVector_t const** _result);

int sdf_StringListOp_GetAppendedItems(sdf_StringListOp_t const* _this, std_StringVector_t const** _result);

int sdf_StringListOp_GetDeletedItems(sdf_StringListOp_t const* _this, std_StringVector_t const** _result);

int sdf_StringListOp_GetOrderedItems(sdf_StringListOp_t const* _this, std_StringVector_t const** _result);

int sdf_StringListOp_GetAppliedItems(sdf_StringListOp_t const* _this, std_StringVector_t* _result);

int sdf_StringListOp_new(sdf_StringListOp_t** _result);

int sdf_StringListOp_dtor(sdf_StringListOp_t* _this);

int sdf_NameChildrenOrderProxy_dtor(sdf_NameChildrenOrderProxy_t* _this);

int sdf_NameEditorProxy_dtor(sdf_NameEditorProxy_t* _this);

/// Returns a namespace edit that removes the object at \p currentPath.
int sdf_NamespaceEdit_Remove(sdf_Path_t const* currentPath, sdf_NamespaceEdit_t* _result);

/// Returns a namespace edit that renames the prim or property at
/// \p currentPath to \p name
int sdf_NamespaceEdit_Rename(sdf_Path_t const* currentPath, tf_Token_t const* name, sdf_NamespaceEdit_t* _result);

/// Returns a namespace edit to reorder the prim or property at
/// \p currentPath to index \p index.
int sdf_NamespaceEdit_Reorder(sdf_Path_t const* currentPath, int index, sdf_NamespaceEdit_t* _result);

/// Returns a namespace edit to reparent the prim or property at
/// \p currentPath to be under \p newParentPath at index \p index.
int sdf_NamespaceEdit_Reparent(sdf_Path_t const* currentPath, sdf_Path_t const* newParentPath, int index, sdf_NamespaceEdit_t* _result);

/// Returns a namespace edit to reparent the prim or property at
/// \p currentPath to be under \p newParentPath at index \p index
/// with the name \p name.
int sdf_NamespaceEdit_ReparentAndRename(sdf_Path_t const* currentPath, sdf_Path_t const* newParentPath, tf_Token_t const* name, int index, sdf_NamespaceEdit_t* _result);

int sdf_NamespaceEdit_from_paths(sdf_NamespaceEdit_t** _result);

int sdf_NamespaceEdit_new(sdf_NamespaceEdit_t** _result);

int sdf_NamespaceEdit_dtor(sdf_NamespaceEdit_t* _this);

int sdf_NamespaceEditVector_data(sdf_NamespaceEditVector_t* _this, sdf_NamespaceEdit_t** _result);

int sdf_NamespaceEditVector_data_const(sdf_NamespaceEditVector_t const* _this, sdf_NamespaceEdit_t const** _result);

int sdf_NamespaceEditVector_empty(sdf_NamespaceEditVector_t const* _this, bool* _result);

int sdf_NamespaceEditVector_size(sdf_NamespaceEditVector_t const* _this, size_t* _result);

int sdf_NamespaceEditVector_max_size(sdf_NamespaceEditVector_t const* _this, size_t* _result);

int sdf_NamespaceEditVector_reserve(sdf_NamespaceEditVector_t* _this, size_t const _Newcapacity);

int sdf_NamespaceEditVector_capacity(sdf_NamespaceEditVector_t const* _this, size_t* _result);

int sdf_NamespaceEditVector_clear(sdf_NamespaceEditVector_t* _this);

int sdf_NamespaceEditVector_push_back(sdf_NamespaceEditVector_t* _this, sdf_NamespaceEdit_t const* _Val);

int sdf_NamespaceEditVector_pop_back(sdf_NamespaceEditVector_t* _this);

int sdf_NamespaceEditVector_resize(sdf_NamespaceEditVector_t* _this, size_t const _Newsize);

int sdf_NamespaceEditVector_resize_with(sdf_NamespaceEditVector_t* _this, size_t const _Newsize, sdf_NamespaceEdit_t const* _Val);

int sdf_NamespaceEditVector_op_index(sdf_NamespaceEditVector_t const* _this, size_t const _Pos, sdf_NamespaceEdit_t const** _result);

int sdf_NamespaceEditVector_default(sdf_NamespaceEditVector_t** _result);

int sdf_NamespaceEditVector_dtor(sdf_NamespaceEditVector_t* _this);

int sdf_NamespaceEditDetail_dtor(sdf_NamespaceEditDetail_t* _this);

int sdf_NamespaceEditDetailVector_data(sdf_NamespaceEditDetailVector_t* _this, sdf_NamespaceEditDetail_t** _result);

int sdf_NamespaceEditDetailVector_data_const(sdf_NamespaceEditDetailVector_t const* _this, sdf_NamespaceEditDetail_t const** _result);

int sdf_NamespaceEditDetailVector_empty(sdf_NamespaceEditDetailVector_t const* _this, bool* _result);

int sdf_NamespaceEditDetailVector_size(sdf_NamespaceEditDetailVector_t const* _this, size_t* _result);

int sdf_NamespaceEditDetailVector_max_size(sdf_NamespaceEditDetailVector_t const* _this, size_t* _result);

int sdf_NamespaceEditDetailVector_reserve(sdf_NamespaceEditDetailVector_t* _this, size_t const _Newcapacity);

int sdf_NamespaceEditDetailVector_capacity(sdf_NamespaceEditDetailVector_t const* _this, size_t* _result);

int sdf_NamespaceEditDetailVector_clear(sdf_NamespaceEditDetailVector_t* _this);

int sdf_NamespaceEditDetailVector_push_back(sdf_NamespaceEditDetailVector_t* _this, sdf_NamespaceEditDetail_t const* _Val);

int sdf_NamespaceEditDetailVector_pop_back(sdf_NamespaceEditDetailVector_t* _this);

int sdf_NamespaceEditDetailVector_resize(sdf_NamespaceEditDetailVector_t* _this, size_t const _Newsize);

int sdf_NamespaceEditDetailVector_resize_with(sdf_NamespaceEditDetailVector_t* _this, size_t const _Newsize, sdf_NamespaceEditDetail_t const* _Val);

int sdf_NamespaceEditDetailVector_op_index(sdf_NamespaceEditDetailVector_t const* _this, size_t const _Pos, sdf_NamespaceEditDetail_t const** _result);

int sdf_NamespaceEditDetailVector_default(sdf_NamespaceEditDetailVector_t** _result);

int sdf_NamespaceEditDetailVector_dtor(sdf_NamespaceEditDetailVector_t* _this);

int sdf_NoticeBase_dtor(sdf_NoticeBase_t* _this);

int sdf_NoticeBaseLayersDidChange_dtor(sdf_NoticeBaseLayersDidChange_t* _this);

int sdf_NoticeLayerDidReloadContent_dtor(sdf_NoticeLayerDidReloadContent_t* _this);

int sdf_NoticeLayerDidReplaceContent_dtor(sdf_NoticeLayerDidReplaceContent_t* _this);

int sdf_NoticeLayerDidSaveLayerToFile_dtor(sdf_NoticeLayerDidSaveLayerToFile_t* _this);

int sdf_NoticeLayerIdentifierDidChange_dtor(sdf_NoticeLayerIdentifierDidChange_t* _this);

int sdf_NoticeLayerInfoDidChange_dtor(sdf_NoticeLayerInfoDidChange_t* _this);

int sdf_NoticeLayerMutenessChanged_dtor(sdf_NoticeLayerMutenessChanged_t* _this);

int sdf_NoticeLayersDidChange_dtor(sdf_NoticeLayersDidChange_t* _this);

int sdf_NoticeLayersDidChangeSentPerLayer_dtor(sdf_NoticeLayersDidChangeSentPerLayer_t* _this);

/// Returns the number of path elements in this path.
int sdf_Path_GetPathElementCount(sdf_Path_t const* _this, size_t* _result);

/// Returns whether the path is absolute.
int sdf_Path_IsAbsolutePath(sdf_Path_t const* _this, bool* _result);

/// Return true if this path is the AbsoluteRootPath().
int sdf_Path_IsAbsoluteRootPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a prim.
int sdf_Path_IsPrimPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a prim or the absolute root.
int sdf_Path_IsAbsoluteRootOrPrimPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a root prim.
/// 
/// the path must be absolute and have a single element
/// (for example <c>/foo</c>).
int sdf_Path_IsRootPrimPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a property.
/// 
/// A relational attribute is considered to be a property, so this
/// method will return true for relational attributes as well
/// as properties of prims.
int sdf_Path_IsPropertyPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a prim's property.
/// 
/// A relational attribute is not a prim property.
int sdf_Path_IsPrimPropertyPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a namespaced property.
/// 
/// A namespaced property has colon embedded in its name.
int sdf_Path_IsNamespacedPropertyPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a variant selection for a
/// prim.
int sdf_Path_IsPrimVariantSelectionPath(sdf_Path_t const* _this, bool* _result);

/// Return true if this path is a prim path or is a prim variant
/// selection path.
int sdf_Path_IsPrimOrPrimVariantSelectionPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path or any of its parent paths identifies
/// a variant selection for a prim.
int sdf_Path_ContainsPrimVariantSelection(sdf_Path_t const* _this, bool* _result);

/// Return true if this path contains any property elements, false
/// otherwise.  A false return indicates a prim-like path, specifically a
/// root path, a prim path, or a prim variant selection path.  A true return
/// indicates a property-like path: a prim property path, a target path, a
/// relational attribute path, etc.
int sdf_Path_ContainsPropertyElements(sdf_Path_t const* _this, bool* _result);

/// Return true if this path is or has a prefix that's a target path or a
/// mapper path.
int sdf_Path_ContainsTargetPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a relational attribute.
/// 
/// If this is true, IsPropertyPath() will also be true.
int sdf_Path_IsRelationalAttributePath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a relationship or
/// connection target.
int sdf_Path_IsTargetPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a connection mapper.
int sdf_Path_IsMapperPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a connection mapper arg.
int sdf_Path_IsMapperArgPath(sdf_Path_t const* _this, bool* _result);

/// Returns whether the path identifies a connection expression.
int sdf_Path_IsExpressionPath(sdf_Path_t const* _this, bool* _result);

/// Returns true if this is the empty path (SdfPath::EmptyPath()).
int sdf_Path_IsEmpty(sdf_Path_t const* _this, bool* _result);

/// Return the string representation of this path as a TfToken.
/// 
/// This function is recommended only for human-readable or diagnostic
/// output.  Use the SdfPath API to manipulate paths.  It is less
/// error-prone and has better performance.
int sdf_Path_GetAsToken(sdf_Path_t const* _this, tf_Token_t* _result);

/// Return the string representation of this path as a std::string.
/// 
/// This function is recommended only for human-readable or diagnostic
/// output.  Use the SdfPath API to manipulate paths.  It is less
/// error-prone and has better performance.
int sdf_Path_GetAsString(sdf_Path_t const* _this, std_String_t* _result);

/// Return the string representation of this path as a std::string.
/// 
/// This function returns a persistent lvalue.  If an rvalue will suffice,
/// call GetAsString() instead.  That avoids populating internal data
/// structures to hold the persistent string.
/// 
/// This function is recommended only for human-readable or diagnostic
/// output.  Use the SdfPath API to manipulate paths.  It is less
/// error-prone and has better performance.
int sdf_Path_GetString(sdf_Path_t const* _this, std_String_t const** _result);

/// Returns the string representation of this path as a c string.
/// 
/// This function returns a pointer to a persistent c string.  If a
/// temporary c string will suffice, call GetAsString().c_str() instead.
/// That avoids populating internal data structures to hold the persistent
/// string.
/// 
/// This function is recommended only for human-readable or diagnostic
/// output.  Use the SdfPath API to manipulate paths.  It is less
/// error-prone and has better performance.
int sdf_Path_GetText(sdf_Path_t const* _this, char const** _result);

/// Returns the prefix paths of this path.
/// 
/// Prefixes are returned in order of shortest to longest.  The path
/// itself is returned as the last prefix.
/// Note that if the prefix order does not need to be from shortest to
/// longest, it is more efficient to use GetAncestorsRange, which
/// produces an equivalent set of paths, ordered from longest to shortest.
int sdf_Path_GetPrefixes(sdf_Path_t const* _this, sdf_PathVector_t* _result);

/// Return up to \p numPrefixes prefix paths of this path.
/// 
/// Prefixes are returned in order of shortest to longest.  The path itself
/// is returned as the last prefix.  Note that if the prefix order does not
/// need to be from shortest to longest, it is more efficient to use
/// GetAncestorsRange, which produces an equivalent set of paths, ordered
/// from longest to shortest.  If \p numPrefixes is 0 or greater than the
/// number of this path's prefixes, fill all prefixes.
int sdf_Path_GetPrefixes_up_to(sdf_Path_t const* _this, size_t numPrefixes, sdf_PathVector_t* _result);

/// Fills prefixes with prefixes of this path.
/// 
/// This avoids copy constructing the return value.
/// 
/// Prefixes are returned in order of shortest to longest.  The path
/// itself is returned as the last prefix.
/// Note that if the prefix order does not need to be from shortest to
/// longest, it is more efficient to use GetAncestorsRange(), which
/// produces an equivalent set of paths, ordered from longest to shortest.
int sdf_Path_GetPrefixes_in(sdf_Path_t const* _this, sdf_PathVector_t* prefixes);

/// Fill \p prefixes with up to \p numPrefixes prefixes of this path.
/// 
/// Prefixes are filled in order of shortest to longest.  The path itself is
/// included as the last prefix.  Note that if the prefix order does not
/// need to be from shortest to longest, it can be more efficient to use
/// GetAncestorsRange(), which produces an equivalent set of paths, ordered
/// from longest to shortest.  If \p numPrefixes is 0 or greater than the
/// number of this path's prefixes, fill all prefixes.
int sdf_Path_GetPrefixes_in_up_to(sdf_Path_t const* _this, sdf_PathVector_t* prefixes, size_t numPrefixes);

/// Returns the name of the prim, property or relational
/// attribute identified by the path.
/// 
/// Returns EmptyPath if this path is a target or mapper path.
/// 
/// <ul>
///     <li>Returns "" for EmptyPath.</li>
///     <li>Returns "." for ReflexiveRelativePath.</li>
///     <li>Returns ".." for a path ending in ParentPathElement.</li>
/// </ul>
int sdf_Path_GetName(sdf_Path_t const* _this, std_String_t const** _result);

/// Returns the name of the prim, property or relational
/// attribute identified by the path, as a token.
int sdf_Path_GetNameToken(sdf_Path_t const* _this, tf_Token_t const** _result);

/// Returns an ascii representation of the "terminal" element
/// of this path, which can be used to reconstruct the path using
/// \c AppendElementString() on its parent.
/// 
/// EmptyPath(), AbsoluteRootPath(), and ReflexiveRelativePath() are
/// \em not considered elements (one of the defining properties of
/// elements is that they have a parent), so \c GetElementString() will
/// return the empty string for these paths.
/// 
/// Unlike \c GetName() and \c GetTargetPath(), which provide you "some"
/// information about the terminal element, this provides a complete
/// representation of the element, for all element types.
/// 
/// Also note that whereas \c GetName(), \c GetNameToken(), \c GetText(),
/// \c GetString(), and \c GetTargetPath() return cached results, 
/// \c GetElementString() always performs some amount of string
/// manipulation, which you should keep in mind if performance is a concern.
int sdf_Path_GetElementString(sdf_Path_t const* _this, std_String_t* _result);

/// Like GetElementString() but return the value as a TfToken.
int sdf_Path_GetElementToken(sdf_Path_t const* _this, tf_Token_t* _result);

/// Return a copy of this path with its final component changed to
/// \a newName.  This path must be a prim or property path.
/// 
/// This method is shorthand for path.GetParentPath().AppendChild(newName)
/// for prim paths, path.GetParentPath().AppendProperty(newName) for
/// prim property paths, and
/// path.GetParentPath().AppendRelationalAttribute(newName) for relational
/// attribute paths.
/// 
/// Note that only the final path component is ever changed.  If the name of
/// the final path component appears elsewhere in the path, it will not be
/// modified.
/// 
/// Some examples:
/// 
/// ReplaceName('/chars/MeridaGroup', 'AngusGroup') -> '/chars/AngusGroup'
/// ReplaceName('/Merida.tx', 'ty') -> '/Merida.ty'
/// ReplaceName('/Merida.tx[targ].tx', 'ty') -> '/Merida.tx[targ].ty'
int sdf_Path_ReplaceName(sdf_Path_t const* _this, tf_Token_t const* newName, sdf_Path_t* _result);

/// Returns the relational attribute or mapper target path
/// for this path.
/// 
/// Returns EmptyPath if this is not a target, relational attribute or
/// mapper path.
/// 
/// Note that it is possible for a path to have multiple "target" paths.
/// For example a path that identifies a connection target for a
/// relational attribute includes the target of the connection as well
/// as the target of the relational attribute.  In these cases, the
/// "deepest" or right-most target path will be returned (the connection
/// target in this example).
int sdf_Path_GetTargetPath(sdf_Path_t const* _this, sdf_Path_t const** _result);

/// Returns all the relationship target or connection target
/// paths contained in this path, and recursively all the target paths
/// contained in those target paths in reverse depth-first order.
/// 
/// For example, given the path: '/A/B.a[/C/D.a[/E/F.a]].a[/A/B.a[/C/D.a]]'
/// this method produces: '/A/B.a[/C/D.a]', '/C/D.a', '/C/D.a[/E/F.a]',
/// '/E/F.a'
int sdf_Path_GetAllTargetPathsRecursively(sdf_Path_t const* _this, sdf_PathVector_t* result);

/// Return true if both this path and \a prefix are not the empty
/// path and this path has \a prefix as a prefix.  Return false otherwise.
int sdf_Path_HasPrefix(sdf_Path_t const* _this, sdf_Path_t const* prefix, bool* _result);

/// Return the path that identifies this path's namespace parent.
/// 
/// For a prim path (like '/foo/bar'), return the prim's parent's path
/// ('/foo').  For a prim property path (like '/foo/bar.property'), return
/// the prim's path ('/foo/bar').  For a target path (like
/// '/foo/bar.property[/target]') return the property path
/// ('/foo/bar.property').  For a mapper path (like
/// '/foo/bar.property.mapper[/target]') return the property path
/// ('/foo/bar.property).  For a relational attribute path (like
/// '/foo/bar.property[/target].relAttr') return the relationship target's
/// path ('/foo/bar.property[/target]').  For a prim variant selection path
/// (like '/foo/bar{var=sel}') return the prim path ('/foo/bar').  For a
/// root prim path (like '/rootPrim'), return AbsoluteRootPath() ('/').  For
/// a single element relative prim path (like 'relativePrim'), return
/// ReflexiveRelativePath() ('.').  For ReflexiveRelativePath(), return the
/// relative parent path ('..').
/// 
/// Note that the parent path of a relative parent path ('..') is a relative
/// grandparent path ('../..').  Use caution writing loops that walk to
/// parent paths since relative paths have infinitely many ancestors.  To
/// more safely traverse ancestor paths, consider iterating over an
/// SdfPathAncestorsRange instead, as returend by GetAncestorsRange().
int sdf_Path_GetParentPath(sdf_Path_t const* _this, sdf_Path_t* _result);

/// Creates a path by stripping all relational attributes, targets,
/// properties, and variant selections from the leafmost prim path, leaving
/// the nearest path for which \a IsPrimPath() returns true.
/// 
/// See \a GetPrimOrPrimVariantSelectionPath also.
/// 
/// If the path is already a prim path, the same path is returned.
int sdf_Path_GetPrimPath(sdf_Path_t const* _this, sdf_Path_t* _result);

/// Creates a path by stripping all relational attributes, targets,
/// and properties, leaving the nearest path for which
/// \a IsPrimOrPrimVariantSelectionPath() returns true.
/// 
/// See \a GetPrimPath also.
/// 
/// If the path is already a prim or a prim variant selection path, the same
/// path is returned.
int sdf_Path_GetPrimOrPrimVariantSelectionPath(sdf_Path_t const* _this, sdf_Path_t* _result);

/// Creates a path by stripping all properties and relational
/// attributes from this path, leaving the path to the containing prim.
/// 
/// If the path is already a prim or absolute root path, the same
/// path is returned.
int sdf_Path_GetAbsoluteRootOrPrimPath(sdf_Path_t const* _this, sdf_Path_t* _result);

/// Create a path by stripping all variant selections from all
/// components of this path, leaving a path with no embedded variant
/// selections.
int sdf_Path_StripAllVariantSelections(sdf_Path_t const* _this, sdf_Path_t* _result);

/// Creates a path by appending a given relative path to this path.
/// 
/// If the newSuffix is a prim path, then this path must be a prim path
/// or a root path.
/// 
/// If the newSuffix is a prim property path, then this path must be
/// a prim path or the ReflexiveRelativePath.
int sdf_Path_AppendPath(sdf_Path_t const* _this, sdf_Path_t const* newSuffix, sdf_Path_t* _result);

/// Creates a path by appending an element for \p childName
/// to this path.
/// 
/// This path must be a prim path, the AbsoluteRootPath
/// or the ReflexiveRelativePath.
int sdf_Path_AppendChild(sdf_Path_t const* _this, tf_Token_t const* childName, sdf_Path_t* _result);

/// Creates a path by appending an element for \p propName
/// to this path.
/// 
/// This path must be a prim path or the ReflexiveRelativePath.
int sdf_Path_AppendProperty(sdf_Path_t const* _this, tf_Token_t const* propName, sdf_Path_t* _result);

/// Creates a path by appending an element for \p variantSet
/// and \p variant to this path.
/// 
/// This path must be a prim path.
int sdf_Path_AppendVariantSelection(sdf_Path_t const* _this, std_String_t const* variantSet, std_String_t const* variant, sdf_Path_t* _result);

/// Creates a path by appending an element for
/// \p targetPath.
/// 
/// This path must be a prim property or relational attribute path.
int sdf_Path_AppendTarget(sdf_Path_t const* _this, sdf_Path_t const* targetPath, sdf_Path_t* _result);

/// Creates a path by appending an element for
/// \p attrName to this path.
/// 
/// This path must be a target path.
int sdf_Path_AppendRelationalAttribute(sdf_Path_t const* _this, tf_Token_t const* attrName, sdf_Path_t* _result);

/// Replaces the relational attribute's target path
/// 
/// The path must be a relational attribute path.
int sdf_Path_ReplaceTargetPath(sdf_Path_t const* _this, sdf_Path_t const* newTargetPath, sdf_Path_t* _result);

/// Creates a path by appending a mapper element for
/// \p targetPath.
/// 
/// This path must be a prim property or relational attribute path.
int sdf_Path_AppendMapper(sdf_Path_t const* _this, sdf_Path_t const* targetPath, sdf_Path_t* _result);

/// Creates a path by appending an element for
/// \p argName.
/// 
/// This path must be a mapper path.
int sdf_Path_AppendMapperArg(sdf_Path_t const* _this, tf_Token_t const* argName, sdf_Path_t* _result);

/// Creates a path by appending an expression element.
/// 
/// This path must be a prim property or relational attribute path.
int sdf_Path_AppendExpression(sdf_Path_t const* _this, sdf_Path_t* _result);

/// Creates a path by extracting and appending an element
/// from the given ascii element encoding.
/// 
/// Attempting to append a root or empty path (or malformed path)
/// or attempting to append \em to the EmptyPath will raise an
/// error and return the EmptyPath.
/// 
/// May also fail and return EmptyPath if this path's type cannot
/// possess a child of the type encoded in \p element.
int sdf_Path_AppendElementString(sdf_Path_t const* _this, std_String_t const* element, sdf_Path_t* _result);

/// Like AppendElementString() but take the element as a TfToken.
int sdf_Path_AppendElementToken(sdf_Path_t const* _this, tf_Token_t const* elementTok, sdf_Path_t* _result);

/// Returns a path with all occurrences of the prefix path
/// \p oldPrefix replaced with the prefix path \p newPrefix.
/// 
/// If fixTargetPaths is true, any embedded target paths will also
/// have their paths replaced.  This is the default.
/// 
/// If this is not a target, relational attribute or mapper path this
/// will do zero or one path prefix replacements, if not the number of
/// replacements can be greater than one.
int sdf_Path_ReplacePrefix(sdf_Path_t const* _this, sdf_Path_t const* oldPrefix, sdf_Path_t const* newPrefix, bool fixTargetPaths, sdf_Path_t* _result);

/// Returns a path with maximal length that is a prefix path of
/// both this path and \p path.
int sdf_Path_GetCommonPrefix(sdf_Path_t const* _this, sdf_Path_t const* path, sdf_Path_t* _result);

/// Returns the absolute form of this path using \p anchor 
/// as the relative basis.
/// 
/// \p anchor must be an absolute prim path.
/// 
/// If this path is a relative path, resolve it using \p anchor as the
/// relative basis.
/// 
/// If this path is already an absolute path, just return a copy.
int sdf_Path_MakeAbsolutePath(sdf_Path_t const* _this, sdf_Path_t const* anchor, sdf_Path_t* _result);

/// Returns the relative form of this path using \p anchor
/// as the relative basis.
/// 
/// \p anchor must be an absolute prim path.
/// 
/// If this path is an absolute path, return the corresponding relative path
/// that is relative to the absolute path given by \p anchor.
/// 
/// If this path is a relative path, return the optimal relative
/// path to the absolute path given by \p anchor.  (The optimal
/// relative path from a given prim path is the relative path
/// with the least leading dot-dots.
int sdf_Path_MakeRelativePath(sdf_Path_t const* _this, sdf_Path_t const* anchor, sdf_Path_t* _result);

/// The empty path value, equivalent to SdfPath().
int sdf_Path_EmptyPath(sdf_Path_t const** _result);

/// The absolute path representing the top of the
/// namespace hierarchy.
int sdf_Path_AbsoluteRootPath(sdf_Path_t const** _result);

/// The relative path representing "self".
int sdf_Path_ReflexiveRelativePath(sdf_Path_t const** _result);

/// Returns whether \p name is a legal identifier for any
/// path component.
int sdf_Path_IsValidIdentifier(std_String_t const* name, bool* _result);

/// Returns whether \p name is a legal namespaced identifier.
/// This returns \c true if IsValidIdentifier() does.
int sdf_Path_IsValidNamespacedIdentifier(std_String_t const* name, bool* _result);

/// Tokenizes \p name by the namespace delimiter.
/// Returns the empty vector if \p name is not a valid namespaced
/// identifier.
int sdf_Path_TokenizeIdentifier(std_String_t const* name, std_StringVector_t* _result);

/// Tokenizes \p name by the namespace delimiter.
/// Returns the empty vector if \p name is not a valid namespaced
/// identifier.
int sdf_Path_TokenizeIdentifierAsTokens(std_String_t const* name, tf_TokenVector_t* _result);

/// Return true if \p pathString is a valid path string, meaning that
/// passing the string to the \a SdfPath constructor will result in a valid,
/// non-empty SdfPath.  Otherwise, return false and if \p errMsg is not NULL,
/// set the pointed-to string to the parse error.
int sdf_Path_IsValidPathString(std_String_t const* pathString, std_String_t* errMsg, bool* _result);

/// Given some vector of paths, get a vector of concise unambiguous
/// relative paths.
/// 
/// GetConciseRelativePaths requires a vector of absolute paths. It
/// finds a set of relative paths such that each relative path is
/// unique.
int sdf_Path_GetConciseRelativePaths(sdf_PathVector_t const* paths, sdf_PathVector_t* _result);

/// Remove all elements of \a paths that are prefixed by other
/// elements in \a paths.  As a side-effect, the result is left in sorted
/// order.
int sdf_Path_RemoveDescendentPaths(sdf_PathVector_t* paths);

/// Remove all elements of \a paths that prefix other elements in
/// \a paths.  As a side-effect, the result is left in sorted order.
int sdf_Path_RemoveAncestorPaths(sdf_PathVector_t* paths);

int sdf_Path_new(sdf_Path_t** _result);

int sdf_Path_dtor(sdf_Path_t* _this);

/// Return a new expression created by replacing literal path prefixes that
/// start with \p oldPrefix with \p newPrefix.
int sdf_PathExpression_ReplacePrefix(sdf_PathExpression_t const* _this, sdf_Path_t const* oldPrefix, sdf_Path_t const* newPrefix, sdf_PathExpression_t* _result);

/// Return true if all contained pattern prefixes are absolute, false
/// otherwise.  Call MakeAbsolute() to anchor any relative paths and make
/// them absolute.
int sdf_PathExpression_IsAbsolute(sdf_PathExpression_t const* _this, bool* _result);

/// Return a new expression created by making any relative path prefixes in
/// this expression absolute by SdfPath::MakeAbsolutePath().
int sdf_PathExpression_MakeAbsolute(sdf_PathExpression_t const* _this, sdf_Path_t const* anchor, sdf_PathExpression_t* _result);

/// Return true if this expression contains any references to other
/// collections.
int sdf_PathExpression_ContainsExpressionReferences(sdf_PathExpression_t const* _this, bool* _result);

/// Return a new expression created by replacing references to the "weaker
/// expression" (i.e. %_) in this expression with \p weaker.  This is a
/// restricted form of ResolveReferences() that only resolves "weaker"
/// references, replacing them by \p weaker, leaving other references
/// unmodified.
int sdf_PathExpression_ComposeOver(sdf_PathExpression_t const* _this, sdf_PathExpression_t const* weaker, sdf_PathExpression_t* _result);

/// Return true if this expression is considered "complete".  Here, complete
/// means that the expression has all absolute paths, and contains no
/// expression references.  This is equivalent to:
/// 
/// \code
/// !expr.ContainsExpressionReferences() && expr.IsAbsolute()
/// \endcode
/// 
/// To complete an expression, call MakeAbsolute(), ResolveReferences()
/// and/or ComposeOver().
int sdf_PathExpression_IsComplete(sdf_PathExpression_t const* _this, bool* _result);

/// Return a debugging-oriented string representation of this expression.
int sdf_PathExpression_GetDebugString(sdf_PathExpression_t const* _this, std_String_t* _result);

/// Return true if this is the empty expression; i.e. default-constructed or
/// constructed from a string with invalid syntax.
int sdf_PathExpression_IsEmpty(sdf_PathExpression_t const* _this, bool* _result);

/// Return parsing errors as a string if this function was constructed from
/// a string and parse errors were encountered.
int sdf_PathExpression_GetParseError(sdf_PathExpression_t const* _this, std_String_t const** _result);

/// \overload
int sdf_PathExpression_MakeComplement(sdf_PathExpression_t const* right, sdf_PathExpression_t* _result);

int sdf_PathExpression_new(sdf_PathExpression_t** _result);

int sdf_PathExpression_dtor(sdf_PathExpression_t* _this);

int sdf_PathSet_dtor(sdf_PathSet_t* _this);

int sdf_PathVector_data(sdf_PathVector_t* _this, sdf_Path_t** _result);

int sdf_PathVector_data_const(sdf_PathVector_t const* _this, sdf_Path_t const** _result);

int sdf_PathVector_empty(sdf_PathVector_t const* _this, bool* _result);

int sdf_PathVector_size(sdf_PathVector_t const* _this, size_t* _result);

int sdf_PathVector_max_size(sdf_PathVector_t const* _this, size_t* _result);

int sdf_PathVector_reserve(sdf_PathVector_t* _this, size_t const _Newcapacity);

int sdf_PathVector_capacity(sdf_PathVector_t const* _this, size_t* _result);

int sdf_PathVector_clear(sdf_PathVector_t* _this);

int sdf_PathVector_push_back(sdf_PathVector_t* _this, sdf_Path_t const* _Val);

int sdf_PathVector_pop_back(sdf_PathVector_t* _this);

int sdf_PathVector_resize(sdf_PathVector_t* _this, size_t const _Newsize);

int sdf_PathVector_resize_with(sdf_PathVector_t* _this, size_t const _Newsize, sdf_Path_t const* _Val);

int sdf_PathVector_op_index(sdf_PathVector_t const* _this, size_t const _Pos, sdf_Path_t const** _result);

int sdf_PathVector_default(sdf_PathVector_t** _result);

int sdf_PathVector_dtor(sdf_PathVector_t* _this);

/// Returns the asset path of the layer that the payload uses.
int sdf_Payload_GetAssetPath(sdf_Payload_t const* _this, std_String_t const** _result);

/// Sets a new asset path for the layer the payload uses.  See SdfAssetPath
/// for what characters are valid in \p assetPath.  If \p assetPath contains
/// invalid characters, issue an error and set this payload's asset path to
/// the empty asset path.
int sdf_Payload_SetAssetPath(sdf_Payload_t* _this, std_String_t const* assetPath);

/// Returns the scene path of the prim for the payload.
int sdf_Payload_GetPrimPath(sdf_Payload_t const* _this, sdf_Path_t const** _result);

/// Sets a new prim path for the prim that the payload uses.
int sdf_Payload_SetPrimPath(sdf_Payload_t* _this, sdf_Path_t const* primPath);

/// Returns the layer offset associated with the payload.
int sdf_Payload_GetLayerOffset(sdf_Payload_t const* _this, sdf_LayerOffset_t const** _result);

/// Sets a new layer offset.
int sdf_Payload_SetLayerOffset(sdf_Payload_t* _this, sdf_LayerOffset_t const* layerOffset);

/// Returns whether this payload equals \a rhs.
int sdf_Payload_op_eq(sdf_Payload_t const* _this, sdf_Payload_t const* rhs, bool* _result);

/// Returns whether this payload is less than \a rhs.
/// The meaning of less than is arbitrary but stable.
int sdf_Payload_op_lt(sdf_Payload_t const* _this, sdf_Payload_t const* rhs, bool* _result);

int sdf_Payload_new(sdf_Payload_t** _result);

int sdf_Payload_dtor(sdf_Payload_t* _this);

int sdf_PayloadEditorProxy_dtor(sdf_PayloadEditorProxy_t* _this);

int sdf_PayloadVector_dtor(sdf_PayloadVector_t* _this);

/// Returns the prim's namespace pseudo-root prim.
int sdf_PrimSpec_GetNameRoot(sdf_PrimSpec_t const* _this, sdf_PrimSpecHandle_t* _result);

/// Returns the prim's namespace parent.
/// 
/// This does not return the pseudo-root for root prims.  Most
/// algorithms that scan the namespace hierarchy upwards don't
/// want to process the pseudo-root the same way as actual prims.
/// Algorithms that do can always call \c GetRealNameParent().
int sdf_PrimSpec_GetNameParent(sdf_PrimSpec_t const* _this, sdf_PrimSpecHandle_t* _result);

/// Returns the prim's namespace parent.
int sdf_PrimSpec_GetRealNameParent(sdf_PrimSpec_t const* _this, sdf_PrimSpecHandle_t* _result);

/// Returns a keyed vector view of the prim's namespace children.
int sdf_PrimSpec_GetNameChildren(sdf_PrimSpec_t const* _this, sdf_PrimSpecView_t* _result);

/// Updates nameChildren to match the given vector of prims.
int sdf_PrimSpec_SetNameChildren(sdf_PrimSpec_t* _this, sdf_PrimSpecHandleVector_t const* param00);

/// Inserts a child.
/// 
/// \p index is ignored except for range checking;  -1 is permitted.
/// 
/// Returns true if successful, false if failed.
int sdf_PrimSpec_InsertNameChild(sdf_PrimSpec_t* _this, sdf_PrimSpecHandle_t const* child, int index, bool* _result);

/// Removes the child.  Returns true if successful, false if failed.
int sdf_PrimSpec_RemoveNameChild(sdf_PrimSpec_t* _this, sdf_PrimSpecHandle_t const* child, bool* _result);

/// Returns the list of child names for this prim's reorder.
/// nameChildren statement.
/// 
/// See SetNameChildrenOrder() for more info.
int sdf_PrimSpec_GetNameChildrenOrder(sdf_PrimSpec_t const* _this, sdf_NameChildrenOrderProxy_t* _result);

/// Returns true if this prim has name children order specified
int sdf_PrimSpec_HasNameChildrenOrder(sdf_PrimSpec_t const* _this, bool* _result);

/// Given a list of (possibly sparse) child names, authors a reorder
/// nameChildren statement for this prim.
/// 
/// The reorder statement can modify the order of name children
/// during composition.  This order doesn't affect GetNameChildren(),
/// InsertNameChild(), SetNameChildren(), et al.
int sdf_PrimSpec_SetNameChildrenOrder(sdf_PrimSpec_t* _this, tf_TokenVector_t const* names);

/// Adds a new name child \p name in the name children order.
/// If \p index is -1, the name is inserted at the end.
int sdf_PrimSpec_InsertInNameChildrenOrder(sdf_PrimSpec_t* _this, tf_Token_t const* name, int index);

/// Removes a name child name from the name children order.
int sdf_PrimSpec_RemoveFromNameChildrenOrder(sdf_PrimSpec_t* _this, tf_Token_t const* name);

/// Removes a name child name from the name children order by index.
int sdf_PrimSpec_RemoveFromNameChildrenOrderByIndex(sdf_PrimSpec_t* _this, int index);

/// Reorders the given list of child names according to the reorder
/// nameChildren statement for this prim.
/// 
/// This routine employs the standard list editing operation for ordered
/// items in a ListEditor.
int sdf_PrimSpec_ApplyNameChildrenOrder(sdf_PrimSpec_t const* _this, tf_TokenVector_t* vec);

/// Returns the prim's properties.
int sdf_PrimSpec_GetProperties(sdf_PrimSpec_t const* _this, sdf_PropertySpecView_t* _result);

/// Updates properties to match the given vector of properties.
int sdf_PrimSpec_SetProperties(sdf_PrimSpec_t* _this, sdf_PropertySpecHandleVector_t const* param00);

/// Inserts a property.
/// 
/// \p index is ignored except for range checking;  -1 is permitted.
/// 
/// Returns true if successful, false if failed.
int sdf_PrimSpec_InsertProperty(sdf_PrimSpec_t* _this, sdf_PropertySpecHandle_t const* property, int index, bool* _result);

/// Removes the property.
int sdf_PrimSpec_RemoveProperty(sdf_PrimSpec_t* _this, sdf_PropertySpecHandle_t const* property);

/// Returns a view of the attributes of this prim.
int sdf_PrimSpec_GetAttributes(sdf_PrimSpec_t const* _this, sdf_AttributeSpecView_t* _result);

/// Returns a view of the relationships of this prim.
int sdf_PrimSpec_GetRelationships(sdf_PrimSpec_t const* _this, sdf_RelationshipSpecView_t* _result);

/// Returns the list of property names for this prim's reorder
/// properties statement.
/// 
/// See SetPropertyOrder() for more info.
int sdf_PrimSpec_GetPropertyOrder(sdf_PrimSpec_t const* _this, sdf_NameChildrenOrderProxy_t* _result);

/// Returns true if this prim has a property ordering specified.
int sdf_PrimSpec_HasPropertyOrder(sdf_PrimSpec_t const* _this, bool* _result);

/// Given a list of (possibly sparse) property names, authors a
/// reorder properties statement for this prim.
/// 
/// The reorder statement can modify the order of properties during
/// composition.  This order doesn't affect GetProperties(),
/// InsertProperty(), SetProperties(), et al.
int sdf_PrimSpec_SetPropertyOrder(sdf_PrimSpec_t* _this, tf_TokenVector_t const* names);

/// Add a new property \p name in the property order.
/// If \p index is -1, the name is inserted at the end.
int sdf_PrimSpec_InsertInPropertyOrder(sdf_PrimSpec_t* _this, tf_Token_t const* name, int index);

/// Remove a property name from the property order.
int sdf_PrimSpec_RemoveFromPropertyOrder(sdf_PrimSpec_t* _this, tf_Token_t const* name);

/// Remove a property name from the property order by index.
int sdf_PrimSpec_RemoveFromPropertyOrderByIndex(sdf_PrimSpec_t* _this, int index);

/// Reorders the given list of property names according to the
/// reorder properties statement for this prim.
/// 
/// This routine employs the standard list editing operation for ordered
/// items in a ListEditor.
int sdf_PrimSpec_ApplyPropertyOrder(sdf_PrimSpec_t const* _this, tf_TokenVector_t* vec);

/// Returns the object for the given \p path.
/// 
/// If \p path is relative then it will be interpreted as
/// relative to this prim.  If it is absolute then it will be
/// interpreted as absolute in this prim's layer.
/// 
/// Returns invalid handle if there is no object at \p path.
int sdf_PrimSpec_GetObjectAtPath(sdf_PrimSpec_t const* _this, sdf_Path_t const* path, sdf_SpecHandle_t* _result);

/// Returns a prim given its \p path.
/// 
/// Returns invalid handle if there is no prim at \p path.
/// This is simply a more specifically typed version of GetObjectAtPath.
int sdf_PrimSpec_GetPrimAtPath(sdf_PrimSpec_t const* _this, sdf_Path_t const* path, sdf_PrimSpecHandle_t* _result);

/// Returns a property given its \p path.
/// 
/// Returns invalid handle if there is no property at \p path.
/// This is simply a more specifically typed version of GetObjectAtPath.
int sdf_PrimSpec_GetPropertyAtPath(sdf_PrimSpec_t const* _this, sdf_Path_t const* path, sdf_PropertySpecHandle_t* _result);

/// Returns an attribute given its \p path.
/// 
/// Returns invalid handle if there is no attribute at \p path.
/// This is simply a more specifically typed version of GetObjectAtPath.
int sdf_PrimSpec_GetAttributeAtPath(sdf_PrimSpec_t const* _this, sdf_Path_t const* path, sdf_AttributeSpecHandle_t* _result);

/// Returns a relationship given its \p path.
/// 
/// Returns invalid handle if there is no relationship at \p path.
/// This is simply a more specifically typed version of GetObjectAtPath.
int sdf_PrimSpec_GetRelationshipAtPath(sdf_PrimSpec_t const* _this, sdf_Path_t const* path, sdf_RelationshipSpecHandle_t* _result);

/// Returns the typeName of the prim.
/// 
/// The typeName should be meaningful to a higher level
/// prim definition system.
/// 
/// The default value for typeName is the empty token.
int sdf_PrimSpec_GetTypeName(sdf_PrimSpec_t const* _this, tf_Token_t* _result);

/// Sets the typeName of the model prim.
int sdf_PrimSpec_SetTypeName(sdf_PrimSpec_t* _this, std_String_t const* value);

/// Returns the comment string for this prim spec.
/// 
/// The default value for comment is @"".
int sdf_PrimSpec_GetComment(sdf_PrimSpec_t const* _this, std_String_t* _result);

/// Sets the comment string for this prim spec.
int sdf_PrimSpec_SetComment(sdf_PrimSpec_t* _this, std_String_t const* value);

/// Returns the documentation string for this prim spec.
/// 
/// The default value for documentation is @"".
int sdf_PrimSpec_GetDocumentation(sdf_PrimSpec_t const* _this, std_String_t* _result);

/// Sets the documentation string for this prim spec.
int sdf_PrimSpec_SetDocumentation(sdf_PrimSpec_t* _this, std_String_t const* value);

/// Returns whether this prim spec is active.
/// 
/// The default value for active is true.
int sdf_PrimSpec_GetActive(sdf_PrimSpec_t const* _this, bool* _result);

/// Sets whether this prim spec is active.
int sdf_PrimSpec_SetActive(sdf_PrimSpec_t* _this, bool value);

/// Returns true if this prim spec has an opinion about active.
int sdf_PrimSpec_HasActive(sdf_PrimSpec_t const* _this, bool* _result);

/// Removes the active opinion in this prim spec if there is one.
int sdf_PrimSpec_ClearActive(sdf_PrimSpec_t* _this);

/// Returns whether this prim spec will be hidden in browsers.
/// 
/// The default value for hidden is false.
int sdf_PrimSpec_GetHidden(sdf_PrimSpec_t const* _this, bool* _result);

/// Sets whether this prim spec will be hidden in browsers.
int sdf_PrimSpec_SetHidden(sdf_PrimSpec_t* _this, bool value);

/// Returns this prim spec's kind.
/// 
/// The default value for kind is an empty \c TfToken.
int sdf_PrimSpec_GetKind(sdf_PrimSpec_t const* _this, tf_Token_t* _result);

/// Sets this prim spec's kind.
int sdf_PrimSpec_SetKind(sdf_PrimSpec_t* _this, tf_Token_t const* value);

/// Returns true if this prim spec has an opinion about kind.
int sdf_PrimSpec_HasKind(sdf_PrimSpec_t const* _this, bool* _result);

/// Remove the kind opinion from this prim spec if there is one.
int sdf_PrimSpec_ClearKind(sdf_PrimSpec_t* _this);

/// Returns the symmetry function for this prim.
/// 
/// The default value for symmetry function is an empty token.
int sdf_PrimSpec_GetSymmetryFunction(sdf_PrimSpec_t const* _this, tf_Token_t* _result);

/// Sets the symmetry function for this prim.
/// 
/// If \p functionName is an empty token, then this removes any symmetry
/// function for the given prim.
int sdf_PrimSpec_SetSymmetryFunction(sdf_PrimSpec_t* _this, tf_Token_t const* functionName);

/// Returns the symmetric peer for this prim.
/// 
/// The default value for symmetric peer is an empty string.
int sdf_PrimSpec_GetSymmetricPeer(sdf_PrimSpec_t const* _this, std_String_t* _result);

/// Sets a symmetric peer for this prim.
/// 
/// If \p peerName is empty, then this removes the symmetric peer
/// for this prim.
int sdf_PrimSpec_SetSymmetricPeer(sdf_PrimSpec_t* _this, std_String_t const* peerName);

/// Returns the prefix string for this prim spec.
/// 
/// The default value for prefix is "".
int sdf_PrimSpec_GetPrefix(sdf_PrimSpec_t const* _this, std_String_t* _result);

/// Sets the prefix string for this prim spec.
int sdf_PrimSpec_SetPrefix(sdf_PrimSpec_t* _this, std_String_t const* value);

/// Returns the suffix string for this prim spec.
/// 
/// The default value for suffix is "".
int sdf_PrimSpec_GetSuffix(sdf_PrimSpec_t const* _this, std_String_t* _result);

/// Sets the suffix string for this prim spec.
int sdf_PrimSpec_SetSuffix(sdf_PrimSpec_t* _this, std_String_t const* value);

/// Returns the custom data for this prim.
/// 
/// The default value for custom data is an empty dictionary.
/// 
/// Custom data is for use by plugins or other non-tools supplied
/// extensions that need to be able to store data attached to arbitrary
/// scene objects.  Note that if the only objects you want to store data
/// on are prims, using custom attributes is probably a better choice.
/// But if you need to possibly store this data on attributes or
/// relationships or as annotations on reference arcs, then custom data
/// is an appropriate choice.
int sdf_PrimSpec_GetCustomData(sdf_PrimSpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Sets a custom data entry for this prim.
/// 
/// If \p value is empty, then this removes the given custom data entry.
int sdf_PrimSpec_SetCustomData(sdf_PrimSpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Returns the asset info dictionary for this prim.
/// 
/// The default value is an empty dictionary. 
/// 
/// The asset info dictionary is used to annotate prims representing the 
/// root-prims of assets (generally organized as models) with various 
/// data related to asset management. For example, asset name, root layer
/// identifier, asset version etc.
int sdf_PrimSpec_GetAssetInfo(sdf_PrimSpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Sets a asset info entry for this prim.
/// 
/// If \p value is empty, then this removes the given asset info entry.
/// 
/// \sa GetAssetInfo()
int sdf_PrimSpec_SetAssetInfo(sdf_PrimSpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Returns the spec specifier (def, over or class).
int sdf_PrimSpec_GetSpecifier(sdf_PrimSpec_t const* _this, int* _result);

/// Sets the spec specifier (def or over).
int sdf_PrimSpec_SetSpecifier(sdf_PrimSpec_t* _this, int value);

/// Returns the prim's permission restriction.
/// 
/// The default value for permission is SdfPermissionPublic.
int sdf_PrimSpec_GetPermission(sdf_PrimSpec_t const* _this, int* _result);

/// Sets the prim's permission restriction.
int sdf_PrimSpec_SetPermission(sdf_PrimSpec_t* _this, int value);

/// Returns the prefixSubstitutions dictionary for this prim spec.
/// 
/// The default value for prefixSubstitutions is an empty VtDictionary.
int sdf_PrimSpec_GetPrefixSubstitutions(sdf_PrimSpec_t const* _this, vt_Dictionary_t* _result);

/// Sets the \p prefixSubstitutions dictionary for this prim spec.
int sdf_PrimSpec_SetPrefixSubstitutions(sdf_PrimSpec_t* _this, vt_Dictionary_t const* prefixSubstitutions);

/// Returns the suffixSubstitutions dictionary for this prim spec.
/// 
/// The default value for suffixSubstitutions is an empty VtDictionary.
int sdf_PrimSpec_GetSuffixSubstitutions(sdf_PrimSpec_t const* _this, vt_Dictionary_t* _result);

/// Sets the \p suffixSubstitutions dictionary for this prim spec.
int sdf_PrimSpec_SetSuffixSubstitutions(sdf_PrimSpec_t* _this, vt_Dictionary_t const* suffixSubstitutions);

/// Returns the value for the prim's instanceable flag.
int sdf_PrimSpec_GetInstanceable(sdf_PrimSpec_t const* _this, bool* _result);

/// Sets the value for the prim's instanceable flag.
int sdf_PrimSpec_SetInstanceable(sdf_PrimSpec_t* _this, bool instanceable);

/// Returns true if this prim spec has a value authored for its
/// instanceable flag, false otherwise.
int sdf_PrimSpec_HasInstanceable(sdf_PrimSpec_t const* _this, bool* _result);

/// Clears the value for the prim's instanceable flag.
int sdf_PrimSpec_ClearInstanceable(sdf_PrimSpec_t* _this);

/// Returns a proxy for the prim's payloads.
/// 
/// Payloads for this prim may be modified through the proxy.
int sdf_PrimSpec_GetPayloadList(sdf_PrimSpec_t const* _this, sdf_PayloadEditorProxy_t* _result);

/// Returns true if this prim has payloads set.
int sdf_PrimSpec_HasPayloads(sdf_PrimSpec_t const* _this, bool* _result);

/// Clears the payloads for this prim.
int sdf_PrimSpec_ClearPayloadList(sdf_PrimSpec_t* _this);

/// Returns a proxy for the prim's inherit paths.
/// 
/// Inherit paths for this prim may be modified through the proxy.
int sdf_PrimSpec_GetInheritPathList(sdf_PrimSpec_t const* _this, sdf_InheritsProxy_t* _result);

/// Returns true if this prim has inherit paths set.
int sdf_PrimSpec_HasInheritPaths(sdf_PrimSpec_t const* _this, bool* _result);

/// Clears the inherit paths for this prim.
int sdf_PrimSpec_ClearInheritPathList(sdf_PrimSpec_t* _this);

/// Returns a proxy for the prim's specializes paths.
/// 
/// Specializes for this prim may be modified through the proxy.
int sdf_PrimSpec_GetSpecializesList(sdf_PrimSpec_t const* _this, sdf_InheritsProxy_t* _result);

/// Returns true if this prim has specializes set.
int sdf_PrimSpec_HasSpecializes(sdf_PrimSpec_t const* _this, bool* _result);

/// Clears the specializes for this prim.
int sdf_PrimSpec_ClearSpecializesList(sdf_PrimSpec_t* _this);

/// Returns a proxy for the prim's references.
/// 
/// References for this prim may be modified through the proxy.
int sdf_PrimSpec_GetReferenceList(sdf_PrimSpec_t const* _this, sdf_ReferenceEditorProxy_t* _result);

/// Returns true if this prim has references set.
int sdf_PrimSpec_HasReferences(sdf_PrimSpec_t const* _this, bool* _result);

/// Clears the references for this prim.
int sdf_PrimSpec_ClearReferenceList(sdf_PrimSpec_t* _this);

/// Returns a proxy for the prim's variant sets.
/// 
/// Variant sets for this prim may be modified through the proxy.
int sdf_PrimSpec_GetVariantSetNameList(sdf_PrimSpec_t const* _this, sdf_NameEditorProxy_t* _result);

/// Returns true if this prim has variant sets set.
int sdf_PrimSpec_HasVariantSetNames(sdf_PrimSpec_t const* _this, bool* _result);

/// Returns list of variant names for the given variant set.
int sdf_PrimSpec_GetVariantNames(sdf_PrimSpec_t const* _this, std_String_t const* name, std_StringVector_t* _result);

/// Removes the variant set with the given \a name.
/// 
/// Note that the set's name should probably also be removed from
/// the variant set names list.
int sdf_PrimSpec_RemoveVariantSet(sdf_PrimSpec_t* _this, std_String_t const* name);

/// Returns an editable map whose keys are variant set names and
/// whose values are the variants selected for each set.
int sdf_PrimSpec_GetVariantSelections(sdf_PrimSpec_t const* _this, sdf_VariantSelectionProxy_t* _result);

/// Blocks the variant selected for the given variant set by setting
/// the variant selection to empty.
int sdf_PrimSpec_BlockVariantSelection(sdf_PrimSpec_t* _this, std_String_t const* variantSetName);

/// Get an editing proxy for the map of namespace relocations
/// specified on this prim.
/// 
/// The map of namespace relocation paths is editable in-place via
/// this editing proxy.  Individual source-target pairs can be added,
/// removed, or altered using common map operations.
/// 
/// The map is organized as target \c SdfPath indexed by source \c SdfPath.
/// Key and value paths are stored as absolute regardless of how they're
/// added.
int sdf_PrimSpec_GetRelocates(sdf_PrimSpec_t const* _this, sdf_RelocatesMapProxy_t* _result);

/// Set the entire map of namespace relocations specified on this prim.
/// Use the editing proxy for modifying single paths in the map.
int sdf_PrimSpec_SetRelocates(sdf_PrimSpec_t* _this, sdf_RelocatesMap_t const* newMap);

/// Returns true if this prim has any relocates opinion, including
/// that there should be no relocates (i.e. an empty map).  An empty
/// map (no relocates) does not mean the same thing as a missing map
/// (no opinion).
int sdf_PrimSpec_HasRelocates(sdf_PrimSpec_t const* _this, bool* _result);

/// Clears the relocates opinion for this prim.
int sdf_PrimSpec_ClearRelocates(sdf_PrimSpec_t* _this);

/// Create a root prim spec.
/// 
/// Creates a prim spec with a \p name, \p specifier and \p typeName as a
/// root prim in the given layer.
int sdf_PrimSpec_New(sdf_LayerHandle_t const* parentLayer, std_String_t const* name, int spec, std_String_t const* typeName, sdf_PrimSpecHandle_t* _result);

/// Create a prim spec.
/// 
/// Creates a prim spec with a \p name, \p specifier and \p typeName as
/// a namespace child of the given prim.
/// 
/// \sa SdfCreatePrimInLayer() to create a PrimSpec with all required
/// ancestor specs as SdfSpecifierOver.
int sdf_PrimSpec_New_under_parent(sdf_PrimSpecHandle_t const* parentPrim, std_String_t const* name, int spec, std_String_t const* typeName, sdf_PrimSpecHandle_t* _result);

/// Returns true if the given string is a valid prim name.
int sdf_PrimSpec_IsValidName(std_String_t const* name, bool* _result);

/// Returns the prim's name.
int sdf_PrimSpec_GetName(sdf_PrimSpec_t const* _this, std_String_t const** _result);

/// Returns the prim's name, as a token.
int sdf_PrimSpec_GetNameToken(sdf_PrimSpec_t const* _this, tf_Token_t* _result);

/// Returns true if setting the prim spec's name to \p newName will
/// succeed.
/// 
/// Returns false if it won't, and sets \p whyNot with a string
/// describing why not.
int sdf_PrimSpec_CanSetName(sdf_PrimSpec_t const* _this, std_String_t const* newName, std_String_t* whyNot, bool* _result);

/// Sets the prim's name.
/// 
/// Children prims must be unique by name. It is an error to
/// set the name to the same name as an existing child of this
/// prim's parent.
/// 
/// Setting validate to false, will skip validation of the \p newName
/// (that is, CanSetName will not be called).
/// 
/// Returns true if successful, false otherwise.
int sdf_PrimSpec_SetName(sdf_PrimSpec_t* _this, std_String_t const* newName, bool validate, bool* _result);

/// Returns the SdfSchemaBase for the layer that owns this spec.
int sdf_PrimSpec_GetSchema(sdf_PrimSpec_t const* _this, sdf_SchemaBase_t const** _result);

/// Returns the SdfSpecType specifying the spec type this object
/// represents.
int sdf_PrimSpec_GetSpecType(sdf_PrimSpec_t const* _this, int* _result);

/// Returns true if this object is invalid or expired.
int sdf_PrimSpec_IsDormant(sdf_PrimSpec_t const* _this, bool* _result);

/// Returns the layer that this object belongs to.
int sdf_PrimSpec_GetLayer(sdf_PrimSpec_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the scene path of this object.
int sdf_PrimSpec_GetPath(sdf_PrimSpec_t const* _this, sdf_Path_t* _result);

/// Returns whether this object's layer can be edited.
int sdf_PrimSpec_PermissionToEdit(sdf_PrimSpec_t const* _this, bool* _result);

/// Returns the full list of info keys currently set on this object.
/// \note This does not include fields that represent names of children.
int sdf_PrimSpec_ListInfoKeys(sdf_PrimSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns the list of metadata info keys for this object.
/// 
/// This is not the complete list of keys, it is only those that
/// should be considered to be metadata by inspectors or other 
/// presentation UI.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PrimSpec_GetMetaDataInfoKeys(sdf_PrimSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns this metadata key's displayGroup.
int sdf_PrimSpec_GetMetaDataDisplayGroup(sdf_PrimSpec_t const* _this, tf_Token_t const* key, tf_Token_t* _result);

/// Gets the value for the given metadata key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PrimSpec_GetInfo(sdf_PrimSpec_t const* _this, tf_Token_t const* key, vt_Value_t* _result);

/// Sets the value for the given metadata key.
/// 
/// It is an error to pass a value that is not the correct type for
/// that given key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PrimSpec_SetInfo(sdf_PrimSpec_t* _this, tf_Token_t const* key, vt_Value_t const* value);

/// Sets the value for \p entryKey to \p value within the dictionary 
///        with the given metadata key \p dictionaryKey
int sdf_PrimSpec_SetInfoDictionaryValue(sdf_PrimSpec_t* _this, tf_Token_t const* dictionaryKey, tf_Token_t const* entryKey, vt_Value_t const* value);

/// Returns whether there is a setting for the scene spec info 
/// with the given key.
/// 
/// When asked for a value for one of its scene spec info, a valid value
/// will always be returned. But if this API returns \b false for a scene
/// spec info, the value of that info will be the defined default value.
/// 
/// When dealing with a composedLayer, it is not necessary to worry about
/// whether a scene spec info "has a value" because the composed layer will
/// always have a valid value, even if it is the default.
/// 
/// A spec may or may not have an expressed value for some of its
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PrimSpec_HasInfo(sdf_PrimSpec_t const* _this, tf_Token_t const* key, bool* _result);

/// Clears the value for scene spec info with the given \a key.
/// 
/// After calling this, HasInfo() will return \b false.
/// To make HasInfo() return \b true just set a value for that
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PrimSpec_ClearInfo(sdf_PrimSpec_t* _this, tf_Token_t const* key);

/// Returns the data type for the info with the given \a key.
int sdf_PrimSpec_GetTypeForInfo(sdf_PrimSpec_t const* _this, tf_Token_t const* key, tf_Type_t* _result);

/// Returns the fallback for the info with the given \a key.
int sdf_PrimSpec_GetFallbackForInfo(sdf_PrimSpec_t const* _this, tf_Token_t const* key, vt_Value_t const** _result);

/// Returns whether this object has no significant data.
/// 
/// "Significant" here means that the object contributes opinions to
/// a scene. If this spec has any child scenegraph objects (e.g.,
/// prim or property spec), it will be considered significant even if
/// those child objects are not.
/// However, if \p ignoreChildren is \c true, these child objects
/// will be ignored. 
int sdf_PrimSpec_IsInert(sdf_PrimSpec_t const* _this, bool ignoreChildren, bool* _result);

/// Returns all fields with values.
int sdf_PrimSpec_ListFields(sdf_PrimSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns \c true if the spec has a non-empty value with field
/// name \p name.
int sdf_PrimSpec_HasField(sdf_PrimSpec_t const* _this, tf_Token_t const* name, bool* _result);

/// Returns a field value by name.
int sdf_PrimSpec_GetField(sdf_PrimSpec_t const* _this, tf_Token_t const* name, vt_Value_t* _result);

/// Sets a field value as a boxed VtValue.
int sdf_PrimSpec_SetField(sdf_PrimSpec_t* _this, tf_Token_t const* name, vt_Value_t const* value, bool* _result);

/// \name Comparison operators
/// @{
int sdf_PrimSpec_op_eq(sdf_PrimSpec_t const* _this, sdf_Spec_t const* rhs, bool* _result);

int sdf_PrimSpec_dtor(sdf_PrimSpec_t* _this);

int sdf_PrimSpecHandle_dtor(sdf_PrimSpecHandle_t* _this);

int sdf_PrimSpecHandleVector_data(sdf_PrimSpecHandleVector_t* _this, sdf_PrimSpecHandle_t** _result);

int sdf_PrimSpecHandleVector_data_const(sdf_PrimSpecHandleVector_t const* _this, sdf_PrimSpecHandle_t const** _result);

int sdf_PrimSpecHandleVector_empty(sdf_PrimSpecHandleVector_t const* _this, bool* _result);

int sdf_PrimSpecHandleVector_size(sdf_PrimSpecHandleVector_t const* _this, size_t* _result);

int sdf_PrimSpecHandleVector_max_size(sdf_PrimSpecHandleVector_t const* _this, size_t* _result);

int sdf_PrimSpecHandleVector_reserve(sdf_PrimSpecHandleVector_t* _this, size_t const _Newcapacity);

int sdf_PrimSpecHandleVector_capacity(sdf_PrimSpecHandleVector_t const* _this, size_t* _result);

int sdf_PrimSpecHandleVector_clear(sdf_PrimSpecHandleVector_t* _this);

int sdf_PrimSpecHandleVector_push_back(sdf_PrimSpecHandleVector_t* _this, sdf_PrimSpecHandle_t const* _Val);

int sdf_PrimSpecHandleVector_pop_back(sdf_PrimSpecHandleVector_t* _this);

int sdf_PrimSpecHandleVector_resize(sdf_PrimSpecHandleVector_t* _this, size_t const _Newsize);

int sdf_PrimSpecHandleVector_resize_with(sdf_PrimSpecHandleVector_t* _this, size_t const _Newsize, sdf_PrimSpecHandle_t const* _Val);

int sdf_PrimSpecHandleVector_op_index(sdf_PrimSpecHandleVector_t const* _this, size_t const _Pos, sdf_PrimSpecHandle_t const** _result);

int sdf_PrimSpecHandleVector_default(sdf_PrimSpecHandleVector_t** _result);

int sdf_PrimSpecHandleVector_dtor(sdf_PrimSpecHandleVector_t* _this);

int sdf_PrimSpecHandleOffsetPair_dtor(sdf_PrimSpecHandleOffsetPair_t* _this);

int sdf_PrimSpecHandleOffsetPairVector_data(sdf_PrimSpecHandleOffsetPairVector_t* _this, sdf_PrimSpecHandleOffsetPair_t** _result);

int sdf_PrimSpecHandleOffsetPairVector_data_const(sdf_PrimSpecHandleOffsetPairVector_t const* _this, sdf_PrimSpecHandleOffsetPair_t const** _result);

int sdf_PrimSpecHandleOffsetPairVector_empty(sdf_PrimSpecHandleOffsetPairVector_t const* _this, bool* _result);

int sdf_PrimSpecHandleOffsetPairVector_size(sdf_PrimSpecHandleOffsetPairVector_t const* _this, size_t* _result);

int sdf_PrimSpecHandleOffsetPairVector_max_size(sdf_PrimSpecHandleOffsetPairVector_t const* _this, size_t* _result);

int sdf_PrimSpecHandleOffsetPairVector_reserve(sdf_PrimSpecHandleOffsetPairVector_t* _this, size_t const _Newcapacity);

int sdf_PrimSpecHandleOffsetPairVector_capacity(sdf_PrimSpecHandleOffsetPairVector_t const* _this, size_t* _result);

int sdf_PrimSpecHandleOffsetPairVector_clear(sdf_PrimSpecHandleOffsetPairVector_t* _this);

int sdf_PrimSpecHandleOffsetPairVector_push_back(sdf_PrimSpecHandleOffsetPairVector_t* _this, sdf_PrimSpecHandleOffsetPair_t const* _Val);

int sdf_PrimSpecHandleOffsetPairVector_pop_back(sdf_PrimSpecHandleOffsetPairVector_t* _this);

int sdf_PrimSpecHandleOffsetPairVector_resize(sdf_PrimSpecHandleOffsetPairVector_t* _this, size_t const _Newsize);

int sdf_PrimSpecHandleOffsetPairVector_resize_with(sdf_PrimSpecHandleOffsetPairVector_t* _this, size_t const _Newsize, sdf_PrimSpecHandleOffsetPair_t const* _Val);

int sdf_PrimSpecHandleOffsetPairVector_op_index(sdf_PrimSpecHandleOffsetPairVector_t const* _this, size_t const _Pos, sdf_PrimSpecHandleOffsetPair_t const** _result);

int sdf_PrimSpecHandleOffsetPairVector_default(sdf_PrimSpecHandleOffsetPairVector_t** _result);

int sdf_PrimSpecHandleOffsetPairVector_dtor(sdf_PrimSpecHandleOffsetPairVector_t* _this);

int sdf_PrimSpecView_dtor(sdf_PrimSpecView_t* _this);

/// Returns the owner prim or relationship of this property.
int sdf_PropertySpec_GetOwner(sdf_PropertySpec_t const* _this, sdf_SpecHandle_t* _result);

/// Returns the property's custom data.
/// 
/// The default value for custom data is an empty dictionary.
/// 
/// Custom data is for use by plugins or other non-tools supplied
/// extensions that need to be able to store data attached to arbitrary
/// scene objects.  Note that if the only objects you want to store data
/// on are prims, using custom attributes is probably a better choice.
/// But if you need to possibly store this data on attributes or
/// relationships or as annotations on reference arcs, then custom data
/// is an appropriate choice.
int sdf_PropertySpec_GetCustomData(sdf_PropertySpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Returns the asset info dictionary for this property.
/// 
/// The default value is an empty dictionary. 
/// 
/// The asset info dictionary is used to annotate SdfAssetPath-valued 
/// attributes pointing to the root-prims of assets (generally organized 
/// as models) with various data related to asset management. For example, 
/// asset name, root layer identifier, asset version etc.
/// 
/// \note It is only valid to author assetInfo on attributes that are of 
/// type SdfAssetPath.
int sdf_PropertySpec_GetAssetInfo(sdf_PropertySpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Sets a property custom data entry.
/// 
/// If \p value is empty, then this removes the given custom data entry.
int sdf_PropertySpec_SetCustomData(sdf_PropertySpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Sets a asset info entry for this property.
/// 
/// If \p value is empty, then this removes the given asset info entry.
/// 
/// \sa GetAssetInfo()
int sdf_PropertySpec_SetAssetInfo(sdf_PropertySpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Returns the displayGroup string for this property spec.
/// 
/// The default value for displayGroup is empty string.
int sdf_PropertySpec_GetDisplayGroup(sdf_PropertySpec_t const* _this, std_String_t* _result);

/// Sets the displayGroup string for this property spec.
int sdf_PropertySpec_SetDisplayGroup(sdf_PropertySpec_t* _this, std_String_t const* value);

/// Returns the displayName string for this property spec.
/// 
/// The default value for displayName is empty string.
int sdf_PropertySpec_GetDisplayName(sdf_PropertySpec_t const* _this, std_String_t* _result);

/// Sets the displayName string for this property spec.
int sdf_PropertySpec_SetDisplayName(sdf_PropertySpec_t* _this, std_String_t const* value);

/// Returns the documentation string for this property spec.
/// 
/// The default value for documentation is empty string.
int sdf_PropertySpec_GetDocumentation(sdf_PropertySpec_t const* _this, std_String_t* _result);

/// Sets the documentation string for this property spec.
int sdf_PropertySpec_SetDocumentation(sdf_PropertySpec_t* _this, std_String_t const* value);

/// Returns whether this property spec will be hidden in browsers.
/// 
/// The default value for hidden is false.
int sdf_PropertySpec_GetHidden(sdf_PropertySpec_t const* _this, bool* _result);

/// Sets whether this property spec will be hidden in browsers.
int sdf_PropertySpec_SetHidden(sdf_PropertySpec_t* _this, bool value);

/// Returns the property's permission restriction.
/// 
/// The default value for permission is SdfPermissionPublic.
int sdf_PropertySpec_GetPermission(sdf_PropertySpec_t const* _this, int* _result);

/// Sets the property's permission restriction.
int sdf_PropertySpec_SetPermission(sdf_PropertySpec_t* _this, int value);

/// Returns the prefix string for this property spec.
/// 
/// The default value for prefix is "".
int sdf_PropertySpec_GetPrefix(sdf_PropertySpec_t const* _this, std_String_t* _result);

/// Sets the prefix string for this property spec.
int sdf_PropertySpec_SetPrefix(sdf_PropertySpec_t* _this, std_String_t const* value);

/// Returns the suffix string for this property spec.
/// 
/// The default value for suffix is "".
int sdf_PropertySpec_GetSuffix(sdf_PropertySpec_t const* _this, std_String_t* _result);

/// Sets the suffix string for this property spec.
int sdf_PropertySpec_SetSuffix(sdf_PropertySpec_t* _this, std_String_t const* value);

/// Returns the property's symmetric peer.
/// 
/// The default value for the symmetric peer is an empty string.
int sdf_PropertySpec_GetSymmetricPeer(sdf_PropertySpec_t const* _this, std_String_t* _result);

/// Sets the property's symmetric peer.
/// 
/// If \p peerName is empty, then this removes any symmetric peer for the
/// given property.
int sdf_PropertySpec_SetSymmetricPeer(sdf_PropertySpec_t* _this, std_String_t const* peerName);

/// Returns the property's symmetry arguments.
/// 
/// The default value for symmetry arguments is an empty dictionary.
int sdf_PropertySpec_GetSymmetryArguments(sdf_PropertySpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Sets a property symmetry argument.
/// 
/// If \p value is empty, then this removes the argument with the given
/// \p name.
int sdf_PropertySpec_SetSymmetryArgument(sdf_PropertySpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Returns the property's symmetry function.
/// 
/// The default value for the symmetry function is an empty token.
int sdf_PropertySpec_GetSymmetryFunction(sdf_PropertySpec_t const* _this, tf_Token_t* _result);

/// Sets the property's symmetry function.
/// 
/// If \p functionName is empty, then this removes any symmetry function
/// for the given property.
int sdf_PropertySpec_SetSymmetryFunction(sdf_PropertySpec_t* _this, tf_Token_t const* functionName);

/// Returns the entire set of time samples.
int sdf_PropertySpec_GetTimeSampleMap(sdf_PropertySpec_t const* _this, sdf_TimeSampleMap_t* _result);

/// Returns the TfType representing the value type this property holds.
int sdf_PropertySpec_GetValueType(sdf_PropertySpec_t const* _this, tf_Type_t* _result);

/// Returns the name of the value type that this property holds.
/// 
/// Returns the typename used to represent the types of value held by
/// this attribute.
int sdf_PropertySpec_GetTypeName(sdf_PropertySpec_t const* _this, sdf_ValueTypeName_t* _result);

/// Returns the attribute's default value.
/// 
/// If it doesn't have a default value, an empty VtValue is returned.
int sdf_PropertySpec_GetDefaultValue(sdf_PropertySpec_t const* _this, vt_Value_t* _result);

/// Sets the attribute's default value.
/// 
/// Returns true if successful, false otherwise.  Fails if \p defaultValue
/// has wrong type.
int sdf_PropertySpec_SetDefaultValue(sdf_PropertySpec_t* _this, vt_Value_t const* defaultValue, bool* _result);

/// Returns true if a default value is set for this attribute.
int sdf_PropertySpec_HasDefaultValue(sdf_PropertySpec_t const* _this, bool* _result);

/// Clear the attribute's default value.
int sdf_PropertySpec_ClearDefaultValue(sdf_PropertySpec_t* _this);

/// Returns the comment string for this property spec.
/// 
/// The default value for comment is "".
int sdf_PropertySpec_GetComment(sdf_PropertySpec_t const* _this, std_String_t* _result);

/// Sets the comment string for this property spec.
int sdf_PropertySpec_SetComment(sdf_PropertySpec_t* _this, std_String_t const* value);

/// Returns true if this spec declares a custom property
int sdf_PropertySpec_IsCustom(sdf_PropertySpec_t const* _this, bool* _result);

/// Sets whether this spec declares a custom property
int sdf_PropertySpec_SetCustom(sdf_PropertySpec_t* _this, bool custom);

/// Returns the variability of the property.
/// 
/// An attribute's variability may be \c Varying (the default),
/// \c Uniform, \c Config, or \c Computed.
/// 
/// A relationship's variability may be \c Varying or \c Uniform (the
/// default)
/// 
/// <ul>
///     <li>\c Varying attributes may be directly authored, animated and
///         affected by \p Actions.  They are the most flexible.
///         Varying relationships can have a default and an anim spline,
///         in addition to a list of targets.
/// 
///     <li>\c Uniform attributes may be authored only with non-animated
///         values (default values).  They cannot be affected by \p Actions,
///         but they can be connected to other Uniform attributes.
///         Uniform relationships have a list of targets but do not have
///         default or anim spline values.
/// 
///     <li>\c Config attributes are the same as Uniform except that a Prim
///         can choose to alter its collection of built-in properties based
///         on the values of its Config attributes.
/// 
///     <li>\c Computed attributes may not be authored in scene description.
///         Prims determine the values of their Computed attributes through
///         Prim-specific computation.  They may not be connected.
/// </ul>
int sdf_PropertySpec_GetVariability(sdf_PropertySpec_t const* _this, int* _result);

/// Returns true if this PropertySpec has no significant data other than
/// just what is necessary for instantiation.
/// 
/// For example, "double foo" has only required fields, but "double foo = 3"
/// has more than just what is required.
/// 
/// This is similar to IsInert except that IsInert will always return false 
/// even for properties that have only required fields; PropertySpecs are 
/// never considered inert because even a spec with only required fields 
/// will cause instantiation of on-demand properties.
int sdf_PropertySpec_HasOnlyRequiredFields(sdf_PropertySpec_t const* _this, bool* _result);

/// Returns the property's name.
int sdf_PropertySpec_GetName(sdf_PropertySpec_t const* _this, std_String_t const** _result);

/// Returns the property's name, as a token.
int sdf_PropertySpec_GetNameToken(sdf_PropertySpec_t const* _this, tf_Token_t* _result);

/// Returns true if setting the property spec's name to \p newName
/// will succeed.
/// 
/// Returns false if it won't, and sets \p whyNot with a string
/// describing why not.
int sdf_PropertySpec_CanSetName(sdf_PropertySpec_t const* _this, std_String_t const* newName, std_String_t* whyNot, bool* _result);

/// Sets the property's name.
/// 
/// A Prim's properties must be unique by name. Setting the
/// name to the same name as an existing property is an error.
/// 
/// Setting \p validate to false, will skip validation of the newName
/// (that is, CanSetName will not be called).
int sdf_PropertySpec_SetName(sdf_PropertySpec_t* _this, std_String_t const* newName, bool validate, bool* _result);

/// Returns true if the given name is considered a valid name for a
/// property.  A valid name is not empty, and does not use invalid
/// characters (such as '/', '[', or '.').
int sdf_PropertySpec_IsValidName(std_String_t const* name, bool* _result);

/// Returns the SdfSchemaBase for the layer that owns this spec.
int sdf_PropertySpec_GetSchema(sdf_PropertySpec_t const* _this, sdf_SchemaBase_t const** _result);

/// Returns the SdfSpecType specifying the spec type this object
/// represents.
int sdf_PropertySpec_GetSpecType(sdf_PropertySpec_t const* _this, int* _result);

/// Returns true if this object is invalid or expired.
int sdf_PropertySpec_IsDormant(sdf_PropertySpec_t const* _this, bool* _result);

/// Returns the layer that this object belongs to.
int sdf_PropertySpec_GetLayer(sdf_PropertySpec_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the scene path of this object.
int sdf_PropertySpec_GetPath(sdf_PropertySpec_t const* _this, sdf_Path_t* _result);

/// Returns whether this object's layer can be edited.
int sdf_PropertySpec_PermissionToEdit(sdf_PropertySpec_t const* _this, bool* _result);

/// Returns the full list of info keys currently set on this object.
/// \note This does not include fields that represent names of children.
int sdf_PropertySpec_ListInfoKeys(sdf_PropertySpec_t const* _this, tf_TokenVector_t* _result);

/// Returns the list of metadata info keys for this object.
/// 
/// This is not the complete list of keys, it is only those that
/// should be considered to be metadata by inspectors or other 
/// presentation UI.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PropertySpec_GetMetaDataInfoKeys(sdf_PropertySpec_t const* _this, tf_TokenVector_t* _result);

/// Returns this metadata key's displayGroup.
int sdf_PropertySpec_GetMetaDataDisplayGroup(sdf_PropertySpec_t const* _this, tf_Token_t const* key, tf_Token_t* _result);

/// Gets the value for the given metadata key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PropertySpec_GetInfo(sdf_PropertySpec_t const* _this, tf_Token_t const* key, vt_Value_t* _result);

/// Sets the value for the given metadata key.
/// 
/// It is an error to pass a value that is not the correct type for
/// that given key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PropertySpec_SetInfo(sdf_PropertySpec_t* _this, tf_Token_t const* key, vt_Value_t const* value);

/// Sets the value for \p entryKey to \p value within the dictionary 
///        with the given metadata key \p dictionaryKey
int sdf_PropertySpec_SetInfoDictionaryValue(sdf_PropertySpec_t* _this, tf_Token_t const* dictionaryKey, tf_Token_t const* entryKey, vt_Value_t const* value);

/// Returns whether there is a setting for the scene spec info 
/// with the given key.
/// 
/// When asked for a value for one of its scene spec info, a valid value
/// will always be returned. But if this API returns \b false for a scene
/// spec info, the value of that info will be the defined default value.
/// 
/// When dealing with a composedLayer, it is not necessary to worry about
/// whether a scene spec info "has a value" because the composed layer will
/// always have a valid value, even if it is the default.
/// 
/// A spec may or may not have an expressed value for some of its
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PropertySpec_HasInfo(sdf_PropertySpec_t const* _this, tf_Token_t const* key, bool* _result);

/// Clears the value for scene spec info with the given \a key.
/// 
/// After calling this, HasInfo() will return \b false.
/// To make HasInfo() return \b true just set a value for that
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_PropertySpec_ClearInfo(sdf_PropertySpec_t* _this, tf_Token_t const* key);

/// Returns the data type for the info with the given \a key.
int sdf_PropertySpec_GetTypeForInfo(sdf_PropertySpec_t const* _this, tf_Token_t const* key, tf_Type_t* _result);

/// Returns the fallback for the info with the given \a key.
int sdf_PropertySpec_GetFallbackForInfo(sdf_PropertySpec_t const* _this, tf_Token_t const* key, vt_Value_t const** _result);

/// Returns whether this object has no significant data.
/// 
/// "Significant" here means that the object contributes opinions to
/// a scene. If this spec has any child scenegraph objects (e.g.,
/// prim or property spec), it will be considered significant even if
/// those child objects are not.
/// However, if \p ignoreChildren is \c true, these child objects
/// will be ignored. 
int sdf_PropertySpec_IsInert(sdf_PropertySpec_t const* _this, bool ignoreChildren, bool* _result);

/// Returns all fields with values.
int sdf_PropertySpec_ListFields(sdf_PropertySpec_t const* _this, tf_TokenVector_t* _result);

/// Returns \c true if the spec has a non-empty value with field
/// name \p name.
int sdf_PropertySpec_HasField(sdf_PropertySpec_t const* _this, tf_Token_t const* name, bool* _result);

/// Returns a field value by name.
int sdf_PropertySpec_GetField(sdf_PropertySpec_t const* _this, tf_Token_t const* name, vt_Value_t* _result);

/// Sets a field value as a boxed VtValue.
int sdf_PropertySpec_SetField(sdf_PropertySpec_t* _this, tf_Token_t const* name, vt_Value_t const* value, bool* _result);

/// \name Comparison operators
/// @{
int sdf_PropertySpec_op_eq(sdf_PropertySpec_t const* _this, sdf_Spec_t const* rhs, bool* _result);

int sdf_PropertySpec_dtor(sdf_PropertySpec_t* _this);

int sdf_PropertySpecHandle_dtor(sdf_PropertySpecHandle_t* _this);

int sdf_PropertySpecHandleVector_data(sdf_PropertySpecHandleVector_t* _this, sdf_PropertySpecHandle_t** _result);

int sdf_PropertySpecHandleVector_data_const(sdf_PropertySpecHandleVector_t const* _this, sdf_PropertySpecHandle_t const** _result);

int sdf_PropertySpecHandleVector_empty(sdf_PropertySpecHandleVector_t const* _this, bool* _result);

int sdf_PropertySpecHandleVector_size(sdf_PropertySpecHandleVector_t const* _this, size_t* _result);

int sdf_PropertySpecHandleVector_max_size(sdf_PropertySpecHandleVector_t const* _this, size_t* _result);

int sdf_PropertySpecHandleVector_reserve(sdf_PropertySpecHandleVector_t* _this, size_t const _Newcapacity);

int sdf_PropertySpecHandleVector_capacity(sdf_PropertySpecHandleVector_t const* _this, size_t* _result);

int sdf_PropertySpecHandleVector_clear(sdf_PropertySpecHandleVector_t* _this);

int sdf_PropertySpecHandleVector_push_back(sdf_PropertySpecHandleVector_t* _this, sdf_PropertySpecHandle_t const* _Val);

int sdf_PropertySpecHandleVector_pop_back(sdf_PropertySpecHandleVector_t* _this);

int sdf_PropertySpecHandleVector_resize(sdf_PropertySpecHandleVector_t* _this, size_t const _Newsize);

int sdf_PropertySpecHandleVector_resize_with(sdf_PropertySpecHandleVector_t* _this, size_t const _Newsize, sdf_PropertySpecHandle_t const* _Val);

int sdf_PropertySpecHandleVector_op_index(sdf_PropertySpecHandleVector_t const* _this, size_t const _Pos, sdf_PropertySpecHandle_t const** _result);

int sdf_PropertySpecHandleVector_default(sdf_PropertySpecHandleVector_t** _result);

int sdf_PropertySpecHandleVector_dtor(sdf_PropertySpecHandleVector_t* _this);

int sdf_PropertySpecHandleOffsetPair_dtor(sdf_PropertySpecHandleOffsetPair_t* _this);

int sdf_PropertySpecHandleOffsetPairVector_data(sdf_PropertySpecHandleOffsetPairVector_t* _this, sdf_PropertySpecHandleOffsetPair_t** _result);

int sdf_PropertySpecHandleOffsetPairVector_data_const(sdf_PropertySpecHandleOffsetPairVector_t const* _this, sdf_PropertySpecHandleOffsetPair_t const** _result);

int sdf_PropertySpecHandleOffsetPairVector_empty(sdf_PropertySpecHandleOffsetPairVector_t const* _this, bool* _result);

int sdf_PropertySpecHandleOffsetPairVector_size(sdf_PropertySpecHandleOffsetPairVector_t const* _this, size_t* _result);

int sdf_PropertySpecHandleOffsetPairVector_max_size(sdf_PropertySpecHandleOffsetPairVector_t const* _this, size_t* _result);

int sdf_PropertySpecHandleOffsetPairVector_reserve(sdf_PropertySpecHandleOffsetPairVector_t* _this, size_t const _Newcapacity);

int sdf_PropertySpecHandleOffsetPairVector_capacity(sdf_PropertySpecHandleOffsetPairVector_t const* _this, size_t* _result);

int sdf_PropertySpecHandleOffsetPairVector_clear(sdf_PropertySpecHandleOffsetPairVector_t* _this);

int sdf_PropertySpecHandleOffsetPairVector_push_back(sdf_PropertySpecHandleOffsetPairVector_t* _this, sdf_PropertySpecHandleOffsetPair_t const* _Val);

int sdf_PropertySpecHandleOffsetPairVector_pop_back(sdf_PropertySpecHandleOffsetPairVector_t* _this);

int sdf_PropertySpecHandleOffsetPairVector_resize(sdf_PropertySpecHandleOffsetPairVector_t* _this, size_t const _Newsize);

int sdf_PropertySpecHandleOffsetPairVector_resize_with(sdf_PropertySpecHandleOffsetPairVector_t* _this, size_t const _Newsize, sdf_PropertySpecHandleOffsetPair_t const* _Val);

int sdf_PropertySpecHandleOffsetPairVector_op_index(sdf_PropertySpecHandleOffsetPairVector_t const* _this, size_t const _Pos, sdf_PropertySpecHandleOffsetPair_t const** _result);

int sdf_PropertySpecHandleOffsetPairVector_default(sdf_PropertySpecHandleOffsetPairVector_t** _result);

int sdf_PropertySpecHandleOffsetPairVector_dtor(sdf_PropertySpecHandleOffsetPairVector_t* _this);

int sdf_PropertySpecView_dtor(sdf_PropertySpecView_t* _this);

/// Returns the asset path to the root layer of the referenced layer
/// stack.  This will be empty in the case of an internal reference.
int sdf_Reference_GetAssetPath(sdf_Reference_t const* _this, std_String_t const** _result);

/// Sets the asset path for the root layer of the referenced layer stack.
/// This may be set to an empty string to specify an internal reference.
/// See SdfAssetPath for what characters are valid in \p assetPath.  If \p
/// assetPath contains invalid characters, issue an error and set this
/// reference's asset path to the empty asset path.
int sdf_Reference_SetAssetPath(sdf_Reference_t* _this, std_String_t const* assetPath);

/// Returns the path of the referenced prim.
/// This will be empty if the referenced prim is the default prim specified
/// in the referenced layer stack.
int sdf_Reference_GetPrimPath(sdf_Reference_t const* _this, sdf_Path_t const** _result);

/// Sets the path of the referenced prim.
/// This may be set to an empty path to specify a reference to the default
/// prim in the referenced layer stack.
int sdf_Reference_SetPrimPath(sdf_Reference_t* _this, sdf_Path_t const* primPath);

/// Returns the layer offset associated with the reference.
int sdf_Reference_GetLayerOffset(sdf_Reference_t const* _this, sdf_LayerOffset_t const** _result);

/// Sets a new layer offset.
int sdf_Reference_SetLayerOffset(sdf_Reference_t* _this, sdf_LayerOffset_t const* layerOffset);

/// Returns the custom data associated with the reference.
int sdf_Reference_GetCustomData(sdf_Reference_t const* _this, vt_Dictionary_t const** _result);

/// Sets the custom data associated with the reference.
int sdf_Reference_SetCustomData(sdf_Reference_t* _this, vt_Dictionary_t const* customData);

/// Sets a custom data entry for the reference.
/// 
/// If \a value is empty, then this removes the given custom data entry.
int sdf_Reference_SetCustomData_value(sdf_Reference_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Swaps the custom data dictionary for this reference.
int sdf_Reference_SwapCustomData(sdf_Reference_t* _this, vt_Dictionary_t* customData);

/// Returns \c true in the case of an internal reference.
/// 
/// An internal reference is a reference with an empty asset path.
int sdf_Reference_IsInternal(sdf_Reference_t const* _this, bool* _result);

/// Returns whether this reference equals \a rhs.
int sdf_Reference_op_eq(sdf_Reference_t const* _this, sdf_Reference_t const* rhs, bool* _result);

/// Returns whether this reference is less than \a rhs.  The meaning
/// of less than is somewhat arbitrary.
int sdf_Reference_op_lt(sdf_Reference_t const* _this, sdf_Reference_t const* rhs, bool* _result);

int sdf_Reference_dtor(sdf_Reference_t* _this);

int sdf_ReferenceEditorProxy_dtor(sdf_ReferenceEditorProxy_t* _this);

int sdf_ReferenceVector_data(sdf_ReferenceVector_t* _this, sdf_Reference_t** _result);

int sdf_ReferenceVector_data_const(sdf_ReferenceVector_t const* _this, sdf_Reference_t const** _result);

int sdf_ReferenceVector_empty(sdf_ReferenceVector_t const* _this, bool* _result);

int sdf_ReferenceVector_size(sdf_ReferenceVector_t const* _this, size_t* _result);

int sdf_ReferenceVector_max_size(sdf_ReferenceVector_t const* _this, size_t* _result);

int sdf_ReferenceVector_reserve(sdf_ReferenceVector_t* _this, size_t const _Newcapacity);

int sdf_ReferenceVector_capacity(sdf_ReferenceVector_t const* _this, size_t* _result);

int sdf_ReferenceVector_clear(sdf_ReferenceVector_t* _this);

int sdf_ReferenceVector_push_back(sdf_ReferenceVector_t* _this, sdf_Reference_t const* _Val);

int sdf_ReferenceVector_pop_back(sdf_ReferenceVector_t* _this);

int sdf_ReferenceVector_resize(sdf_ReferenceVector_t* _this, size_t const _Newsize);

int sdf_ReferenceVector_resize_with(sdf_ReferenceVector_t* _this, size_t const _Newsize, sdf_Reference_t const* _Val);

int sdf_ReferenceVector_op_index(sdf_ReferenceVector_t const* _this, size_t const _Pos, sdf_Reference_t const** _result);

int sdf_ReferenceVector_default(sdf_ReferenceVector_t** _result);

int sdf_ReferenceVector_dtor(sdf_ReferenceVector_t* _this);

/// Creates a new prim relationship instance.
/// 
/// Creates and returns a new relationship for the given prim.
/// The \p owner will own the newly created relationship.
int sdf_RelationshipSpec_New(sdf_PrimSpecHandle_t const* owner, std_String_t const* name, bool custom, int variability, sdf_RelationshipSpecHandle_t* _result);

/// Get whether loading the target of this relationship is necessary
/// to load the prim we're attached to
int sdf_RelationshipSpec_GetNoLoadHint(sdf_RelationshipSpec_t const* _this, bool* _result);

/// Set whether loading the target of this relationship is necessary
/// to load the prim we're attached to
int sdf_RelationshipSpec_SetNoLoadHint(sdf_RelationshipSpec_t* _this, bool noload);

/// Returns the relationship's target path list editor.
/// 
/// The list of the target paths for this relationship may be modified
/// through the proxy.
int sdf_RelationshipSpec_GetTargetPathList(sdf_RelationshipSpec_t const* _this, sdf_InheritsProxy_t* _result);

/// Returns true if the relationship has any target paths.
int sdf_RelationshipSpec_HasTargetPathList(sdf_RelationshipSpec_t const* _this, bool* _result);

/// Clears the list of target paths on this relationship.
int sdf_RelationshipSpec_ClearTargetPathList(sdf_RelationshipSpec_t const* _this);

/// Updates the specified target path.
/// 
/// Replaces the path given by \p oldPath with the one specified by
/// \p newPath.  Relational attributes are updated if necessary.
int sdf_RelationshipSpec_ReplaceTargetPath(sdf_RelationshipSpec_t* _this, sdf_Path_t const* oldPath, sdf_Path_t const* newPath);

/// Removes the specified target path.
/// 
/// Removes the given target path and any relational attributes for the
/// given target path. If \p preserveTargetOrder is \c true, Erase() is
/// called on the list editor instead of RemoveItemEdits(). This preserves
/// the ordered items list.
int sdf_RelationshipSpec_RemoveTargetPath(sdf_RelationshipSpec_t* _this, sdf_Path_t const* path, bool preserveTargetOrder);

/// Returns the owner prim or relationship of this property.
int sdf_RelationshipSpec_GetOwner(sdf_RelationshipSpec_t const* _this, sdf_SpecHandle_t* _result);

/// Returns the property's custom data.
/// 
/// The default value for custom data is an empty dictionary.
/// 
/// Custom data is for use by plugins or other non-tools supplied
/// extensions that need to be able to store data attached to arbitrary
/// scene objects.  Note that if the only objects you want to store data
/// on are prims, using custom attributes is probably a better choice.
/// But if you need to possibly store this data on attributes or
/// relationships or as annotations on reference arcs, then custom data
/// is an appropriate choice.
int sdf_RelationshipSpec_GetCustomData(sdf_RelationshipSpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Returns the asset info dictionary for this property.
/// 
/// The default value is an empty dictionary. 
/// 
/// The asset info dictionary is used to annotate SdfAssetPath-valued 
/// attributes pointing to the root-prims of assets (generally organized 
/// as models) with various data related to asset management. For example, 
/// asset name, root layer identifier, asset version etc.
/// 
/// \note It is only valid to author assetInfo on attributes that are of 
/// type SdfAssetPath.
int sdf_RelationshipSpec_GetAssetInfo(sdf_RelationshipSpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Sets a property custom data entry.
/// 
/// If \p value is empty, then this removes the given custom data entry.
int sdf_RelationshipSpec_SetCustomData(sdf_RelationshipSpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Sets a asset info entry for this property.
/// 
/// If \p value is empty, then this removes the given asset info entry.
/// 
/// \sa GetAssetInfo()
int sdf_RelationshipSpec_SetAssetInfo(sdf_RelationshipSpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Returns the displayGroup string for this property spec.
/// 
/// The default value for displayGroup is empty string.
int sdf_RelationshipSpec_GetDisplayGroup(sdf_RelationshipSpec_t const* _this, std_String_t* _result);

/// Sets the displayGroup string for this property spec.
int sdf_RelationshipSpec_SetDisplayGroup(sdf_RelationshipSpec_t* _this, std_String_t const* value);

/// Returns the displayName string for this property spec.
/// 
/// The default value for displayName is empty string.
int sdf_RelationshipSpec_GetDisplayName(sdf_RelationshipSpec_t const* _this, std_String_t* _result);

/// Sets the displayName string for this property spec.
int sdf_RelationshipSpec_SetDisplayName(sdf_RelationshipSpec_t* _this, std_String_t const* value);

/// Returns the documentation string for this property spec.
/// 
/// The default value for documentation is empty string.
int sdf_RelationshipSpec_GetDocumentation(sdf_RelationshipSpec_t const* _this, std_String_t* _result);

/// Sets the documentation string for this property spec.
int sdf_RelationshipSpec_SetDocumentation(sdf_RelationshipSpec_t* _this, std_String_t const* value);

/// Returns whether this property spec will be hidden in browsers.
/// 
/// The default value for hidden is false.
int sdf_RelationshipSpec_GetHidden(sdf_RelationshipSpec_t const* _this, bool* _result);

/// Sets whether this property spec will be hidden in browsers.
int sdf_RelationshipSpec_SetHidden(sdf_RelationshipSpec_t* _this, bool value);

/// Returns the property's permission restriction.
/// 
/// The default value for permission is SdfPermissionPublic.
int sdf_RelationshipSpec_GetPermission(sdf_RelationshipSpec_t const* _this, int* _result);

/// Sets the property's permission restriction.
int sdf_RelationshipSpec_SetPermission(sdf_RelationshipSpec_t* _this, int value);

/// Returns the prefix string for this property spec.
/// 
/// The default value for prefix is "".
int sdf_RelationshipSpec_GetPrefix(sdf_RelationshipSpec_t const* _this, std_String_t* _result);

/// Sets the prefix string for this property spec.
int sdf_RelationshipSpec_SetPrefix(sdf_RelationshipSpec_t* _this, std_String_t const* value);

/// Returns the suffix string for this property spec.
/// 
/// The default value for suffix is "".
int sdf_RelationshipSpec_GetSuffix(sdf_RelationshipSpec_t const* _this, std_String_t* _result);

/// Sets the suffix string for this property spec.
int sdf_RelationshipSpec_SetSuffix(sdf_RelationshipSpec_t* _this, std_String_t const* value);

/// Returns the property's symmetric peer.
/// 
/// The default value for the symmetric peer is an empty string.
int sdf_RelationshipSpec_GetSymmetricPeer(sdf_RelationshipSpec_t const* _this, std_String_t* _result);

/// Sets the property's symmetric peer.
/// 
/// If \p peerName is empty, then this removes any symmetric peer for the
/// given property.
int sdf_RelationshipSpec_SetSymmetricPeer(sdf_RelationshipSpec_t* _this, std_String_t const* peerName);

/// Returns the property's symmetry arguments.
/// 
/// The default value for symmetry arguments is an empty dictionary.
int sdf_RelationshipSpec_GetSymmetryArguments(sdf_RelationshipSpec_t const* _this, sdf_DictionaryProxy_t* _result);

/// Sets a property symmetry argument.
/// 
/// If \p value is empty, then this removes the argument with the given
/// \p name.
int sdf_RelationshipSpec_SetSymmetryArgument(sdf_RelationshipSpec_t* _this, std_String_t const* name, vt_Value_t const* value);

/// Returns the property's symmetry function.
/// 
/// The default value for the symmetry function is an empty token.
int sdf_RelationshipSpec_GetSymmetryFunction(sdf_RelationshipSpec_t const* _this, tf_Token_t* _result);

/// Sets the property's symmetry function.
/// 
/// If \p functionName is empty, then this removes any symmetry function
/// for the given property.
int sdf_RelationshipSpec_SetSymmetryFunction(sdf_RelationshipSpec_t* _this, tf_Token_t const* functionName);

/// Returns the entire set of time samples.
int sdf_RelationshipSpec_GetTimeSampleMap(sdf_RelationshipSpec_t const* _this, sdf_TimeSampleMap_t* _result);

/// Returns the TfType representing the value type this property holds.
int sdf_RelationshipSpec_GetValueType(sdf_RelationshipSpec_t const* _this, tf_Type_t* _result);

/// Returns the name of the value type that this property holds.
/// 
/// Returns the typename used to represent the types of value held by
/// this attribute.
int sdf_RelationshipSpec_GetTypeName(sdf_RelationshipSpec_t const* _this, sdf_ValueTypeName_t* _result);

/// Returns the attribute's default value.
/// 
/// If it doesn't have a default value, an empty VtValue is returned.
int sdf_RelationshipSpec_GetDefaultValue(sdf_RelationshipSpec_t const* _this, vt_Value_t* _result);

/// Sets the attribute's default value.
/// 
/// Returns true if successful, false otherwise.  Fails if \p defaultValue
/// has wrong type.
int sdf_RelationshipSpec_SetDefaultValue(sdf_RelationshipSpec_t* _this, vt_Value_t const* defaultValue, bool* _result);

/// Returns true if a default value is set for this attribute.
int sdf_RelationshipSpec_HasDefaultValue(sdf_RelationshipSpec_t const* _this, bool* _result);

/// Clear the attribute's default value.
int sdf_RelationshipSpec_ClearDefaultValue(sdf_RelationshipSpec_t* _this);

/// Returns the comment string for this property spec.
/// 
/// The default value for comment is "".
int sdf_RelationshipSpec_GetComment(sdf_RelationshipSpec_t const* _this, std_String_t* _result);

/// Sets the comment string for this property spec.
int sdf_RelationshipSpec_SetComment(sdf_RelationshipSpec_t* _this, std_String_t const* value);

/// Returns true if this spec declares a custom property
int sdf_RelationshipSpec_IsCustom(sdf_RelationshipSpec_t const* _this, bool* _result);

/// Sets whether this spec declares a custom property
int sdf_RelationshipSpec_SetCustom(sdf_RelationshipSpec_t* _this, bool custom);

/// Returns the variability of the property.
/// 
/// An attribute's variability may be \c Varying (the default),
/// \c Uniform, \c Config, or \c Computed.
/// 
/// A relationship's variability may be \c Varying or \c Uniform (the
/// default)
/// 
/// <ul>
///     <li>\c Varying attributes may be directly authored, animated and
///         affected by \p Actions.  They are the most flexible.
///         Varying relationships can have a default and an anim spline,
///         in addition to a list of targets.
/// 
///     <li>\c Uniform attributes may be authored only with non-animated
///         values (default values).  They cannot be affected by \p Actions,
///         but they can be connected to other Uniform attributes.
///         Uniform relationships have a list of targets but do not have
///         default or anim spline values.
/// 
///     <li>\c Config attributes are the same as Uniform except that a Prim
///         can choose to alter its collection of built-in properties based
///         on the values of its Config attributes.
/// 
///     <li>\c Computed attributes may not be authored in scene description.
///         Prims determine the values of their Computed attributes through
///         Prim-specific computation.  They may not be connected.
/// </ul>
int sdf_RelationshipSpec_GetVariability(sdf_RelationshipSpec_t const* _this, int* _result);

/// Returns true if this PropertySpec has no significant data other than
/// just what is necessary for instantiation.
/// 
/// For example, "double foo" has only required fields, but "double foo = 3"
/// has more than just what is required.
/// 
/// This is similar to IsInert except that IsInert will always return false 
/// even for properties that have only required fields; PropertySpecs are 
/// never considered inert because even a spec with only required fields 
/// will cause instantiation of on-demand properties.
int sdf_RelationshipSpec_HasOnlyRequiredFields(sdf_RelationshipSpec_t const* _this, bool* _result);

/// Returns the property's name.
int sdf_RelationshipSpec_GetName(sdf_RelationshipSpec_t const* _this, std_String_t const** _result);

/// Returns the property's name, as a token.
int sdf_RelationshipSpec_GetNameToken(sdf_RelationshipSpec_t const* _this, tf_Token_t* _result);

/// Returns true if setting the property spec's name to \p newName
/// will succeed.
/// 
/// Returns false if it won't, and sets \p whyNot with a string
/// describing why not.
int sdf_RelationshipSpec_CanSetName(sdf_RelationshipSpec_t const* _this, std_String_t const* newName, std_String_t* whyNot, bool* _result);

/// Sets the property's name.
/// 
/// A Prim's properties must be unique by name. Setting the
/// name to the same name as an existing property is an error.
/// 
/// Setting \p validate to false, will skip validation of the newName
/// (that is, CanSetName will not be called).
int sdf_RelationshipSpec_SetName(sdf_RelationshipSpec_t* _this, std_String_t const* newName, bool validate, bool* _result);

/// Returns true if the given name is considered a valid name for a
/// property.  A valid name is not empty, and does not use invalid
/// characters (such as '/', '[', or '.').
int sdf_RelationshipSpec_IsValidName(std_String_t const* name, bool* _result);

/// Returns the SdfSchemaBase for the layer that owns this spec.
int sdf_RelationshipSpec_GetSchema(sdf_RelationshipSpec_t const* _this, sdf_SchemaBase_t const** _result);

/// Returns the SdfSpecType specifying the spec type this object
/// represents.
int sdf_RelationshipSpec_GetSpecType(sdf_RelationshipSpec_t const* _this, int* _result);

/// Returns true if this object is invalid or expired.
int sdf_RelationshipSpec_IsDormant(sdf_RelationshipSpec_t const* _this, bool* _result);

/// Returns the layer that this object belongs to.
int sdf_RelationshipSpec_GetLayer(sdf_RelationshipSpec_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the scene path of this object.
int sdf_RelationshipSpec_GetPath(sdf_RelationshipSpec_t const* _this, sdf_Path_t* _result);

/// Returns whether this object's layer can be edited.
int sdf_RelationshipSpec_PermissionToEdit(sdf_RelationshipSpec_t const* _this, bool* _result);

/// Returns the full list of info keys currently set on this object.
/// \note This does not include fields that represent names of children.
int sdf_RelationshipSpec_ListInfoKeys(sdf_RelationshipSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns the list of metadata info keys for this object.
/// 
/// This is not the complete list of keys, it is only those that
/// should be considered to be metadata by inspectors or other 
/// presentation UI.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_RelationshipSpec_GetMetaDataInfoKeys(sdf_RelationshipSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns this metadata key's displayGroup.
int sdf_RelationshipSpec_GetMetaDataDisplayGroup(sdf_RelationshipSpec_t const* _this, tf_Token_t const* key, tf_Token_t* _result);

/// Gets the value for the given metadata key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_RelationshipSpec_GetInfo(sdf_RelationshipSpec_t const* _this, tf_Token_t const* key, vt_Value_t* _result);

/// Sets the value for the given metadata key.
/// 
/// It is an error to pass a value that is not the correct type for
/// that given key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_RelationshipSpec_SetInfo(sdf_RelationshipSpec_t* _this, tf_Token_t const* key, vt_Value_t const* value);

/// Sets the value for \p entryKey to \p value within the dictionary 
///        with the given metadata key \p dictionaryKey
int sdf_RelationshipSpec_SetInfoDictionaryValue(sdf_RelationshipSpec_t* _this, tf_Token_t const* dictionaryKey, tf_Token_t const* entryKey, vt_Value_t const* value);

/// Returns whether there is a setting for the scene spec info 
/// with the given key.
/// 
/// When asked for a value for one of its scene spec info, a valid value
/// will always be returned. But if this API returns \b false for a scene
/// spec info, the value of that info will be the defined default value.
/// 
/// When dealing with a composedLayer, it is not necessary to worry about
/// whether a scene spec info "has a value" because the composed layer will
/// always have a valid value, even if it is the default.
/// 
/// A spec may or may not have an expressed value for some of its
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_RelationshipSpec_HasInfo(sdf_RelationshipSpec_t const* _this, tf_Token_t const* key, bool* _result);

/// Clears the value for scene spec info with the given \a key.
/// 
/// After calling this, HasInfo() will return \b false.
/// To make HasInfo() return \b true just set a value for that
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_RelationshipSpec_ClearInfo(sdf_RelationshipSpec_t* _this, tf_Token_t const* key);

/// Returns the data type for the info with the given \a key.
int sdf_RelationshipSpec_GetTypeForInfo(sdf_RelationshipSpec_t const* _this, tf_Token_t const* key, tf_Type_t* _result);

/// Returns the fallback for the info with the given \a key.
int sdf_RelationshipSpec_GetFallbackForInfo(sdf_RelationshipSpec_t const* _this, tf_Token_t const* key, vt_Value_t const** _result);

/// Returns whether this object has no significant data.
/// 
/// "Significant" here means that the object contributes opinions to
/// a scene. If this spec has any child scenegraph objects (e.g.,
/// prim or property spec), it will be considered significant even if
/// those child objects are not.
/// However, if \p ignoreChildren is \c true, these child objects
/// will be ignored. 
int sdf_RelationshipSpec_IsInert(sdf_RelationshipSpec_t const* _this, bool ignoreChildren, bool* _result);

/// Returns all fields with values.
int sdf_RelationshipSpec_ListFields(sdf_RelationshipSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns \c true if the spec has a non-empty value with field
/// name \p name.
int sdf_RelationshipSpec_HasField(sdf_RelationshipSpec_t const* _this, tf_Token_t const* name, bool* _result);

/// Returns a field value by name.
int sdf_RelationshipSpec_GetField(sdf_RelationshipSpec_t const* _this, tf_Token_t const* name, vt_Value_t* _result);

/// Sets a field value as a boxed VtValue.
int sdf_RelationshipSpec_SetField(sdf_RelationshipSpec_t* _this, tf_Token_t const* name, vt_Value_t const* value, bool* _result);

/// \name Comparison operators
/// @{
int sdf_RelationshipSpec_op_eq(sdf_RelationshipSpec_t const* _this, sdf_Spec_t const* rhs, bool* _result);

int sdf_RelationshipSpec_dtor(sdf_RelationshipSpec_t* _this);

int sdf_RelationshipSpecHandle_dtor(sdf_RelationshipSpecHandle_t* _this);

int sdf_RelationshipSpecHandleVector_data(sdf_RelationshipSpecHandleVector_t* _this, sdf_RelationshipSpecHandle_t** _result);

int sdf_RelationshipSpecHandleVector_data_const(sdf_RelationshipSpecHandleVector_t const* _this, sdf_RelationshipSpecHandle_t const** _result);

int sdf_RelationshipSpecHandleVector_empty(sdf_RelationshipSpecHandleVector_t const* _this, bool* _result);

int sdf_RelationshipSpecHandleVector_size(sdf_RelationshipSpecHandleVector_t const* _this, size_t* _result);

int sdf_RelationshipSpecHandleVector_max_size(sdf_RelationshipSpecHandleVector_t const* _this, size_t* _result);

int sdf_RelationshipSpecHandleVector_reserve(sdf_RelationshipSpecHandleVector_t* _this, size_t const _Newcapacity);

int sdf_RelationshipSpecHandleVector_capacity(sdf_RelationshipSpecHandleVector_t const* _this, size_t* _result);

int sdf_RelationshipSpecHandleVector_clear(sdf_RelationshipSpecHandleVector_t* _this);

int sdf_RelationshipSpecHandleVector_push_back(sdf_RelationshipSpecHandleVector_t* _this, sdf_RelationshipSpecHandle_t const* _Val);

int sdf_RelationshipSpecHandleVector_pop_back(sdf_RelationshipSpecHandleVector_t* _this);

int sdf_RelationshipSpecHandleVector_resize(sdf_RelationshipSpecHandleVector_t* _this, size_t const _Newsize);

int sdf_RelationshipSpecHandleVector_resize_with(sdf_RelationshipSpecHandleVector_t* _this, size_t const _Newsize, sdf_RelationshipSpecHandle_t const* _Val);

int sdf_RelationshipSpecHandleVector_op_index(sdf_RelationshipSpecHandleVector_t const* _this, size_t const _Pos, sdf_RelationshipSpecHandle_t const** _result);

int sdf_RelationshipSpecHandleVector_default(sdf_RelationshipSpecHandleVector_t** _result);

int sdf_RelationshipSpecHandleVector_dtor(sdf_RelationshipSpecHandleVector_t* _this);

int sdf_RelationshipSpecView_dtor(sdf_RelationshipSpecView_t* _this);

int sdf_RelationshipSpecHandleOffsetPair_dtor(sdf_RelationshipSpecHandleOffsetPair_t* _this);

int sdf_RelationshipSpecHandleOffsetPairVector_data(sdf_RelationshipSpecHandleOffsetPairVector_t* _this, sdf_RelationshipSpecHandleOffsetPair_t** _result);

int sdf_RelationshipSpecHandleOffsetPairVector_data_const(sdf_RelationshipSpecHandleOffsetPairVector_t const* _this, sdf_RelationshipSpecHandleOffsetPair_t const** _result);

int sdf_RelationshipSpecHandleOffsetPairVector_empty(sdf_RelationshipSpecHandleOffsetPairVector_t const* _this, bool* _result);

int sdf_RelationshipSpecHandleOffsetPairVector_size(sdf_RelationshipSpecHandleOffsetPairVector_t const* _this, size_t* _result);

int sdf_RelationshipSpecHandleOffsetPairVector_max_size(sdf_RelationshipSpecHandleOffsetPairVector_t const* _this, size_t* _result);

int sdf_RelationshipSpecHandleOffsetPairVector_reserve(sdf_RelationshipSpecHandleOffsetPairVector_t* _this, size_t const _Newcapacity);

int sdf_RelationshipSpecHandleOffsetPairVector_capacity(sdf_RelationshipSpecHandleOffsetPairVector_t const* _this, size_t* _result);

int sdf_RelationshipSpecHandleOffsetPairVector_clear(sdf_RelationshipSpecHandleOffsetPairVector_t* _this);

int sdf_RelationshipSpecHandleOffsetPairVector_push_back(sdf_RelationshipSpecHandleOffsetPairVector_t* _this, sdf_RelationshipSpecHandleOffsetPair_t const* _Val);

int sdf_RelationshipSpecHandleOffsetPairVector_pop_back(sdf_RelationshipSpecHandleOffsetPairVector_t* _this);

int sdf_RelationshipSpecHandleOffsetPairVector_resize(sdf_RelationshipSpecHandleOffsetPairVector_t* _this, size_t const _Newsize);

int sdf_RelationshipSpecHandleOffsetPairVector_resize_with(sdf_RelationshipSpecHandleOffsetPairVector_t* _this, size_t const _Newsize, sdf_RelationshipSpecHandleOffsetPair_t const* _Val);

int sdf_RelationshipSpecHandleOffsetPairVector_op_index(sdf_RelationshipSpecHandleOffsetPairVector_t const* _this, size_t const _Pos, sdf_RelationshipSpecHandleOffsetPair_t const** _result);

int sdf_RelationshipSpecHandleOffsetPairVector_default(sdf_RelationshipSpecHandleOffsetPairVector_t** _result);

int sdf_RelationshipSpecHandleOffsetPairVector_dtor(sdf_RelationshipSpecHandleOffsetPairVector_t* _this);

int sdf_RelocatesMap_dtor(sdf_RelocatesMap_t* _this);

int sdf_RelocatesMapProxy_dtor(sdf_RelocatesMapProxy_t* _this);

/// Returns the field definition for the given field. 
/// Returns NULL if no definition exists for given field.
int sdf_SchemaBase_GetFieldDefinition(sdf_SchemaBase_t const* _this, tf_Token_t const* fieldKey, sdf_SchemaBaseFieldDefinition_t const** _result);

/// Returns the spec definition for the given spec type.
/// Returns NULL if no definition exists for the given spec type.
int sdf_SchemaBase_GetSpecDefinition(sdf_SchemaBase_t const* _this, int specType, sdf_SchemaBaseSpecDefinition_t const** _result);

/// Return whether the specified field has been registered. Also
/// optionally return the fallback value.
int sdf_SchemaBase_IsRegistered(sdf_SchemaBase_t const* _this, tf_Token_t const* fieldKey, vt_Value_t* fallback, bool* _result);

/// Returns whether the given field is a 'children' field -- that is, it
/// indexes certain children beneath the owning spec.
int sdf_SchemaBase_HoldsChildren(sdf_SchemaBase_t const* _this, tf_Token_t const* fieldKey, bool* _result);

/// Return the fallback value for the specified \p fieldKey or the
/// empty value if \p fieldKey is not registered.
int sdf_SchemaBase_GetFallback(sdf_SchemaBase_t const* _this, tf_Token_t const* fieldKey, vt_Value_t const** _result);

/// Coerce \p value to the correct type for the specified field.
int sdf_SchemaBase_CastToTypeOf(sdf_SchemaBase_t const* _this, tf_Token_t const* fieldKey, vt_Value_t const* value, vt_Value_t* _result);

/// Return whether the given field is valid for the given spec type.
int sdf_SchemaBase_IsValidFieldForSpec(sdf_SchemaBase_t const* _this, tf_Token_t const* fieldKey, int specType, bool* _result);

/// Returns all fields registered for the given spec type.
int sdf_SchemaBase_GetFields(sdf_SchemaBase_t const* _this, int specType, tf_TokenVector_t* _result);

/// Returns all metadata fields registered for the given spec type.
int sdf_SchemaBase_GetMetadataFields(sdf_SchemaBase_t const* _this, int specType, tf_TokenVector_t* _result);

/// Return the metadata field display group for metadata \a metadataField on
/// \a specType.  Return the empty token if \a metadataField is not a
/// metadata field, or if it has no display group.
int sdf_SchemaBase_GetMetadataFieldDisplayGroup(sdf_SchemaBase_t const* _this, int specType, tf_Token_t const* metadataField, tf_Token_t* _result);

/// Returns all required fields registered for the given spec type.
int sdf_SchemaBase_GetRequiredFields(sdf_SchemaBase_t const* _this, int specType, tf_TokenVector_t const** _result);

/// Return true if \p fieldName is a required field name for at least one
/// spec type, return false otherwise.  The main use of this function is to
/// quickly rule out field names that aren't required (and thus don't need
/// special handling).
int sdf_SchemaBase_IsRequiredFieldName(sdf_SchemaBase_t const* _this, tf_Token_t const* fieldName, bool* _result);

/// Given a value, check if it is a valid value type.
/// This function only checks that the type of the value is valid
/// for this schema. It does not imply that the value is valid for
/// a particular field -- the field's validation function must be
/// used for that.
int sdf_SchemaBase_IsValidValue(sdf_SchemaBase_t const* _this, vt_Value_t const* value, sdf_Allowed_t* _result);

/// Returns all registered type names.
int sdf_SchemaBase_GetAllTypes(sdf_SchemaBase_t const* _this, sdf_ValueTypeNameVector_t* _result);

/// Return the type name object for the given type name token.
int sdf_SchemaBase_FindType(sdf_SchemaBase_t const* _this, tf_Token_t const* typeName, sdf_ValueTypeName_t* _result);

/// Return the type name object for the given type and optional role.
int sdf_SchemaBase_FindType_with_role(sdf_SchemaBase_t const* _this, tf_Type_t const* type, tf_Token_t const* role, sdf_ValueTypeName_t* _result);

/// Return the type name object for the given type name string if it
/// exists otherwise create a temporary type name object.  Clients
/// should not normally need to call this.
int sdf_SchemaBase_FindOrCreateType(sdf_SchemaBase_t const* _this, tf_Token_t const* typeName, sdf_ValueTypeName_t* _result);

/// Specific validation functions for various fields. These are internally
/// registered as validators for the associated field, but can also be
/// used directly.
/// @{
int sdf_SchemaBase_IsValidAttributeConnectionPath(sdf_Path_t const* path, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidIdentifier(std_String_t const* name, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidNamespacedIdentifier(std_String_t const* name, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidInheritPath(sdf_Path_t const* path, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidPayload(sdf_Payload_t const* payload, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidReference(sdf_Reference_t const* ref, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidRelationshipTargetPath(sdf_Path_t const* path, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidRelocatesPath(sdf_Path_t const* path, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidSpecializesPath(sdf_Path_t const* path, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidSubLayer(std_String_t const* sublayer, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidVariantIdentifier(std_String_t const* name, sdf_Allowed_t* _result);

int sdf_SchemaBase_IsValidVariantSelection(std_String_t const* sel, sdf_Allowed_t* _result);

int sdf_SchemaBaseFieldDefinition_GetName(sdf_SchemaBaseFieldDefinition_t const* _this, tf_Token_t const** _result);

int sdf_SchemaBaseFieldDefinition_GetFallbackValue(sdf_SchemaBaseFieldDefinition_t const* _this, vt_Value_t const** _result);

int sdf_SchemaBaseFieldDefinition_GetInfo(sdf_SchemaBaseFieldDefinition_t const* _this, sdf_SchemaBaseFieldDefinitionInfoVec_t const** _result);

int sdf_SchemaBaseFieldDefinition_IsPlugin(sdf_SchemaBaseFieldDefinition_t const* _this, bool* _result);

int sdf_SchemaBaseFieldDefinition_IsReadOnly(sdf_SchemaBaseFieldDefinition_t const* _this, bool* _result);

int sdf_SchemaBaseFieldDefinition_HoldsChildren(sdf_SchemaBaseFieldDefinition_t const* _this, bool* _result);

int sdf_SchemaBaseFieldDefinition_dtor(sdf_SchemaBaseFieldDefinition_t* _this);

int sdf_SchemaBaseFieldDefinitionInfoVec_data(sdf_SchemaBaseFieldDefinitionInfoVec_t* _this, sdf_TokenValuePair_t** _result);

int sdf_SchemaBaseFieldDefinitionInfoVec_data_const(sdf_SchemaBaseFieldDefinitionInfoVec_t const* _this, sdf_TokenValuePair_t const** _result);

int sdf_SchemaBaseFieldDefinitionInfoVec_empty(sdf_SchemaBaseFieldDefinitionInfoVec_t const* _this, bool* _result);

int sdf_SchemaBaseFieldDefinitionInfoVec_size(sdf_SchemaBaseFieldDefinitionInfoVec_t const* _this, size_t* _result);

int sdf_SchemaBaseFieldDefinitionInfoVec_max_size(sdf_SchemaBaseFieldDefinitionInfoVec_t const* _this, size_t* _result);

int sdf_SchemaBaseFieldDefinitionInfoVec_reserve(sdf_SchemaBaseFieldDefinitionInfoVec_t* _this, size_t const _Newcapacity);

int sdf_SchemaBaseFieldDefinitionInfoVec_capacity(sdf_SchemaBaseFieldDefinitionInfoVec_t const* _this, size_t* _result);

int sdf_SchemaBaseFieldDefinitionInfoVec_clear(sdf_SchemaBaseFieldDefinitionInfoVec_t* _this);

int sdf_SchemaBaseFieldDefinitionInfoVec_push_back(sdf_SchemaBaseFieldDefinitionInfoVec_t* _this, sdf_TokenValuePair_t const* _Val);

int sdf_SchemaBaseFieldDefinitionInfoVec_pop_back(sdf_SchemaBaseFieldDefinitionInfoVec_t* _this);

int sdf_SchemaBaseFieldDefinitionInfoVec_resize(sdf_SchemaBaseFieldDefinitionInfoVec_t* _this, size_t const _Newsize);

int sdf_SchemaBaseFieldDefinitionInfoVec_resize_with(sdf_SchemaBaseFieldDefinitionInfoVec_t* _this, size_t const _Newsize, sdf_TokenValuePair_t const* _Val);

int sdf_SchemaBaseFieldDefinitionInfoVec_op_index(sdf_SchemaBaseFieldDefinitionInfoVec_t const* _this, size_t const _Pos, sdf_TokenValuePair_t const** _result);

int sdf_SchemaBaseFieldDefinitionInfoVec_default(sdf_SchemaBaseFieldDefinitionInfoVec_t** _result);

int sdf_SchemaBaseFieldDefinitionInfoVec_dtor(sdf_SchemaBaseFieldDefinitionInfoVec_t* _this);

int sdf_TokenValuePair_dtor(sdf_TokenValuePair_t* _this);

int sdf_SchemaBaseSpecDefinition_dtor(sdf_SchemaBaseSpecDefinition_t* _this);

/// Returns the SdfSchemaBase for the layer that owns this spec.
int sdf_Spec_GetSchema(sdf_Spec_t const* _this, sdf_SchemaBase_t const** _result);

/// Returns the SdfSpecType specifying the spec type this object
/// represents.
int sdf_Spec_GetSpecType(sdf_Spec_t const* _this, int* _result);

/// Returns true if this object is invalid or expired.
int sdf_Spec_IsDormant(sdf_Spec_t const* _this, bool* _result);

/// Returns the layer that this object belongs to.
int sdf_Spec_GetLayer(sdf_Spec_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the scene path of this object.
int sdf_Spec_GetPath(sdf_Spec_t const* _this, sdf_Path_t* _result);

/// Returns whether this object's layer can be edited.
int sdf_Spec_PermissionToEdit(sdf_Spec_t const* _this, bool* _result);

/// Returns the full list of info keys currently set on this object.
/// \note This does not include fields that represent names of children.
int sdf_Spec_ListInfoKeys(sdf_Spec_t const* _this, tf_TokenVector_t* _result);

/// Returns the list of metadata info keys for this object.
/// 
/// This is not the complete list of keys, it is only those that
/// should be considered to be metadata by inspectors or other 
/// presentation UI.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_Spec_GetMetaDataInfoKeys(sdf_Spec_t const* _this, tf_TokenVector_t* _result);

/// Returns this metadata key's displayGroup.
int sdf_Spec_GetMetaDataDisplayGroup(sdf_Spec_t const* _this, tf_Token_t const* key, tf_Token_t* _result);

/// Gets the value for the given metadata key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_Spec_GetInfo(sdf_Spec_t const* _this, tf_Token_t const* key, vt_Value_t* _result);

/// Sets the value for the given metadata key.
/// 
/// It is an error to pass a value that is not the correct type for
/// that given key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_Spec_SetInfo(sdf_Spec_t* _this, tf_Token_t const* key, vt_Value_t const* value);

/// Sets the value for \p entryKey to \p value within the dictionary 
///        with the given metadata key \p dictionaryKey
int sdf_Spec_SetInfoDictionaryValue(sdf_Spec_t* _this, tf_Token_t const* dictionaryKey, tf_Token_t const* entryKey, vt_Value_t const* value);

/// Returns whether there is a setting for the scene spec info 
/// with the given key.
/// 
/// When asked for a value for one of its scene spec info, a valid value
/// will always be returned. But if this API returns \b false for a scene
/// spec info, the value of that info will be the defined default value.
/// 
/// When dealing with a composedLayer, it is not necessary to worry about
/// whether a scene spec info "has a value" because the composed layer will
/// always have a valid value, even if it is the default.
/// 
/// A spec may or may not have an expressed value for some of its
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_Spec_HasInfo(sdf_Spec_t const* _this, tf_Token_t const* key, bool* _result);

/// Clears the value for scene spec info with the given \a key.
/// 
/// After calling this, HasInfo() will return \b false.
/// To make HasInfo() return \b true just set a value for that
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_Spec_ClearInfo(sdf_Spec_t* _this, tf_Token_t const* key);

/// Returns the data type for the info with the given \a key.
int sdf_Spec_GetTypeForInfo(sdf_Spec_t const* _this, tf_Token_t const* key, tf_Type_t* _result);

/// Returns the fallback for the info with the given \a key.
int sdf_Spec_GetFallbackForInfo(sdf_Spec_t const* _this, tf_Token_t const* key, vt_Value_t const** _result);

/// Returns whether this object has no significant data.
/// 
/// "Significant" here means that the object contributes opinions to
/// a scene. If this spec has any child scenegraph objects (e.g.,
/// prim or property spec), it will be considered significant even if
/// those child objects are not.
/// However, if \p ignoreChildren is \c true, these child objects
/// will be ignored. 
int sdf_Spec_IsInert(sdf_Spec_t const* _this, bool ignoreChildren, bool* _result);

/// Returns all fields with values.
int sdf_Spec_ListFields(sdf_Spec_t const* _this, tf_TokenVector_t* _result);

/// Returns \c true if the spec has a non-empty value with field
/// name \p name.
int sdf_Spec_HasField(sdf_Spec_t const* _this, tf_Token_t const* name, bool* _result);

/// Returns a field value by name.
int sdf_Spec_GetField(sdf_Spec_t const* _this, tf_Token_t const* name, vt_Value_t* _result);

/// Sets a field value as a boxed VtValue.
int sdf_Spec_SetField(sdf_Spec_t* _this, tf_Token_t const* name, vt_Value_t const* value, bool* _result);

/// \name Comparison operators
/// @{
int sdf_Spec_op_eq(sdf_Spec_t const* _this, sdf_Spec_t const* rhs, bool* _result);

int sdf_Spec_dtor(sdf_Spec_t* _this);

int sdf_SpecHandle_dtor(sdf_SpecHandle_t* _this);

int sdf_SubLayerProxy_dtor(sdf_SubLayerProxy_t* _this);

/// Returns the schema for this format.
int sdf_TextFileFormat_GetSchema(sdf_TextFileFormat_t const* _this, sdf_SchemaBase_t const** _result);

/// Returns the format identifier.
int sdf_TextFileFormat_GetFormatId(sdf_TextFileFormat_t const* _this, tf_Token_t const** _result);

/// Returns the target for this file format.
int sdf_TextFileFormat_GetTarget(sdf_TextFileFormat_t const* _this, tf_Token_t const** _result);

/// Returns the cookie to be used when writing files with this format.
int sdf_TextFileFormat_GetFileCookie(sdf_TextFileFormat_t const* _this, std_String_t const** _result);

/// Returns the current version of this file format.
int sdf_TextFileFormat_GetVersionString(sdf_TextFileFormat_t const* _this, tf_Token_t const** _result);

/// Returns true if this file format is the primary format for the 
/// extensions it handles.
int sdf_TextFileFormat_IsPrimaryFormatForExtensions(sdf_TextFileFormat_t const* _this, bool* _result);

/// Returns a list of extensions that this format supports.
int sdf_TextFileFormat_GetFileExtensions(sdf_TextFileFormat_t const* _this, std_StringVector_t const** _result);

/// Returns the primary file extension for this format. This is the
/// extension that is reported for layers using this file format.
int sdf_TextFileFormat_GetPrimaryFileExtension(sdf_TextFileFormat_t const* _this, std_String_t const** _result);

/// Returns true if \p extension matches one of the extensions returned by
/// GetFileExtensions.
int sdf_TextFileFormat_IsSupportedExtension(sdf_TextFileFormat_t const* _this, std_String_t const* extension, bool* _result);

/// Returns true if this file format is a package containing other
/// assets.
int sdf_TextFileFormat_IsPackage(sdf_TextFileFormat_t const* _this, bool* _result);

/// Returns the path of the "root" layer contained in the package
/// layer at \p resolvedPath produced by this file format. If this 
/// file format is not a package, returns the empty string.
/// 
/// The package root layer is the layer in the package layer that 
/// is used when that package is opened via SdfLayer.
int sdf_TextFileFormat_GetPackageRootLayerPath(sdf_TextFileFormat_t const* _this, std_String_t const* resolvedPath, std_String_t* _result);

/// Return true if this file format prefers to skip reloading anonymous
/// layers.
int sdf_TextFileFormat_ShouldSkipAnonymousReload(sdf_TextFileFormat_t const* _this, bool* _result);

/// Returns true if anonymous layer identifiers should be passed to Read 
/// when a layer is opened or reloaded.
/// 
/// Anonymous layers will not have an asset backing and thus for most
/// file formats there is nothing that can be read for an anonymous layer. 
/// However, there are file formats that use Read to generate dynamic layer 
/// content without reading any data from the resolved asset associated with
/// the layer's identifier. 
/// 
/// For these types of file formats it is useful to be able to open 
/// anonymous layers and allow Read to populate them to avoid requiring a
/// placeholder asset to exist just so Read can populate the layer.
int sdf_TextFileFormat_ShouldReadAnonymousLayers(sdf_TextFileFormat_t const* _this, bool* _result);

/// Reads scene description from the asset specified by \p resolvedPath
/// into the detached layer \p layer. After reading is completed,
/// \p layer must be detached from any underlying storage.
/// 
/// \p metadataOnly is a flag that asks for only the layer metadata
/// to be read in, which can be much faster if that is all that is
/// required.  Note that this is just a hint: some FileFormat readers
/// may disregard this flag and still fully populate the layer contents.
/// 
/// Returns true if the asset is successfully read into \p layer,
/// false if the the asset could not be read or if the resulting
/// layer is not detached.
int sdf_TextFileFormat_ReadDetached(sdf_TextFileFormat_t const* _this, sdf_Layer_t* layer, std_String_t const* resolvedPath, bool metadataOnly, bool* _result);

/// Returns the set of resolved paths to external asset file dependencies 
/// for the given \p layer. These are additional dependencies, specific to 
/// the file format, that are needed when generating the layer's contents
/// and would not otherwise be discoverable through composition dependencies
/// (i.e. sublayers, references, and payloads). 
/// 
/// The default implementation returns an empty set. Derived file formats 
/// that depend on external assets to read and generate layer content 
/// should implement this function to return the external asset paths.
/// 
/// \sa SdfLayer::GetExternalAssetDependencies
/// \sa SdfLayer::Reload
int sdf_TextFileFormat_GetExternalAssetDependencies(sdf_TextFileFormat_t const* _this, sdf_Layer_t const* layer, std_StringSet_t* _result);

/// Returns true if this file format supports reading.
/// This is a convenience method for invoking \ref FormatSupportsReading
/// with this format's extension and target
int sdf_TextFileFormat_SupportsReading(sdf_TextFileFormat_t const* _this, bool* _result);

/// This is a convenience method for invoking \ref FormatSupportsWriting
/// with this format's extension and target
int sdf_TextFileFormat_SupportsWriting(sdf_TextFileFormat_t const* _this, bool* _result);

/// This is a convenience method for invoking \ref FormatSupportsEditing
/// with this format's extension and target
int sdf_TextFileFormat_SupportsEditing(sdf_TextFileFormat_t const* _this, bool* _result);

/// Returns the file extension for path or file name \p s, without the
/// leading dot character.
int sdf_TextFileFormat_GetFileExtension(std_String_t const* s, std_String_t* _result);

/// Returns a set containing the extension(s) corresponding to 
/// all registered file formats.
int sdf_TextFileFormat_FindAllFileFormatExtensions(std_StringSet_t* _result);

/// Returns a set containing the extension(s) corresponding to
/// all registered file formats that derive from \p baseType.
/// 
/// \p baseType must derive from SdfFileFormat.
int sdf_TextFileFormat_FindAllDerivedFileFormatExtensions(tf_Type_t const* baseType, std_StringSet_t* _result);

/// Returns true if the file format for the supplied \p extension and
/// \p target pair supports reading.
/// This method will not load the plugin that provides the specified 
/// file format.
/// If the extension and target pair is invalid, this method will
/// return false.
/// \sa FormatSupportsWriting \sa FormatSupportsEditing
int sdf_TextFileFormat_FormatSupportsReading(std_String_t const* extension, std_String_t const* target, bool* _result);

/// Returns true if the file format for the supplied \p extension and 
/// \p target pair supports writing.
/// This method will not load the plugin that provides the specified 
/// file format.
/// If the extension and target pair is invalid, this method will return
/// false.
/// \sa FormatSupportsReading \sa FormatSupportsEditing
int sdf_TextFileFormat_FormatSupportsWriting(std_String_t const* extension, std_String_t const* target, bool* _result);

/// Returns true if the file format for the supplied \p extension and 
/// \p target pair supports editing.
/// This method will not load the plugin that provides the specified 
/// file format.
/// If the extension and target pair is invalid, this method will return
/// false.
/// \sa FormatSupportsReading \sa FormatSupportsWriting
int sdf_TextFileFormat_FormatSupportsEditing(std_String_t const* extension, std_String_t const* target, bool* _result);

int sdf_TextFileFormat_CanRead(sdf_TextFileFormat_t const* _this, std_String_t const* file, bool* _result);

int sdf_TextFileFormat_Read(sdf_TextFileFormat_t const* _this, sdf_Layer_t* layer, std_String_t const* resolvedPath, bool metadataOnly, bool* _result);

int sdf_TextFileFormat_WriteToFile(sdf_TextFileFormat_t const* _this, sdf_Layer_t const* layer, std_String_t const* filePath, std_String_t const* comment, sdf_LayerFileFormatArguments_t const* args, bool* _result);

int sdf_TextFileFormat_ReadFromString(sdf_TextFileFormat_t const* _this, sdf_Layer_t* layer, std_String_t const* str, bool* _result);

int sdf_TextFileFormat_WriteToString(sdf_TextFileFormat_t const* _this, sdf_Layer_t const* layer, std_String_t* str, std_String_t const* comment, bool* _result);

/// Return the time value.
int sdf_TimeCode_GetValue(sdf_TimeCode_t const* _this, double* _result);

int sdf_TimeCode_from_time(double param00, sdf_TimeCode_t** _result);

int sdf_TimeCode_dtor(sdf_TimeCode_t* _this);

int sdf_TimeSampleMap_dtor(sdf_TimeSampleMap_t* _this);

int sdf_ValueBlock_new(sdf_ValueBlock_t** _result);

int sdf_ValueBlock_dtor(sdf_ValueBlock_t* _this);

/// Returns the type name as a token.  This should not be used for
/// comparison purposes.
int sdf_ValueTypeName_GetAsToken(sdf_ValueTypeName_t const* _this, tf_Token_t* _result);

/// Returns the \c TfType of the type.
int sdf_ValueTypeName_GetType(sdf_ValueTypeName_t const* _this, tf_Type_t const** _result);

/// Returns the type's role.
int sdf_ValueTypeName_GetRole(sdf_ValueTypeName_t const* _this, tf_Token_t const** _result);

/// Returns the default value for the type.
int sdf_ValueTypeName_GetDefaultValue(sdf_ValueTypeName_t const* _this, vt_Value_t const** _result);

/// Returns the default unit enum for the type.
int sdf_ValueTypeName_GetDefaultUnit(sdf_ValueTypeName_t const* _this, tf_Enum_t const** _result);

/// Returns the scalar version of this type name if it's an array type
/// name, otherwise returns this type name.  If there is no scalar type
/// name then this returns the invalid type name.
int sdf_ValueTypeName_GetScalarType(sdf_ValueTypeName_t const* _this, sdf_ValueTypeName_t* _result);

/// Returns the array version of this type name if it's an scalar type
/// name, otherwise returns this type name.  If there is no array type
/// name then this returns the invalid type name.
int sdf_ValueTypeName_GetArrayType(sdf_ValueTypeName_t const* _this, sdf_ValueTypeName_t* _result);

/// Returns \c true iff this type is a scalar.  The invalid type is
/// considered neither scalar nor array.
int sdf_ValueTypeName_IsScalar(sdf_ValueTypeName_t const* _this, bool* _result);

/// Returns \c true iff this type is an array.  The invalid type is
/// considered neither scalar nor array.
int sdf_ValueTypeName_IsArray(sdf_ValueTypeName_t const* _this, bool* _result);

/// Returns the dimensions of the scalar value, e.g. 3 for a 3D point.
int sdf_ValueTypeName_GetDimensions(sdf_ValueTypeName_t const* _this, sdf_TupleDimensions_t* _result);

/// Returns all aliases of the type name as tokens.  These should not
/// be used for comparison purposes.
int sdf_ValueTypeName_GetAliasesAsTokens(sdf_ValueTypeName_t const* _this, tf_TokenVector_t* _result);

int sdf_ValueTypeName_new(sdf_ValueTypeName_t** _result);

int sdf_ValueTypeName_dtor(sdf_ValueTypeName_t* _this);

int sdf_ValueTypeNameVector_data(sdf_ValueTypeNameVector_t* _this, sdf_ValueTypeName_t** _result);

int sdf_ValueTypeNameVector_data_const(sdf_ValueTypeNameVector_t const* _this, sdf_ValueTypeName_t const** _result);

int sdf_ValueTypeNameVector_empty(sdf_ValueTypeNameVector_t const* _this, bool* _result);

int sdf_ValueTypeNameVector_size(sdf_ValueTypeNameVector_t const* _this, size_t* _result);

int sdf_ValueTypeNameVector_max_size(sdf_ValueTypeNameVector_t const* _this, size_t* _result);

int sdf_ValueTypeNameVector_reserve(sdf_ValueTypeNameVector_t* _this, size_t const _Newcapacity);

int sdf_ValueTypeNameVector_capacity(sdf_ValueTypeNameVector_t const* _this, size_t* _result);

int sdf_ValueTypeNameVector_clear(sdf_ValueTypeNameVector_t* _this);

int sdf_ValueTypeNameVector_push_back(sdf_ValueTypeNameVector_t* _this, sdf_ValueTypeName_t const* _Val);

int sdf_ValueTypeNameVector_pop_back(sdf_ValueTypeNameVector_t* _this);

int sdf_ValueTypeNameVector_resize(sdf_ValueTypeNameVector_t* _this, size_t const _Newsize);

int sdf_ValueTypeNameVector_resize_with(sdf_ValueTypeNameVector_t* _this, size_t const _Newsize, sdf_ValueTypeName_t const* _Val);

int sdf_ValueTypeNameVector_op_index(sdf_ValueTypeNameVector_t const* _this, size_t const _Pos, sdf_ValueTypeName_t const** _result);

int sdf_ValueTypeNameVector_default(sdf_ValueTypeNameVector_t** _result);

int sdf_ValueTypeNameVector_dtor(sdf_ValueTypeNameVector_t* _this);

/// Returns a list of errors encountered when parsing this expression.
/// 
/// If the expression was parsed successfully, this list will be empty.
/// However, additional errors may be encountered when evaluating the e
/// expression.
int sdf_VariableExpression_GetErrors(sdf_VariableExpression_t const* _this, std_StringVector_t const** _result);

/// Evaluates this expression using the variables in
/// \p variables and returns a Result object with the final
/// value. If an error occurs during evaluation, the value field
/// in the Result object will be an empty VtValue and error messages
/// will be added to the errors field.
/// 
/// If this object represents an invalid expression, calling this
/// function will return a Result object with an empty value and the
/// errors from GetErrors().
/// 
/// If any values in \p variables used by this expression
/// are themselves expressions, they will be parsed and evaluated.
/// If an error occurs while evaluating any of these subexpressions,
/// evaluation of this expression fails and the encountered errors
/// will be added in the Result's list of errors.
int sdf_VariableExpression_Evaluate(sdf_VariableExpression_t const* _this, vt_Dictionary_t const* variables, sdf_VariableExpressionResult_t* _result);

int sdf_VariableExpression_new(sdf_VariableExpression_t** _result);

int sdf_VariableExpression_dtor(sdf_VariableExpression_t* _this);

int sdf_VariableExpressionResult_dtor(sdf_VariableExpressionResult_t* _this);

int sdf_VariantSelectionProxy_dtor(sdf_VariantSelectionProxy_t* _this);

/// Returns the name of this variant set.
int sdf_VariantSetSpec_GetName(sdf_VariantSetSpec_t const* _this, std_String_t* _result);

/// Returns the name of this variant set.
int sdf_VariantSetSpec_GetNameToken(sdf_VariantSetSpec_t const* _this, tf_Token_t* _result);

/// Returns the prim or variant that this variant set belongs to.
int sdf_VariantSetSpec_GetOwner(sdf_VariantSetSpec_t const* _this, sdf_SpecHandle_t* _result);

/// Returns the variants as a map.
int sdf_VariantSetSpec_GetVariants(sdf_VariantSetSpec_t const* _this, sdf_VariantView_t* _result);

/// Returns the variants as a vector.
int sdf_VariantSetSpec_GetVariantList(sdf_VariantSetSpec_t const* _this, sdf_VariantSpecHandleVector_t* _result);

/// Removes \p variant from the list of variants.
/// 
/// If the variant set does not currently own \p variant, no action
/// is taken.
int sdf_VariantSetSpec_RemoveVariant(sdf_VariantSetSpec_t* _this, sdf_VariantSpecHandle_t const* variant);

/// Returns the SdfSchemaBase for the layer that owns this spec.
int sdf_VariantSetSpec_GetSchema(sdf_VariantSetSpec_t const* _this, sdf_SchemaBase_t const** _result);

/// Returns the SdfSpecType specifying the spec type this object
/// represents.
int sdf_VariantSetSpec_GetSpecType(sdf_VariantSetSpec_t const* _this, int* _result);

/// Returns true if this object is invalid or expired.
int sdf_VariantSetSpec_IsDormant(sdf_VariantSetSpec_t const* _this, bool* _result);

/// Returns the layer that this object belongs to.
int sdf_VariantSetSpec_GetLayer(sdf_VariantSetSpec_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the scene path of this object.
int sdf_VariantSetSpec_GetPath(sdf_VariantSetSpec_t const* _this, sdf_Path_t* _result);

/// Returns whether this object's layer can be edited.
int sdf_VariantSetSpec_PermissionToEdit(sdf_VariantSetSpec_t const* _this, bool* _result);

/// Returns the full list of info keys currently set on this object.
/// \note This does not include fields that represent names of children.
int sdf_VariantSetSpec_ListInfoKeys(sdf_VariantSetSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns the list of metadata info keys for this object.
/// 
/// This is not the complete list of keys, it is only those that
/// should be considered to be metadata by inspectors or other 
/// presentation UI.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSetSpec_GetMetaDataInfoKeys(sdf_VariantSetSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns this metadata key's displayGroup.
int sdf_VariantSetSpec_GetMetaDataDisplayGroup(sdf_VariantSetSpec_t const* _this, tf_Token_t const* key, tf_Token_t* _result);

/// Gets the value for the given metadata key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSetSpec_GetInfo(sdf_VariantSetSpec_t const* _this, tf_Token_t const* key, vt_Value_t* _result);

/// Sets the value for the given metadata key.
/// 
/// It is an error to pass a value that is not the correct type for
/// that given key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSetSpec_SetInfo(sdf_VariantSetSpec_t* _this, tf_Token_t const* key, vt_Value_t const* value);

/// Sets the value for \p entryKey to \p value within the dictionary 
///        with the given metadata key \p dictionaryKey
int sdf_VariantSetSpec_SetInfoDictionaryValue(sdf_VariantSetSpec_t* _this, tf_Token_t const* dictionaryKey, tf_Token_t const* entryKey, vt_Value_t const* value);

/// Returns whether there is a setting for the scene spec info 
/// with the given key.
/// 
/// When asked for a value for one of its scene spec info, a valid value
/// will always be returned. But if this API returns \b false for a scene
/// spec info, the value of that info will be the defined default value.
/// 
/// When dealing with a composedLayer, it is not necessary to worry about
/// whether a scene spec info "has a value" because the composed layer will
/// always have a valid value, even if it is the default.
/// 
/// A spec may or may not have an expressed value for some of its
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSetSpec_HasInfo(sdf_VariantSetSpec_t const* _this, tf_Token_t const* key, bool* _result);

/// Clears the value for scene spec info with the given \a key.
/// 
/// After calling this, HasInfo() will return \b false.
/// To make HasInfo() return \b true just set a value for that
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSetSpec_ClearInfo(sdf_VariantSetSpec_t* _this, tf_Token_t const* key);

/// Returns the data type for the info with the given \a key.
int sdf_VariantSetSpec_GetTypeForInfo(sdf_VariantSetSpec_t const* _this, tf_Token_t const* key, tf_Type_t* _result);

/// Returns the fallback for the info with the given \a key.
int sdf_VariantSetSpec_GetFallbackForInfo(sdf_VariantSetSpec_t const* _this, tf_Token_t const* key, vt_Value_t const** _result);

/// Returns whether this object has no significant data.
/// 
/// "Significant" here means that the object contributes opinions to
/// a scene. If this spec has any child scenegraph objects (e.g.,
/// prim or property spec), it will be considered significant even if
/// those child objects are not.
/// However, if \p ignoreChildren is \c true, these child objects
/// will be ignored. 
int sdf_VariantSetSpec_IsInert(sdf_VariantSetSpec_t const* _this, bool ignoreChildren, bool* _result);

/// Returns all fields with values.
int sdf_VariantSetSpec_ListFields(sdf_VariantSetSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns \c true if the spec has a non-empty value with field
/// name \p name.
int sdf_VariantSetSpec_HasField(sdf_VariantSetSpec_t const* _this, tf_Token_t const* name, bool* _result);

/// Returns a field value by name.
int sdf_VariantSetSpec_GetField(sdf_VariantSetSpec_t const* _this, tf_Token_t const* name, vt_Value_t* _result);

/// Sets a field value as a boxed VtValue.
int sdf_VariantSetSpec_SetField(sdf_VariantSetSpec_t* _this, tf_Token_t const* name, vt_Value_t const* value, bool* _result);

/// \name Comparison operators
/// @{
int sdf_VariantSetSpec_op_eq(sdf_VariantSetSpec_t const* _this, sdf_Spec_t const* rhs, bool* _result);

int sdf_VariantSetSpec_dtor(sdf_VariantSetSpec_t* _this);

int sdf_VariantSetsProxy_dtor(sdf_VariantSetsProxy_t* _this);

/// Returns the name of this variant.
int sdf_VariantSpec_GetName(sdf_VariantSpec_t const* _this, std_String_t* _result);

/// Returns the name of this variant.
int sdf_VariantSpec_GetNameToken(sdf_VariantSpec_t const* _this, tf_Token_t* _result);

/// Return the SdfVariantSetSpec that owns this variant.
int sdf_VariantSpec_GetOwner(sdf_VariantSpec_t const* _this, sdf_VariantSetSpecHandle_t* _result);

/// Get the prim spec owned by this variant.
int sdf_VariantSpec_GetPrimSpec(sdf_VariantSpec_t const* _this, sdf_PrimSpecHandle_t* _result);

/// Returns the nested variant sets.
/// 
/// The result maps variant set names to variant sets.  Variant sets
/// may be removed through the proxy.
int sdf_VariantSpec_GetVariantSets(sdf_VariantSpec_t const* _this, sdf_VariantSetsProxy_t* _result);

/// Returns list of variant names for the given variant set.
int sdf_VariantSpec_GetVariantNames(sdf_VariantSpec_t const* _this, std_String_t const* name, std_StringVector_t* _result);

/// Returns the SdfSchemaBase for the layer that owns this spec.
int sdf_VariantSpec_GetSchema(sdf_VariantSpec_t const* _this, sdf_SchemaBase_t const** _result);

/// Returns the SdfSpecType specifying the spec type this object
/// represents.
int sdf_VariantSpec_GetSpecType(sdf_VariantSpec_t const* _this, int* _result);

/// Returns true if this object is invalid or expired.
int sdf_VariantSpec_IsDormant(sdf_VariantSpec_t const* _this, bool* _result);

/// Returns the layer that this object belongs to.
int sdf_VariantSpec_GetLayer(sdf_VariantSpec_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the scene path of this object.
int sdf_VariantSpec_GetPath(sdf_VariantSpec_t const* _this, sdf_Path_t* _result);

/// Returns whether this object's layer can be edited.
int sdf_VariantSpec_PermissionToEdit(sdf_VariantSpec_t const* _this, bool* _result);

/// Returns the full list of info keys currently set on this object.
/// \note This does not include fields that represent names of children.
int sdf_VariantSpec_ListInfoKeys(sdf_VariantSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns the list of metadata info keys for this object.
/// 
/// This is not the complete list of keys, it is only those that
/// should be considered to be metadata by inspectors or other 
/// presentation UI.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSpec_GetMetaDataInfoKeys(sdf_VariantSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns this metadata key's displayGroup.
int sdf_VariantSpec_GetMetaDataDisplayGroup(sdf_VariantSpec_t const* _this, tf_Token_t const* key, tf_Token_t* _result);

/// Gets the value for the given metadata key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSpec_GetInfo(sdf_VariantSpec_t const* _this, tf_Token_t const* key, vt_Value_t* _result);

/// Sets the value for the given metadata key.
/// 
/// It is an error to pass a value that is not the correct type for
/// that given key.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSpec_SetInfo(sdf_VariantSpec_t* _this, tf_Token_t const* key, vt_Value_t const* value);

/// Sets the value for \p entryKey to \p value within the dictionary 
///        with the given metadata key \p dictionaryKey
int sdf_VariantSpec_SetInfoDictionaryValue(sdf_VariantSpec_t* _this, tf_Token_t const* dictionaryKey, tf_Token_t const* entryKey, vt_Value_t const* value);

/// Returns whether there is a setting for the scene spec info 
/// with the given key.
/// 
/// When asked for a value for one of its scene spec info, a valid value
/// will always be returned. But if this API returns \b false for a scene
/// spec info, the value of that info will be the defined default value.
/// 
/// When dealing with a composedLayer, it is not necessary to worry about
/// whether a scene spec info "has a value" because the composed layer will
/// always have a valid value, even if it is the default.
/// 
/// A spec may or may not have an expressed value for some of its
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSpec_HasInfo(sdf_VariantSpec_t const* _this, tf_Token_t const* key, bool* _result);

/// Clears the value for scene spec info with the given \a key.
/// 
/// After calling this, HasInfo() will return \b false.
/// To make HasInfo() return \b true just set a value for that
/// scene spec info.
/// 
/// This is interim API which is likely to change.  Only editors with
/// an immediate specific need (like the Inspector) should use this API.
int sdf_VariantSpec_ClearInfo(sdf_VariantSpec_t* _this, tf_Token_t const* key);

/// Returns the data type for the info with the given \a key.
int sdf_VariantSpec_GetTypeForInfo(sdf_VariantSpec_t const* _this, tf_Token_t const* key, tf_Type_t* _result);

/// Returns the fallback for the info with the given \a key.
int sdf_VariantSpec_GetFallbackForInfo(sdf_VariantSpec_t const* _this, tf_Token_t const* key, vt_Value_t const** _result);

/// Returns whether this object has no significant data.
/// 
/// "Significant" here means that the object contributes opinions to
/// a scene. If this spec has any child scenegraph objects (e.g.,
/// prim or property spec), it will be considered significant even if
/// those child objects are not.
/// However, if \p ignoreChildren is \c true, these child objects
/// will be ignored. 
int sdf_VariantSpec_IsInert(sdf_VariantSpec_t const* _this, bool ignoreChildren, bool* _result);

/// Returns all fields with values.
int sdf_VariantSpec_ListFields(sdf_VariantSpec_t const* _this, tf_TokenVector_t* _result);

/// Returns \c true if the spec has a non-empty value with field
/// name \p name.
int sdf_VariantSpec_HasField(sdf_VariantSpec_t const* _this, tf_Token_t const* name, bool* _result);

/// Returns a field value by name.
int sdf_VariantSpec_GetField(sdf_VariantSpec_t const* _this, tf_Token_t const* name, vt_Value_t* _result);

/// Sets a field value as a boxed VtValue.
int sdf_VariantSpec_SetField(sdf_VariantSpec_t* _this, tf_Token_t const* name, vt_Value_t const* value, bool* _result);

/// \name Comparison operators
/// @{
int sdf_VariantSpec_op_eq(sdf_VariantSpec_t const* _this, sdf_Spec_t const* rhs, bool* _result);

int sdf_VariantSpec_dtor(sdf_VariantSpec_t* _this);

int sdf_VariantSetSpecHandle_dtor(sdf_VariantSetSpecHandle_t* _this);

int sdf_VariantSpecHandle_dtor(sdf_VariantSpecHandle_t* _this);

int sdf_VariantSpecHandleVector_data(sdf_VariantSpecHandleVector_t* _this, sdf_VariantSpecHandle_t** _result);

int sdf_VariantSpecHandleVector_data_const(sdf_VariantSpecHandleVector_t const* _this, sdf_VariantSpecHandle_t const** _result);

int sdf_VariantSpecHandleVector_empty(sdf_VariantSpecHandleVector_t const* _this, bool* _result);

int sdf_VariantSpecHandleVector_size(sdf_VariantSpecHandleVector_t const* _this, size_t* _result);

int sdf_VariantSpecHandleVector_max_size(sdf_VariantSpecHandleVector_t const* _this, size_t* _result);

int sdf_VariantSpecHandleVector_reserve(sdf_VariantSpecHandleVector_t* _this, size_t const _Newcapacity);

int sdf_VariantSpecHandleVector_capacity(sdf_VariantSpecHandleVector_t const* _this, size_t* _result);

int sdf_VariantSpecHandleVector_clear(sdf_VariantSpecHandleVector_t* _this);

int sdf_VariantSpecHandleVector_push_back(sdf_VariantSpecHandleVector_t* _this, sdf_VariantSpecHandle_t const* _Val);

int sdf_VariantSpecHandleVector_pop_back(sdf_VariantSpecHandleVector_t* _this);

int sdf_VariantSpecHandleVector_resize(sdf_VariantSpecHandleVector_t* _this, size_t const _Newsize);

int sdf_VariantSpecHandleVector_resize_with(sdf_VariantSpecHandleVector_t* _this, size_t const _Newsize, sdf_VariantSpecHandle_t const* _Val);

int sdf_VariantSpecHandleVector_op_index(sdf_VariantSpecHandleVector_t const* _this, size_t const _Pos, sdf_VariantSpecHandle_t const** _result);

int sdf_VariantSpecHandleVector_default(sdf_VariantSpecHandleVector_t** _result);

int sdf_VariantSpecHandleVector_dtor(sdf_VariantSpecHandleVector_t* _this);

int sdf_VariantView_dtor(sdf_VariantView_t* _this);

int sdf_AssetPath_GetAssetPath(sdf_AssetPath_t const* path, char const** _result);

int sdf_AssetPath_GetResolvedPath(sdf_AssetPath_t const* path, char const** _result);

int sdf_NamespaceEdit_get_current_path(sdf_NamespaceEdit_t const* edit, sdf_Path_t const** _result);

int sdf_NamespaceEdit_get_new_path(sdf_NamespaceEdit_t const* edit, sdf_Path_t const** _result);

int sdf_NamespaceEdit_get_index(sdf_NamespaceEdit_t const* edit, int* _result);

int sdf_NamespaceEditDetail_get_edit(sdf_NamespaceEditDetail_t const* detail, sdf_NamespaceEdit_t const** _result);

int sdf_NamespaceEditDetail_get_result(sdf_NamespaceEditDetail_t const* detail, int* _result);

int sdf_NamespaceEditDetail_get_reason(sdf_NamespaceEditDetail_t const* detail, char const** _result);

int sdf_PathExpression_from_string(char const* expr, char const* parseContext, sdf_PathExpression_t** _result);

int sdf_Payload_from_asset_path(char const* assetPath, sdf_Payload_t** _result);

int sdf_Payload_from_asset_path_and_prim_path(char const* assetPath, sdf_Path_t const* primPath, sdf_Payload_t** _result);

int sdf_Payload_from_asset_path_and_prim_path_and_layer_offset(char const* assetPath, sdf_Path_t const* primPath, sdf_LayerOffset_t const* layerOffset, sdf_Payload_t** _result);

int sdf_Reference_from_asset_path(char const* assetPath, sdf_Reference_t** _result);

int sdf_Reference_from_asset_path_and_prim_path(char const* assetPath, sdf_Path_t const* primPath, sdf_Reference_t** _result);

int sdf_Reference_from_asset_path_and_prim_path_and_layer_offset(char const* assetPath, sdf_Path_t const* primPath, sdf_LayerOffset_t const* layerOffset, sdf_Reference_t** _result);

int sdf_Reference_from_asset_path_and_prim_path_and_layer_offset_and_custom_data(char const* assetPath, sdf_Path_t const* primPath, sdf_LayerOffset_t const* layerOffset, vt_Dictionary_t const* customData, sdf_Reference_t** _result);

int sdf_ValueTypeName_GetCPPTypeName(sdf_ValueTypeName_t const* vtn, char const** _result);

int std_String_c_str(std_String_t const* _this, char const** _result);

int std_String_from_char_ptr(char const* param00, std_String_t** _result);

int std_String_dtor(std_String_t* _this);

int std_StringVector_data(std_StringVector_t* _this, std_String_t** _result);

int std_StringVector_data_const(std_StringVector_t const* _this, std_String_t const** _result);

int std_StringVector_empty(std_StringVector_t const* _this, bool* _result);

int std_StringVector_size(std_StringVector_t const* _this, size_t* _result);

int std_StringVector_max_size(std_StringVector_t const* _this, size_t* _result);

int std_StringVector_reserve(std_StringVector_t* _this, size_t const _Newcapacity);

int std_StringVector_capacity(std_StringVector_t const* _this, size_t* _result);

int std_StringVector_clear(std_StringVector_t* _this);

int std_StringVector_push_back(std_StringVector_t* _this, std_String_t const* _Val);

int std_StringVector_pop_back(std_StringVector_t* _this);

int std_StringVector_resize(std_StringVector_t* _this, size_t const _Newsize);

int std_StringVector_resize_with(std_StringVector_t* _this, size_t const _Newsize, std_String_t const* _Val);

int std_StringVector_op_index(std_StringVector_t const* _this, size_t const _Pos, std_String_t const** _result);

int std_StringVector_default(std_StringVector_t** _result);

int std_StringVector_dtor(std_StringVector_t* _this);

int std_StringSet_dtor(std_StringSet_t* _this);

int std_DoubleVector_data(std_DoubleVector_t* _this, double** _result);

int std_DoubleVector_data_const(std_DoubleVector_t const* _this, double const** _result);

int std_DoubleVector_empty(std_DoubleVector_t const* _this, bool* _result);

int std_DoubleVector_size(std_DoubleVector_t const* _this, size_t* _result);

int std_DoubleVector_max_size(std_DoubleVector_t const* _this, size_t* _result);

int std_DoubleVector_reserve(std_DoubleVector_t* _this, size_t const _Newcapacity);

int std_DoubleVector_capacity(std_DoubleVector_t const* _this, size_t* _result);

int std_DoubleVector_clear(std_DoubleVector_t* _this);

int std_DoubleVector_push_back(std_DoubleVector_t* _this, double const* _Val);

int std_DoubleVector_pop_back(std_DoubleVector_t* _this);

int std_DoubleVector_resize(std_DoubleVector_t* _this, size_t const _Newsize);

int std_DoubleVector_resize_with(std_DoubleVector_t* _this, size_t const _Newsize, double const* _Val);

int std_DoubleVector_op_index(std_DoubleVector_t const* _this, size_t const _Pos, double* _result);

int std_DoubleVector_default(std_DoubleVector_t** _result);

int std_DoubleVector_dtor(std_DoubleVector_t* _this);

int std_DoubleSet_dtor(std_DoubleSet_t* _this);

/// Returns the integral value of the enum value.
int tf_Enum_GetValueAsInt(tf_Enum_t const* _this, int* _result);

/// Returns the name associated with an enumerated value.
/// 
/// If there is no such name registered, an empty string is returned.
int tf_Enum_GetName(tf_Enum_t* val, std_String_t* _result);

/// Returns the display name for an enumerated value.
/// 
/// This returns a user interface-suitable string for the given enumerated
/// value.
int tf_Enum_GetDisplayName(tf_Enum_t* val, std_String_t* _result);

/// Returns the fully-qualified name for an enumerated value.
/// 
/// This returns a fully-qualified enumerated value name (e.g.,
/// \c "Season::WINTER") associated with the given value. If there is no
/// such name registered, an empty string is returned.
int tf_Enum_GetFullName(tf_Enum_t* val, std_String_t* _result);

int tf_Enum_new(tf_Enum_t** _result);

int tf_Enum_dtor(tf_Enum_t* _this);

/// Copy assignment.
int tf_Token_op_assign(tf_Token_t* _this, tf_Token_t const* rhs, tf_Token_t** _result);

/// Return the text that this token represents.
/// 
/// \note The returned pointer value is not valid after this TfToken
/// object has been destroyed.
int tf_Token_GetText(tf_Token_t const* _this, char const** _result);

int tf_Token_new(tf_Token_t** _result);

int tf_Token_dtor(tf_Token_t* _this);

int tf_Type_dtor(tf_Type_t* _this);

int tf_TokenVector_data(tf_TokenVector_t* _this, tf_Token_t** _result);

int tf_TokenVector_data_const(tf_TokenVector_t const* _this, tf_Token_t const** _result);

int tf_TokenVector_empty(tf_TokenVector_t const* _this, bool* _result);

int tf_TokenVector_size(tf_TokenVector_t const* _this, size_t* _result);

int tf_TokenVector_max_size(tf_TokenVector_t const* _this, size_t* _result);

int tf_TokenVector_reserve(tf_TokenVector_t* _this, size_t const _Newcapacity);

int tf_TokenVector_capacity(tf_TokenVector_t const* _this, size_t* _result);

int tf_TokenVector_clear(tf_TokenVector_t* _this);

int tf_TokenVector_push_back(tf_TokenVector_t* _this, tf_Token_t const* _Val);

int tf_TokenVector_pop_back(tf_TokenVector_t* _this);

int tf_TokenVector_resize(tf_TokenVector_t* _this, size_t const _Newsize);

int tf_TokenVector_resize_with(tf_TokenVector_t* _this, size_t const _Newsize, tf_Token_t const* _Val);

int tf_TokenVector_op_index(tf_TokenVector_t const* _this, size_t const _Pos, tf_Token_t const** _result);

int tf_TokenVector_default(tf_TokenVector_t** _result);

int tf_TokenVector_dtor(tf_TokenVector_t* _this);

/// Linear curves interpolate linearly between two vertices.  
/// Cubic curves use a basis matrix with four vertices to interpolate a segment.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token type = "cubic"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | linear, cubic |
int usdGeom_BasisCurves_GetTypeAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetTypeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateTypeAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The basis specifies the vstep and matrix used for cubic 
/// interpolation.  \note The 'hermite' and 'power' tokens have been
/// removed. We've provided UsdGeomHermiteCurves
/// as an alternative for the 'hermite' basis.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token basis = "bezier"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | bezier, bspline, catmullRom |
int usdGeom_BasisCurves_GetBasisAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetBasisAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateBasisAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If wrap is set to periodic, the curve when rendered will 
/// repeat the initial vertices (dependent on the vstep) to close the
/// curve. If wrap is set to 'pinned', phantom points may be created
/// to ensure that the curve interpolation starts at P[0] and ends at P[n-1].
/// 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token wrap = "nonperiodic"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | nonperiodic, periodic, pinned |
int usdGeom_BasisCurves_GetWrapAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetWrapAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateWrapAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Curves-derived primitives can represent multiple distinct,
/// potentially disconnected curves.  The length of 'curveVertexCounts'
/// gives the number of such curves, and each element describes the
/// number of vertices in the corresponding curve
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] curveVertexCounts` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_BasisCurves_GetCurveVertexCountsAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetCurveVertexCountsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateCurveVertexCountsAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provides width specification for the curves, whose application
/// will depend on whether the curve is oriented (normals are defined for
/// it), in which case widths are "ribbon width", or unoriented, in which
/// case widths are cylinder width.  'widths' is not a generic Primvar,
/// but the number of elements in this attribute will be determined by
/// its 'interpolation'.  See \ref SetWidthsInterpolation() .  If 'widths'
/// and 'primvars:widths' are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] widths` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_BasisCurves_GetWidthsAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetWidthsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateWidthsAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// Although 'widths' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which means a width value is specified at the end of each curve segment.
int usdGeom_BasisCurves_GetWidthsInterpolation(usdGeom_BasisCurves_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the widths attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetWidthsInterpolation()
int usdGeom_BasisCurves_SetWidthsInterpolation(usdGeom_BasisCurves_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Returns the number of curves as defined by the size of the
/// _curveVertexCounts_ array at _timeCode_.
/// 
/// \snippetdoc snippets.dox GetCount
/// \sa GetCurveVertexCountsAttr()
int usdGeom_BasisCurves_GetCurveCount(usdGeom_BasisCurves_t const* _this, usd_TimeCode_t timeCode, size_t* _result);

/// The primary geometry attribute for all PointBased
/// primitives, describes points in (local) space.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `point3f[] points` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Point3fArray |
int usdGeom_BasisCurves_GetPointsAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetPointsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreatePointsAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'velocities' should be used by renderers to 
/// 
/// compute positions between samples for the 'points' attribute, rather
/// than interpolating between neighboring 'points' samples.  This is the
/// only reasonable means of computing motion blur for topologically
/// varying PointBased primitives.  It follows that the length of each
/// 'velocities' sample must match the length of the corresponding
/// 'points' sample.  Velocity is measured in position units per second,
/// as per most simulation software. To convert to position units per
/// UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeom_VelocityInterpolation .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] velocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_BasisCurves_GetVelocitiesAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateVelocitiesAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'accelerations' should be used with
/// velocities to compute positions between samples for the 'points'
/// attribute rather than interpolating between neighboring 'points'
/// samples. Acceleration is measured in position units per second-squared.
/// To convert to position units per squared UsdTimeCode, divide by the
/// square of UsdStage::GetTimeCodesPerSecond().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] accelerations` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_BasisCurves_GetAccelerationsAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetAccelerationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateAccelerationsAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provide an object-space orientation for individual points, 
/// which, depending on subclass, may define a surface, curve, or free 
/// points.  Note that 'normals' should not be authored on any Mesh that
/// is subdivided, since the subdivision algorithm will define its own
/// normals. 'normals' is not a generic primvar, but the number of elements
/// in this attribute will be determined by its 'interpolation'.  See
/// \ref SetNormalsInterpolation() . If 'normals' and 'primvars:normals'
/// are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `normal3f[] normals` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Normal3fArray |
int usdGeom_BasisCurves_GetNormalsAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetNormalsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateNormalsAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// Although 'normals' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which will generally produce smooth shading on a polygonal mesh.
/// To achieve partial or fully faceted shading of a polygonal mesh
/// with normals, one should use UsdGeomTokens->faceVarying or
/// UsdGeomTokens->uniform interpolation.
int usdGeom_BasisCurves_GetNormalsInterpolation(usdGeom_BasisCurves_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdGeomPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the normals attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetNormalsInterpolation()
int usdGeom_BasisCurves_SetNormalsInterpolation(usdGeom_BasisCurves_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Compute points given the positions, velocities and accelerations
/// at \p time. 
/// 
/// This will return \c false and leave \p points untouched if:
/// - \p points is NULL
/// - one of \p time and \p baseTime is numeric and the other is
///   UsdTimeCode::Default() (they must either both be numeric or both be
///   default)
/// - there is no authored points attribute
/// 
/// If there is no error, we will return \c true and \p points will contain
/// the computed points.
/// 
/// \param points - the out parameter for the new points.  Its size
///                 will depend on the authored data.
/// \param time - UsdTimeCode at which we want to evaluate the transforms
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em accelerations are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
int usdGeom_BasisCurves_ComputePointsAtTime(usdGeom_BasisCurves_t const* _this, gf_Vec3fArray_t* points, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, bool* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_BasisCurves_GetDisplayColorAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateDisplayColorAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_BasisCurves_GetDisplayOpacityAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateDisplayOpacityAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_BasisCurves_GetDoubleSidedAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateDoubleSidedAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_BasisCurves_GetOrientationAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateOrientationAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_BasisCurves_GetDisplayColorPrimvar(usdGeom_BasisCurves_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_BasisCurves_CreateDisplayColorPrimvar(usdGeom_BasisCurves_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_BasisCurves_GetExtentAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateExtentAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_BasisCurves_GetXformOpOrderAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_BasisCurves_AddXformOp(usdGeom_BasisCurves_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_BasisCurves_AddTranslateOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_BasisCurves_AddScaleOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_BasisCurves_AddRotateXOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_BasisCurves_AddRotateYOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_BasisCurves_AddRotateZOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_BasisCurves_AddRotateXYZOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_BasisCurves_AddRotateXZYOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_BasisCurves_AddRotateYXZOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_BasisCurves_AddRotateYZXOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_BasisCurves_AddRotateZXYOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_BasisCurves_AddRotateZYXOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_BasisCurves_AddOrientOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_BasisCurves_AddTransformOp(usdGeom_BasisCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_BasisCurves_SetResetXformStack(usdGeom_BasisCurves_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_BasisCurves_SetXformOpOrder(usdGeom_BasisCurves_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_BasisCurves_GetOrderedXformOps(usdGeom_BasisCurves_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_BasisCurves_ClearXformOpOrder(usdGeom_BasisCurves_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_BasisCurves_MakeMatrixXform(usdGeom_BasisCurves_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_BasisCurves_TransformMightBeTimeVarying(usdGeom_BasisCurves_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_BasisCurves_TransformMightBeTimeVarying_using(usdGeom_BasisCurves_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_BasisCurves_GetTimeSamples(usdGeom_BasisCurves_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_BasisCurves_GetTimeSamplesInInterval(usdGeom_BasisCurves_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_BasisCurves_GetLocalTransformation(usdGeom_BasisCurves_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_BasisCurves_GetLocalTransformation_with_ops(usdGeom_BasisCurves_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_BasisCurves_GetVisibilityAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreateVisibilityAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_BasisCurves_GetPurposeAttr(usdGeom_BasisCurves_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_BasisCurves_CreatePurposeAttr(usdGeom_BasisCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_BasisCurves_GetProxyPrimRel(usdGeom_BasisCurves_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_BasisCurves_CreateProxyPrimRel(usdGeom_BasisCurves_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_BasisCurves_MakeVisible(usdGeom_BasisCurves_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_BasisCurves_MakeInvisible(usdGeom_BasisCurves_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_BasisCurves_ComputeVisibility(usdGeom_BasisCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_BasisCurves_GetPurposeVisibilityAttr(usdGeom_BasisCurves_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_BasisCurves_ComputePurposeInfo(usdGeom_BasisCurves_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_BasisCurves_ComputePurposeInfo_given_parent(usdGeom_BasisCurves_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_BasisCurves_ComputePurpose(usdGeom_BasisCurves_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_BasisCurves_ComputeProxyPrim(usdGeom_BasisCurves_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_BasisCurves_SetProxyPrim(usdGeom_BasisCurves_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_BasisCurves_ComputeWorldBound(usdGeom_BasisCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_BasisCurves_ComputeLocalBound(usdGeom_BasisCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_BasisCurves_ComputeUntransformedBound(usdGeom_BasisCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_BasisCurves_ComputeLocalToWorldTransform(usdGeom_BasisCurves_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_BasisCurves_ComputeParentToWorldTransform(usdGeom_BasisCurves_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_BasisCurves_IsConcrete(usdGeom_BasisCurves_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_BasisCurves_IsTyped(usdGeom_BasisCurves_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_BasisCurves_IsAPISchema(usdGeom_BasisCurves_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_BasisCurves_IsAppliedAPISchema(usdGeom_BasisCurves_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_BasisCurves_IsMultipleApplyAPISchema(usdGeom_BasisCurves_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_BasisCurves_GetSchemaKind(usdGeom_BasisCurves_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_BasisCurves_GetPrim(usdGeom_BasisCurves_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_BasisCurves_GetPath(usdGeom_BasisCurves_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_BasisCurves_GetSchemaClassPrimDefinition(usdGeom_BasisCurves_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_BasisCurves_new(usd_Prim_t const* param00, usdGeom_BasisCurves_t** _result);

int usdGeom_BasisCurves_dtor(usdGeom_BasisCurves_t* _this);

/// Compute the bound of the given prim in world space, leveraging any
/// pre-existing, cached bounds.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// Error handling note: No checking of \p prim validity is performed.  If
/// \p prim is invalid, this method will abort the program; therefore it is
/// the client's responsibility to ensure \p prim is valid.
int usdGeom_BBoxCache_ComputeWorldBound(usdGeom_BBoxCache_t* _this, usd_Prim_t const* prim, gf_BBox3d_t* _result);

/// Compute the bound of the given prim in the space of an ancestor prim,
/// \p relativeToAncestorPrim, leveraging any pre-existing cached bounds.
/// 
/// The computed bound excludes the local transform at
/// \p relativeToAncestorPrim. The computed bound may be incorrect if
/// \p relativeToAncestorPrim is not an ancestor of \p prim.
int usdGeom_BBoxCache_ComputeRelativeBound(usdGeom_BBoxCache_t* _this, usd_Prim_t const* prim, usd_Prim_t const* relativeToAncestorPrim, gf_BBox3d_t* _result);

/// Computes the oriented bounding box of the given prim, leveraging any
/// pre-existing, cached bounds.
/// 
/// The computed bound includes the transform authored on the prim itself,
/// but does not include any ancestor transforms (it does not include the
/// local-to-world transform).
/// 
/// See ComputeWorldBound() for notes on performance and error handling.
int usdGeom_BBoxCache_ComputeLocalBound(usdGeom_BBoxCache_t* _this, usd_Prim_t const* prim, gf_BBox3d_t* _result);

/// Computes the bound of the prim's children leveraging any pre-existing,
/// cached bounds, but does not include the transform (if any) authored on
/// the prim itself.
/// 
/// \b IMPORTANT: while the BBox does not contain the local transformation,
/// in general it may still contain a non-identity transformation matrix to
/// put the bounds in the correct space. Therefore, to obtain the correct
/// axis-aligned bounding box, the client must call ComputeAlignedRange().
/// 
/// See ComputeWorldBound() for notes on performance and error handling.
int usdGeom_BBoxCache_ComputeUntransformedBound(usdGeom_BBoxCache_t* _this, usd_Prim_t const* prim, gf_BBox3d_t* _result);

/// Compute the bound of the given point instance in world space.
int usdGeom_BBoxCache_ComputePointInstanceWorldBound(usdGeom_BBoxCache_t* _this, usdGeom_PointInstancer_t const* instancer, int64_t instanceId, gf_BBox3d_t* _result);

/// Compute the bound of the given point instances in world space.
/// 
/// The bounds of each instance is computed and then transformed to world
/// space.  The \p result pointer must point to \p numIds GfBBox3d instances
/// to be filled.
int usdGeom_BBoxCache_ComputePointInstanceWorldBounds(usdGeom_BBoxCache_t* _this, usdGeom_PointInstancer_t const* instancer, int64_t const* instanceIdBegin, size_t numIds, gf_BBox3d_t* result, bool* _result);

/// Compute the bounds of the given point instances in the space of an
/// ancestor prim \p relativeToAncestorPrim.  Write the results to
/// \p result.
/// 
/// The computed bound excludes the local transform at
/// \p relativeToAncestorPrim. The computed bound may be incorrect if
/// \p relativeToAncestorPrim is not an ancestor of \p prim.
/// 
/// The \p result pointer must point to \p numIds GfBBox3d instances to be
/// filled.
int usdGeom_BBoxCache_ComputePointInstanceRelativeBounds(usdGeom_BBoxCache_t* _this, usdGeom_PointInstancer_t const* instancer, int64_t const* instanceIdBegin, size_t numIds, usd_Prim_t const* relativeToAncestorPrim, gf_BBox3d_t* result, bool* _result);

/// Compute the bound of the given point instance in the space of an
/// ancestor prim \p relativeToAncestorPrim.
int usdGeom_BBoxCache_ComputePointInstanceRelativeBound(usdGeom_BBoxCache_t* _this, usdGeom_PointInstancer_t const* instancer, int64_t instanceId, usd_Prim_t const* relativeToAncestorPrim, gf_BBox3d_t* _result);

/// Compute the oriented bounding boxes of the given point instances.
/// 
/// The computed bounds include the transform authored on the instancer
/// itself, but does not include any ancestor transforms (it does not
/// include the local-to-world transform).
/// 
/// The \p result pointer must point to \p numIds GfBBox3d instances to be
/// filled.
int usdGeom_BBoxCache_ComputePointInstanceLocalBounds(usdGeom_BBoxCache_t* _this, usdGeom_PointInstancer_t const* instancer, int64_t const* instanceIdBegin, size_t numIds, gf_BBox3d_t* result, bool* _result);

/// Compute the oriented bounding boxes of the given point instances.
int usdGeom_BBoxCache_ComputePointInstanceLocalBound(usdGeom_BBoxCache_t* _this, usdGeom_PointInstancer_t const* instancer, int64_t instanceId, gf_BBox3d_t* _result);

/// Computes the bound of the given point instances, but does not include
/// the transform (if any) authored on the instancer itself.
/// 
/// \b IMPORTANT: while the BBox does not contain the local transformation,
/// in general it may still contain a non-identity transformation matrix to
/// put the bounds in the correct space. Therefore, to obtain the correct
/// axis-aligned bounding box, the client must call ComputeAlignedRange().
/// 
/// The \p result pointer must point to \p numIds GfBBox3d instances to be
/// filled.
int usdGeom_BBoxCache_ComputePointInstanceUntransformedBounds(usdGeom_BBoxCache_t* _this, usdGeom_PointInstancer_t const* instancer, int64_t const* instanceIdBegin, size_t numIds, gf_BBox3d_t* result, bool* _result);

/// Computes the bound of the given point instances, but does not include
/// the instancer's transform.
int usdGeom_BBoxCache_ComputePointInstanceUntransformedBound(usdGeom_BBoxCache_t* _this, usdGeom_PointInstancer_t const* instancer, int64_t instanceId, gf_BBox3d_t* _result);

/// Clears all pre-cached values.
int usdGeom_BBoxCache_Clear(usdGeom_BBoxCache_t* _this);

/// Indicate the set of \p includedPurposes to use when resolving child
/// bounds. Each child's purpose must match one of the elements of this set
/// to be included in the computation; if it does not, child is excluded.
/// 
/// Note the use of *child* in the docs above, purpose is ignored for the
/// prim for whose bounds are directly queried.
/// 
/// Changing this value <b>does not invalidate existing caches</b>.
int usdGeom_BBoxCache_SetIncludedPurposes(usdGeom_BBoxCache_t* _this, tf_TokenVector_t const* includedPurposes);

/// Get the current set of included purposes.
int usdGeom_BBoxCache_GetIncludedPurposes(usdGeom_BBoxCache_t* _this, tf_TokenVector_t const** _result);

/// Returns whether authored extent hints are used to compute
/// bounding boxes.
int usdGeom_BBoxCache_GetUseExtentsHint(usdGeom_BBoxCache_t const* _this, bool* _result);

/// Returns whether prim visibility should be ignored when computing
/// bounding boxes.
int usdGeom_BBoxCache_GetIgnoreVisibility(usdGeom_BBoxCache_t const* _this, bool* _result);

/// Use the new \p time when computing values and may clear any existing
/// values cached for the previous time. Setting \p time to the current time
/// is a no-op.
int usdGeom_BBoxCache_SetTime(usdGeom_BBoxCache_t* _this, usd_TimeCode_t time);

/// Get the current time from which this cache is reading values.
int usdGeom_BBoxCache_GetTime(usdGeom_BBoxCache_t const* _this, usd_TimeCode_t* _result);

/// Set the base time value for this bbox cache.  This value is used only
/// when computing bboxes for point instancer instances (see
/// ComputePointInstanceWorldBounds(), for example).  See
/// UsdGeomPointInstancer::ComputeExtentAtTime() for more information.  If
/// unset, the bbox cache uses its time (GetTime() / SetTime()) for this
/// value.
/// 
/// Note that setting the base time does not invalidate any cache entries.
int usdGeom_BBoxCache_SetBaseTime(usdGeom_BBoxCache_t* _this, usd_TimeCode_t baseTime);

/// Return the base time if set, otherwise GetTime().  Use HasBaseTime() to
/// observe if a base time has been set.
int usdGeom_BBoxCache_GetBaseTime(usdGeom_BBoxCache_t const* _this, usd_TimeCode_t* _result);

/// Clear this cache's baseTime if one has been set.  After calling this,
/// the cache will use its time as the baseTime value.
int usdGeom_BBoxCache_ClearBaseTime(usdGeom_BBoxCache_t* _this);

/// Return true if this cache has a baseTime that's been explicitly set,
/// false otherwise.
int usdGeom_BBoxCache_HasBaseTime(usdGeom_BBoxCache_t const* _this, bool* _result);

int usdGeom_BBoxCache_ctor(usd_TimeCode_t time, tf_TokenVector_t* includedPurposes, bool useExtentsHint, bool ignoreVisibility, usdGeom_BBoxCache_t** _result);

int usdGeom_BBoxCache_dtor(usdGeom_BBoxCache_t* _this);

int usdGeom_PathMatrixHashMap_dtor(usdGeom_PathMatrixHashMap_t* _this);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Boundable_GetExtentAttr(usdGeom_Boundable_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Boundable_CreateExtentAttr(usdGeom_Boundable_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Boundable_GetXformOpOrderAttr(usdGeom_Boundable_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Boundable_AddXformOp(usdGeom_Boundable_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Boundable_AddTranslateOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Boundable_AddScaleOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Boundable_AddRotateXOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Boundable_AddRotateYOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Boundable_AddRotateZOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Boundable_AddRotateXYZOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Boundable_AddRotateXZYOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Boundable_AddRotateYXZOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Boundable_AddRotateYZXOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Boundable_AddRotateZXYOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Boundable_AddRotateZYXOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Boundable_AddOrientOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Boundable_AddTransformOp(usdGeom_Boundable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Boundable_SetResetXformStack(usdGeom_Boundable_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Boundable_SetXformOpOrder(usdGeom_Boundable_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Boundable_GetOrderedXformOps(usdGeom_Boundable_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Boundable_ClearXformOpOrder(usdGeom_Boundable_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Boundable_MakeMatrixXform(usdGeom_Boundable_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Boundable_TransformMightBeTimeVarying(usdGeom_Boundable_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Boundable_TransformMightBeTimeVarying_using(usdGeom_Boundable_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Boundable_GetTimeSamples(usdGeom_Boundable_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Boundable_GetTimeSamplesInInterval(usdGeom_Boundable_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Boundable_GetLocalTransformation(usdGeom_Boundable_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Boundable_GetLocalTransformation_with_ops(usdGeom_Boundable_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Boundable_GetVisibilityAttr(usdGeom_Boundable_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Boundable_CreateVisibilityAttr(usdGeom_Boundable_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Boundable_GetPurposeAttr(usdGeom_Boundable_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Boundable_CreatePurposeAttr(usdGeom_Boundable_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Boundable_GetProxyPrimRel(usdGeom_Boundable_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Boundable_CreateProxyPrimRel(usdGeom_Boundable_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Boundable_MakeVisible(usdGeom_Boundable_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Boundable_MakeInvisible(usdGeom_Boundable_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Boundable_ComputeVisibility(usdGeom_Boundable_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Boundable_GetPurposeVisibilityAttr(usdGeom_Boundable_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Boundable_ComputePurposeInfo(usdGeom_Boundable_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Boundable_ComputePurposeInfo_given_parent(usdGeom_Boundable_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Boundable_ComputePurpose(usdGeom_Boundable_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Boundable_ComputeProxyPrim(usdGeom_Boundable_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Boundable_SetProxyPrim(usdGeom_Boundable_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Boundable_ComputeWorldBound(usdGeom_Boundable_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Boundable_ComputeLocalBound(usdGeom_Boundable_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Boundable_ComputeUntransformedBound(usdGeom_Boundable_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Boundable_ComputeLocalToWorldTransform(usdGeom_Boundable_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Boundable_ComputeParentToWorldTransform(usdGeom_Boundable_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Boundable_IsConcrete(usdGeom_Boundable_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Boundable_IsTyped(usdGeom_Boundable_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Boundable_IsAPISchema(usdGeom_Boundable_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Boundable_IsAppliedAPISchema(usdGeom_Boundable_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Boundable_IsMultipleApplyAPISchema(usdGeom_Boundable_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Boundable_GetSchemaKind(usdGeom_Boundable_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Boundable_GetPrim(usdGeom_Boundable_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Boundable_GetPath(usdGeom_Boundable_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Boundable_GetSchemaClassPrimDefinition(usdGeom_Boundable_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Boundable_new(usd_Prim_t const* param00, usdGeom_Boundable_t** _result);

int usdGeom_Boundable_dtor(usdGeom_Boundable_t* _this);

/// 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token projection = "perspective"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | perspective, orthographic |
int usdGeom_Camera_GetProjectionAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetProjectionAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateProjectionAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Horizontal aperture in tenths of a scene unit; see 
/// \ref UsdGeom_CameraUnits . Default is the equivalent of 
/// the standard 35mm spherical projector aperture.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float horizontalAperture = 20.955` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_Camera_GetHorizontalApertureAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetHorizontalApertureAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateHorizontalApertureAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Vertical aperture in tenths of a scene unit; see 
/// \ref UsdGeom_CameraUnits . Default is the equivalent of 
/// the standard 35mm spherical projector aperture.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float verticalAperture = 15.2908` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_Camera_GetVerticalApertureAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetVerticalApertureAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateVerticalApertureAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Horizontal aperture offset in the same units as
/// horizontalAperture. Defaults to 0.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float horizontalApertureOffset = 0` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_Camera_GetHorizontalApertureOffsetAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetHorizontalApertureOffsetAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateHorizontalApertureOffsetAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Vertical aperture offset in the same units as
/// verticalAperture. Defaults to 0.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float verticalApertureOffset = 0` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_Camera_GetVerticalApertureOffsetAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetVerticalApertureOffsetAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateVerticalApertureOffsetAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Perspective focal length in tenths of a scene unit; see 
/// \ref UsdGeom_CameraUnits .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float focalLength = 50` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_Camera_GetFocalLengthAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetFocalLengthAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateFocalLengthAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Near and far clipping distances in scene units; see 
/// \ref UsdGeom_CameraUnits .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float2 clippingRange = (1, 1000000)` |
/// | C++ Type | GfVec2f |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float2 |
int usdGeom_Camera_GetClippingRangeAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetClippingRangeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateClippingRangeAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Additional, arbitrarily oriented clipping planes.
/// A vector (a,b,c,d) encodes a clipping plane that cuts off
/// (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)
/// are the coordinates in the camera's space.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float4[] clippingPlanes = []` |
/// | C++ Type | VtArray<GfVec4f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float4Array |
int usdGeom_Camera_GetClippingPlanesAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetClippingPlanesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateClippingPlanesAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Lens aperture. Defaults to 0.0, which turns off focusing.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float fStop = 0` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_Camera_GetFStopAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetFStopAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateFStopAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Distance from the camera to the focus plane in scene units; see 
/// \ref UsdGeom_CameraUnits .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float focusDistance = 0` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_Camera_GetFocusDistanceAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetFocusDistanceAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateFocusDistanceAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If different from mono, the camera is intended to be the left
/// or right camera of a stereo setup.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token stereoRole = "mono"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | mono, left, right |
int usdGeom_Camera_GetStereoRoleAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetStereoRoleAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateStereoRoleAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Frame relative shutter open time in UsdTimeCode units (negative
/// value indicates that the shutter opens before the current
/// frame time). Used for motion blur.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double shutter:open = 0` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Camera_GetShutterOpenAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetShutterOpenAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateShutterOpenAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Frame relative shutter close time, analogous comments from
/// shutter:open apply. A value greater or equal to shutter:open
/// should be authored, otherwise there is no exposure and a
/// renderer should produce a black image.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double shutter:close = 0` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Camera_GetShutterCloseAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetShutterCloseAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateShutterCloseAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Exposure adjustment, as a log base-2 value.  The default
/// of 0.0 has no effect.  A value of 1.0 will double the
/// image-plane intensities in a rendered image; a value of
/// -1.0 will halve them.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float exposure = 0` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_Camera_GetExposureAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetExposureAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateExposureAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Creates a GfCamera object from the attribute values at \p time.
int usdGeom_Camera_GetCamera(usdGeom_Camera_t const* _this, usd_TimeCode_t const* time, gf_Camera_t* _result);

/// Write attribute values from \p camera for \p time.
/// These attributes will be updated:
///  - projection
///  - horizontalAperture
///  - horizontalApertureOffset
///  - verticalAperture
///  - verticalApertureOffset
///  - focalLength
///  - clippingRange
///  - clippingPlanes
///  - fStop
///  - focalDistance
///  - xformOpOrder and xformOp:transform
/// 
/// \note This will clear any existing xformOpOrder and replace
/// it with a single xformOp:transform entry. The xformOp:transform
/// property is created or updated here to match the transform
/// on \p camera . This operation will fail if there are stronger xform op
/// opinions in the composed layer stack that are stronger than that of
/// the current edit target.
int usdGeom_Camera_SetFromCamera(usdGeom_Camera_t* _this, gf_Camera_t const* camera, usd_TimeCode_t const* time);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Camera_GetXformOpOrderAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Camera_AddXformOp(usdGeom_Camera_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Camera_AddTranslateOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Camera_AddScaleOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Camera_AddRotateXOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Camera_AddRotateYOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Camera_AddRotateZOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Camera_AddRotateXYZOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Camera_AddRotateXZYOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Camera_AddRotateYXZOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Camera_AddRotateYZXOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Camera_AddRotateZXYOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Camera_AddRotateZYXOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Camera_AddOrientOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Camera_AddTransformOp(usdGeom_Camera_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Camera_SetResetXformStack(usdGeom_Camera_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Camera_SetXformOpOrder(usdGeom_Camera_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Camera_GetOrderedXformOps(usdGeom_Camera_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Camera_ClearXformOpOrder(usdGeom_Camera_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Camera_MakeMatrixXform(usdGeom_Camera_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Camera_TransformMightBeTimeVarying(usdGeom_Camera_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Camera_TransformMightBeTimeVarying_using(usdGeom_Camera_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Camera_GetTimeSamples(usdGeom_Camera_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Camera_GetTimeSamplesInInterval(usdGeom_Camera_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Camera_GetLocalTransformation(usdGeom_Camera_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Camera_GetLocalTransformation_with_ops(usdGeom_Camera_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Camera_GetVisibilityAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreateVisibilityAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Camera_GetPurposeAttr(usdGeom_Camera_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Camera_CreatePurposeAttr(usdGeom_Camera_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Camera_GetProxyPrimRel(usdGeom_Camera_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Camera_CreateProxyPrimRel(usdGeom_Camera_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Camera_MakeVisible(usdGeom_Camera_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Camera_MakeInvisible(usdGeom_Camera_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Camera_ComputeVisibility(usdGeom_Camera_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Camera_GetPurposeVisibilityAttr(usdGeom_Camera_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Camera_ComputePurposeInfo(usdGeom_Camera_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Camera_ComputePurposeInfo_given_parent(usdGeom_Camera_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Camera_ComputePurpose(usdGeom_Camera_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Camera_ComputeProxyPrim(usdGeom_Camera_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Camera_SetProxyPrim(usdGeom_Camera_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Camera_ComputeWorldBound(usdGeom_Camera_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Camera_ComputeLocalBound(usdGeom_Camera_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Camera_ComputeUntransformedBound(usdGeom_Camera_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Camera_ComputeLocalToWorldTransform(usdGeom_Camera_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Camera_ComputeParentToWorldTransform(usdGeom_Camera_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Camera_IsConcrete(usdGeom_Camera_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Camera_IsTyped(usdGeom_Camera_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Camera_IsAPISchema(usdGeom_Camera_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Camera_IsAppliedAPISchema(usdGeom_Camera_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Camera_IsMultipleApplyAPISchema(usdGeom_Camera_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Camera_GetSchemaKind(usdGeom_Camera_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Camera_GetPrim(usdGeom_Camera_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Camera_GetPath(usdGeom_Camera_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Camera_GetSchemaClassPrimDefinition(usdGeom_Camera_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Camera_new(usd_Prim_t const* param00, usdGeom_Camera_t** _result);

int usdGeom_Camera_dtor(usdGeom_Camera_t* _this);

/// The size of the capsule's spine along the specified
/// \em axis excluding the size of the two half spheres, i.e.
/// the size of the cylinder portion of the capsule.
/// If you author \em height you must also author \em extent.
/// \sa GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double height = 1` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Capsule_GetHeightAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetHeightAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreateHeightAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The radius of the capsule.  If you
/// author \em radius you must also author \em extent.
/// 
/// \sa GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double radius = 0.5` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Capsule_GetRadiusAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetRadiusAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreateRadiusAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The axis along which the spine of the capsule is aligned
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token axis = "Z"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | X, Y, Z |
int usdGeom_Capsule_GetAxisAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetAxisAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreateAxisAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Capsule_GetDisplayColorAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreateDisplayColorAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Capsule_GetDisplayOpacityAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreateDisplayOpacityAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Capsule_GetDoubleSidedAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreateDoubleSidedAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Capsule_GetOrientationAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreateOrientationAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Capsule_GetDisplayColorPrimvar(usdGeom_Capsule_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Capsule_CreateDisplayColorPrimvar(usdGeom_Capsule_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is re-defined on Capsule only to provide a fallback
/// value. \sa UsdGeomGprim::GetExtentAttr().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent = [(-0.5, -0.5, -1), (0.5, 0.5, 1)]` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Capsule_GetExtentAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreateExtentAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Capsule_GetXformOpOrderAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Capsule_AddXformOp(usdGeom_Capsule_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Capsule_AddTranslateOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Capsule_AddScaleOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Capsule_AddRotateXOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Capsule_AddRotateYOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Capsule_AddRotateZOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Capsule_AddRotateXYZOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Capsule_AddRotateXZYOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Capsule_AddRotateYXZOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Capsule_AddRotateYZXOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Capsule_AddRotateZXYOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Capsule_AddRotateZYXOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Capsule_AddOrientOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Capsule_AddTransformOp(usdGeom_Capsule_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Capsule_SetResetXformStack(usdGeom_Capsule_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Capsule_SetXformOpOrder(usdGeom_Capsule_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Capsule_GetOrderedXformOps(usdGeom_Capsule_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Capsule_ClearXformOpOrder(usdGeom_Capsule_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Capsule_MakeMatrixXform(usdGeom_Capsule_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Capsule_TransformMightBeTimeVarying(usdGeom_Capsule_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Capsule_TransformMightBeTimeVarying_using(usdGeom_Capsule_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Capsule_GetTimeSamples(usdGeom_Capsule_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Capsule_GetTimeSamplesInInterval(usdGeom_Capsule_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Capsule_GetLocalTransformation(usdGeom_Capsule_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Capsule_GetLocalTransformation_with_ops(usdGeom_Capsule_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Capsule_GetVisibilityAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreateVisibilityAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Capsule_GetPurposeAttr(usdGeom_Capsule_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Capsule_CreatePurposeAttr(usdGeom_Capsule_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Capsule_GetProxyPrimRel(usdGeom_Capsule_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Capsule_CreateProxyPrimRel(usdGeom_Capsule_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Capsule_MakeVisible(usdGeom_Capsule_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Capsule_MakeInvisible(usdGeom_Capsule_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Capsule_ComputeVisibility(usdGeom_Capsule_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Capsule_GetPurposeVisibilityAttr(usdGeom_Capsule_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Capsule_ComputePurposeInfo(usdGeom_Capsule_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Capsule_ComputePurposeInfo_given_parent(usdGeom_Capsule_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Capsule_ComputePurpose(usdGeom_Capsule_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Capsule_ComputeProxyPrim(usdGeom_Capsule_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Capsule_SetProxyPrim(usdGeom_Capsule_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Capsule_ComputeWorldBound(usdGeom_Capsule_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Capsule_ComputeLocalBound(usdGeom_Capsule_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Capsule_ComputeUntransformedBound(usdGeom_Capsule_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Capsule_ComputeLocalToWorldTransform(usdGeom_Capsule_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Capsule_ComputeParentToWorldTransform(usdGeom_Capsule_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Capsule_IsConcrete(usdGeom_Capsule_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Capsule_IsTyped(usdGeom_Capsule_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Capsule_IsAPISchema(usdGeom_Capsule_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Capsule_IsAppliedAPISchema(usdGeom_Capsule_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Capsule_IsMultipleApplyAPISchema(usdGeom_Capsule_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Capsule_GetSchemaKind(usdGeom_Capsule_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Capsule_GetPrim(usdGeom_Capsule_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Capsule_GetPath(usdGeom_Capsule_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Capsule_GetSchemaClassPrimDefinition(usdGeom_Capsule_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Capsule_new(usd_Prim_t const* param00, usdGeom_Capsule_t** _result);

int usdGeom_Capsule_dtor(usdGeom_Capsule_t* _this);

/// The size of the cone's spine along the specified
/// \em axis.  If you author \em height you must also author \em extent.
/// 
/// \sa GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double height = 2` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Cone_GetHeightAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetHeightAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreateHeightAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The radius of the cone.  If you
/// author \em radius you must also author \em extent.
/// 
/// \sa GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double radius = 1` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Cone_GetRadiusAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetRadiusAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreateRadiusAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The axis along which the spine of the cone is aligned
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token axis = "Z"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | X, Y, Z |
int usdGeom_Cone_GetAxisAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetAxisAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreateAxisAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Cone_GetDisplayColorAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreateDisplayColorAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Cone_GetDisplayOpacityAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreateDisplayOpacityAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Cone_GetDoubleSidedAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreateDoubleSidedAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Cone_GetOrientationAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreateOrientationAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Cone_GetDisplayColorPrimvar(usdGeom_Cone_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Cone_CreateDisplayColorPrimvar(usdGeom_Cone_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is re-defined on Cone only to provide a fallback
/// value. \sa UsdGeomGprim::GetExtentAttr().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent = [(-1, -1, -1), (1, 1, 1)]` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Cone_GetExtentAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreateExtentAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Cone_GetXformOpOrderAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Cone_AddXformOp(usdGeom_Cone_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cone_AddTranslateOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cone_AddScaleOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Cone_AddRotateXOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Cone_AddRotateYOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cone_AddRotateZOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cone_AddRotateXYZOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cone_AddRotateXZYOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cone_AddRotateYXZOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cone_AddRotateYZXOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cone_AddRotateZXYOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cone_AddRotateZYXOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cone_AddOrientOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Cone_AddTransformOp(usdGeom_Cone_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Cone_SetResetXformStack(usdGeom_Cone_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Cone_SetXformOpOrder(usdGeom_Cone_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Cone_GetOrderedXformOps(usdGeom_Cone_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Cone_ClearXformOpOrder(usdGeom_Cone_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Cone_MakeMatrixXform(usdGeom_Cone_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Cone_TransformMightBeTimeVarying(usdGeom_Cone_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Cone_TransformMightBeTimeVarying_using(usdGeom_Cone_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Cone_GetTimeSamples(usdGeom_Cone_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Cone_GetTimeSamplesInInterval(usdGeom_Cone_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Cone_GetLocalTransformation(usdGeom_Cone_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Cone_GetLocalTransformation_with_ops(usdGeom_Cone_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Cone_GetVisibilityAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreateVisibilityAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Cone_GetPurposeAttr(usdGeom_Cone_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cone_CreatePurposeAttr(usdGeom_Cone_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Cone_GetProxyPrimRel(usdGeom_Cone_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Cone_CreateProxyPrimRel(usdGeom_Cone_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Cone_MakeVisible(usdGeom_Cone_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Cone_MakeInvisible(usdGeom_Cone_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Cone_ComputeVisibility(usdGeom_Cone_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Cone_GetPurposeVisibilityAttr(usdGeom_Cone_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Cone_ComputePurposeInfo(usdGeom_Cone_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Cone_ComputePurposeInfo_given_parent(usdGeom_Cone_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Cone_ComputePurpose(usdGeom_Cone_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Cone_ComputeProxyPrim(usdGeom_Cone_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Cone_SetProxyPrim(usdGeom_Cone_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Cone_ComputeWorldBound(usdGeom_Cone_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Cone_ComputeLocalBound(usdGeom_Cone_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Cone_ComputeUntransformedBound(usdGeom_Cone_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Cone_ComputeLocalToWorldTransform(usdGeom_Cone_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Cone_ComputeParentToWorldTransform(usdGeom_Cone_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Cone_IsConcrete(usdGeom_Cone_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Cone_IsTyped(usdGeom_Cone_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Cone_IsAPISchema(usdGeom_Cone_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Cone_IsAppliedAPISchema(usdGeom_Cone_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Cone_IsMultipleApplyAPISchema(usdGeom_Cone_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Cone_GetSchemaKind(usdGeom_Cone_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Cone_GetPrim(usdGeom_Cone_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Cone_GetPath(usdGeom_Cone_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Cone_GetSchemaClassPrimDefinition(usdGeom_Cone_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Cone_new(usd_Prim_t const* param00, usdGeom_Cone_t** _result);

int usdGeom_Cone_dtor(usdGeom_Cone_t* _this);

/// Test whether a given UsdAttribute represents valid ConstraintTarget, 
/// which implies that creating a UsdGeomConstraintTarget from the attribute 
/// will succeed.
/// 
/// Success implies that \c attr.IsDefined() is true.
int usdGeom_ConstraintTarget_IsValid(usd_Attribute_t const* attr, bool* _result);

/// Explicit UsdAttribute extractor
int usdGeom_ConstraintTarget_GetAttr(usdGeom_ConstraintTarget_t const* _this, usd_Attribute_t const** _result);

/// Return true if the wrapped UsdAttribute::IsDefined(), and in
/// addition the attribute is identified as a ConstraintTarget.
int usdGeom_ConstraintTarget_IsDefined(usdGeom_ConstraintTarget_t const* _this, bool* _result);

/// Get the attribute value of the ConstraintTarget at \p time 
int usdGeom_ConstraintTarget_Get(usdGeom_ConstraintTarget_t const* _this, gf_Matrix4d_t* value, usd_TimeCode_t time, bool* _result);

/// Set the attribute value of the ConstraintTarget at \p time 
int usdGeom_ConstraintTarget_Set(usdGeom_ConstraintTarget_t const* _this, gf_Matrix4d_t const* value, usd_TimeCode_t time, bool* _result);

/// Get the stored identifier unique to the enclosing model's namespace for
/// this constraint target.
/// \sa SetIdentifier()
int usdGeom_ConstraintTarget_GetIdentifier(usdGeom_ConstraintTarget_t const* _this, tf_Token_t* _result);

/// Explicitly sets the stored identifier to the given string. Clients are
/// responsible for ensuring the uniqueness of this identifier within the
/// enclosing model's namespace.
int usdGeom_ConstraintTarget_SetIdentifier(usdGeom_ConstraintTarget_t* _this, tf_Token_t const* identifier);

/// Computes the value of the constraint target in world space.
/// 
/// If a valid UsdGeomXformCache is provided in the argument \p xfCache, 
/// it is used to evaluate the CTM of the model to which the constraint
/// target belongs. 
/// 
/// To get the constraint value in model-space (or local space), simply 
/// use UsdGeomConstraintTarget::Get(), since the authored values must 
/// already be in model-space.
int usdGeom_ConstraintTarget_ComputeInWorldSpace(usdGeom_ConstraintTarget_t const* _this, usd_TimeCode_t time, usdGeom_XformCache_t* xfCache, gf_Matrix4d_t* _result);

/// Returns the fully namespaced constraint attribute name, given the 
/// constraint name.
int usdGeom_ConstraintTarget_GetConstraintAttrName(std_String_t const* constraintName, tf_Token_t* _result);

int usdGeom_ConstraintTarget_new(usd_Attribute_t const* param00, usdGeom_ConstraintTarget_t** _result);

int usdGeom_ConstraintTarget_dtor(usdGeom_ConstraintTarget_t* _this);

int usdGeom_ConstraintTargetVector_data(usdGeom_ConstraintTargetVector_t* _this, usdGeom_ConstraintTarget_t** _result);

int usdGeom_ConstraintTargetVector_data_const(usdGeom_ConstraintTargetVector_t const* _this, usdGeom_ConstraintTarget_t const** _result);

int usdGeom_ConstraintTargetVector_empty(usdGeom_ConstraintTargetVector_t const* _this, bool* _result);

int usdGeom_ConstraintTargetVector_size(usdGeom_ConstraintTargetVector_t const* _this, size_t* _result);

int usdGeom_ConstraintTargetVector_max_size(usdGeom_ConstraintTargetVector_t const* _this, size_t* _result);

int usdGeom_ConstraintTargetVector_reserve(usdGeom_ConstraintTargetVector_t* _this, size_t const _Newcapacity);

int usdGeom_ConstraintTargetVector_capacity(usdGeom_ConstraintTargetVector_t const* _this, size_t* _result);

int usdGeom_ConstraintTargetVector_clear(usdGeom_ConstraintTargetVector_t* _this);

int usdGeom_ConstraintTargetVector_push_back(usdGeom_ConstraintTargetVector_t* _this, usdGeom_ConstraintTarget_t const* _Val);

int usdGeom_ConstraintTargetVector_pop_back(usdGeom_ConstraintTargetVector_t* _this);

int usdGeom_ConstraintTargetVector_resize(usdGeom_ConstraintTargetVector_t* _this, size_t const _Newsize);

int usdGeom_ConstraintTargetVector_resize_with(usdGeom_ConstraintTargetVector_t* _this, size_t const _Newsize, usdGeom_ConstraintTarget_t const* _Val);

int usdGeom_ConstraintTargetVector_op_index(usdGeom_ConstraintTargetVector_t const* _this, size_t const _Pos, usdGeom_ConstraintTarget_t const** _result);

int usdGeom_ConstraintTargetVector_default(usdGeom_ConstraintTargetVector_t** _result);

int usdGeom_ConstraintTargetVector_dtor(usdGeom_ConstraintTargetVector_t* _this);

/// Indicates the length of each edge of the cube.  If you
/// author \em size you must also author \em extent.
/// 
/// \sa GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double size = 2` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Cube_GetSizeAttr(usdGeom_Cube_t const* _this, usd_Attribute_t* _result);

/// See GetSizeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cube_CreateSizeAttr(usdGeom_Cube_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Cube_GetDisplayColorAttr(usdGeom_Cube_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cube_CreateDisplayColorAttr(usdGeom_Cube_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Cube_GetDisplayOpacityAttr(usdGeom_Cube_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cube_CreateDisplayOpacityAttr(usdGeom_Cube_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Cube_GetDoubleSidedAttr(usdGeom_Cube_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cube_CreateDoubleSidedAttr(usdGeom_Cube_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Cube_GetOrientationAttr(usdGeom_Cube_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cube_CreateOrientationAttr(usdGeom_Cube_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Cube_GetDisplayColorPrimvar(usdGeom_Cube_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Cube_CreateDisplayColorPrimvar(usdGeom_Cube_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is re-defined on Cube only to provide a fallback value.
/// \sa UsdGeomGprim::GetExtentAttr().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent = [(-1, -1, -1), (1, 1, 1)]` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Cube_GetExtentAttr(usdGeom_Cube_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cube_CreateExtentAttr(usdGeom_Cube_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Cube_GetXformOpOrderAttr(usdGeom_Cube_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Cube_AddXformOp(usdGeom_Cube_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cube_AddTranslateOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cube_AddScaleOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Cube_AddRotateXOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Cube_AddRotateYOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cube_AddRotateZOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cube_AddRotateXYZOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cube_AddRotateXZYOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cube_AddRotateYXZOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cube_AddRotateYZXOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cube_AddRotateZXYOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cube_AddRotateZYXOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cube_AddOrientOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Cube_AddTransformOp(usdGeom_Cube_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Cube_SetResetXformStack(usdGeom_Cube_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Cube_SetXformOpOrder(usdGeom_Cube_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Cube_GetOrderedXformOps(usdGeom_Cube_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Cube_ClearXformOpOrder(usdGeom_Cube_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Cube_MakeMatrixXform(usdGeom_Cube_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Cube_TransformMightBeTimeVarying(usdGeom_Cube_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Cube_TransformMightBeTimeVarying_using(usdGeom_Cube_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Cube_GetTimeSamples(usdGeom_Cube_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Cube_GetTimeSamplesInInterval(usdGeom_Cube_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Cube_GetLocalTransformation(usdGeom_Cube_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Cube_GetLocalTransformation_with_ops(usdGeom_Cube_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Cube_GetVisibilityAttr(usdGeom_Cube_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cube_CreateVisibilityAttr(usdGeom_Cube_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Cube_GetPurposeAttr(usdGeom_Cube_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cube_CreatePurposeAttr(usdGeom_Cube_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Cube_GetProxyPrimRel(usdGeom_Cube_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Cube_CreateProxyPrimRel(usdGeom_Cube_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Cube_MakeVisible(usdGeom_Cube_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Cube_MakeInvisible(usdGeom_Cube_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Cube_ComputeVisibility(usdGeom_Cube_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Cube_GetPurposeVisibilityAttr(usdGeom_Cube_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Cube_ComputePurposeInfo(usdGeom_Cube_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Cube_ComputePurposeInfo_given_parent(usdGeom_Cube_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Cube_ComputePurpose(usdGeom_Cube_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Cube_ComputeProxyPrim(usdGeom_Cube_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Cube_SetProxyPrim(usdGeom_Cube_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Cube_ComputeWorldBound(usdGeom_Cube_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Cube_ComputeLocalBound(usdGeom_Cube_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Cube_ComputeUntransformedBound(usdGeom_Cube_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Cube_ComputeLocalToWorldTransform(usdGeom_Cube_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Cube_ComputeParentToWorldTransform(usdGeom_Cube_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Cube_IsConcrete(usdGeom_Cube_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Cube_IsTyped(usdGeom_Cube_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Cube_IsAPISchema(usdGeom_Cube_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Cube_IsAppliedAPISchema(usdGeom_Cube_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Cube_IsMultipleApplyAPISchema(usdGeom_Cube_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Cube_GetSchemaKind(usdGeom_Cube_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Cube_GetPrim(usdGeom_Cube_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Cube_GetPath(usdGeom_Cube_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Cube_GetSchemaClassPrimDefinition(usdGeom_Cube_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Cube_new(usd_Prim_t const* param00, usdGeom_Cube_t** _result);

int usdGeom_Cube_dtor(usdGeom_Cube_t* _this);

/// Curves-derived primitives can represent multiple distinct,
/// potentially disconnected curves.  The length of 'curveVertexCounts'
/// gives the number of such curves, and each element describes the
/// number of vertices in the corresponding curve
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] curveVertexCounts` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_Curves_GetCurveVertexCountsAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetCurveVertexCountsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateCurveVertexCountsAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provides width specification for the curves, whose application
/// will depend on whether the curve is oriented (normals are defined for
/// it), in which case widths are "ribbon width", or unoriented, in which
/// case widths are cylinder width.  'widths' is not a generic Primvar,
/// but the number of elements in this attribute will be determined by
/// its 'interpolation'.  See \ref SetWidthsInterpolation() .  If 'widths'
/// and 'primvars:widths' are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] widths` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Curves_GetWidthsAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetWidthsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateWidthsAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// Although 'widths' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which means a width value is specified at the end of each curve segment.
int usdGeom_Curves_GetWidthsInterpolation(usdGeom_Curves_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the widths attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetWidthsInterpolation()
int usdGeom_Curves_SetWidthsInterpolation(usdGeom_Curves_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Returns the number of curves as defined by the size of the
/// _curveVertexCounts_ array at _timeCode_.
/// 
/// \snippetdoc snippets.dox GetCount
/// \sa GetCurveVertexCountsAttr()
int usdGeom_Curves_GetCurveCount(usdGeom_Curves_t const* _this, usd_TimeCode_t timeCode, size_t* _result);

/// The primary geometry attribute for all PointBased
/// primitives, describes points in (local) space.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `point3f[] points` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Point3fArray |
int usdGeom_Curves_GetPointsAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetPointsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreatePointsAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'velocities' should be used by renderers to 
/// 
/// compute positions between samples for the 'points' attribute, rather
/// than interpolating between neighboring 'points' samples.  This is the
/// only reasonable means of computing motion blur for topologically
/// varying PointBased primitives.  It follows that the length of each
/// 'velocities' sample must match the length of the corresponding
/// 'points' sample.  Velocity is measured in position units per second,
/// as per most simulation software. To convert to position units per
/// UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeom_VelocityInterpolation .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] velocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_Curves_GetVelocitiesAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateVelocitiesAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'accelerations' should be used with
/// velocities to compute positions between samples for the 'points'
/// attribute rather than interpolating between neighboring 'points'
/// samples. Acceleration is measured in position units per second-squared.
/// To convert to position units per squared UsdTimeCode, divide by the
/// square of UsdStage::GetTimeCodesPerSecond().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] accelerations` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_Curves_GetAccelerationsAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetAccelerationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateAccelerationsAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provide an object-space orientation for individual points, 
/// which, depending on subclass, may define a surface, curve, or free 
/// points.  Note that 'normals' should not be authored on any Mesh that
/// is subdivided, since the subdivision algorithm will define its own
/// normals. 'normals' is not a generic primvar, but the number of elements
/// in this attribute will be determined by its 'interpolation'.  See
/// \ref SetNormalsInterpolation() . If 'normals' and 'primvars:normals'
/// are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `normal3f[] normals` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Normal3fArray |
int usdGeom_Curves_GetNormalsAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetNormalsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateNormalsAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// Although 'normals' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which will generally produce smooth shading on a polygonal mesh.
/// To achieve partial or fully faceted shading of a polygonal mesh
/// with normals, one should use UsdGeomTokens->faceVarying or
/// UsdGeomTokens->uniform interpolation.
int usdGeom_Curves_GetNormalsInterpolation(usdGeom_Curves_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdGeomPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the normals attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetNormalsInterpolation()
int usdGeom_Curves_SetNormalsInterpolation(usdGeom_Curves_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Compute points given the positions, velocities and accelerations
/// at \p time. 
/// 
/// This will return \c false and leave \p points untouched if:
/// - \p points is NULL
/// - one of \p time and \p baseTime is numeric and the other is
///   UsdTimeCode::Default() (they must either both be numeric or both be
///   default)
/// - there is no authored points attribute
/// 
/// If there is no error, we will return \c true and \p points will contain
/// the computed points.
/// 
/// \param points - the out parameter for the new points.  Its size
///                 will depend on the authored data.
/// \param time - UsdTimeCode at which we want to evaluate the transforms
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em accelerations are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
int usdGeom_Curves_ComputePointsAtTime(usdGeom_Curves_t const* _this, gf_Vec3fArray_t* points, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, bool* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Curves_GetDisplayColorAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateDisplayColorAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Curves_GetDisplayOpacityAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateDisplayOpacityAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Curves_GetDoubleSidedAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateDoubleSidedAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Curves_GetOrientationAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateOrientationAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Curves_GetDisplayColorPrimvar(usdGeom_Curves_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Curves_CreateDisplayColorPrimvar(usdGeom_Curves_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Curves_GetExtentAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateExtentAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Curves_GetXformOpOrderAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Curves_AddXformOp(usdGeom_Curves_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Curves_AddTranslateOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Curves_AddScaleOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Curves_AddRotateXOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Curves_AddRotateYOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Curves_AddRotateZOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Curves_AddRotateXYZOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Curves_AddRotateXZYOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Curves_AddRotateYXZOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Curves_AddRotateYZXOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Curves_AddRotateZXYOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Curves_AddRotateZYXOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Curves_AddOrientOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Curves_AddTransformOp(usdGeom_Curves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Curves_SetResetXformStack(usdGeom_Curves_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Curves_SetXformOpOrder(usdGeom_Curves_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Curves_GetOrderedXformOps(usdGeom_Curves_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Curves_ClearXformOpOrder(usdGeom_Curves_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Curves_MakeMatrixXform(usdGeom_Curves_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Curves_TransformMightBeTimeVarying(usdGeom_Curves_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Curves_TransformMightBeTimeVarying_using(usdGeom_Curves_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Curves_GetTimeSamples(usdGeom_Curves_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Curves_GetTimeSamplesInInterval(usdGeom_Curves_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Curves_GetLocalTransformation(usdGeom_Curves_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Curves_GetLocalTransformation_with_ops(usdGeom_Curves_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Curves_GetVisibilityAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreateVisibilityAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Curves_GetPurposeAttr(usdGeom_Curves_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Curves_CreatePurposeAttr(usdGeom_Curves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Curves_GetProxyPrimRel(usdGeom_Curves_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Curves_CreateProxyPrimRel(usdGeom_Curves_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Curves_MakeVisible(usdGeom_Curves_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Curves_MakeInvisible(usdGeom_Curves_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Curves_ComputeVisibility(usdGeom_Curves_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Curves_GetPurposeVisibilityAttr(usdGeom_Curves_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Curves_ComputePurposeInfo(usdGeom_Curves_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Curves_ComputePurposeInfo_given_parent(usdGeom_Curves_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Curves_ComputePurpose(usdGeom_Curves_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Curves_ComputeProxyPrim(usdGeom_Curves_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Curves_SetProxyPrim(usdGeom_Curves_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Curves_ComputeWorldBound(usdGeom_Curves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Curves_ComputeLocalBound(usdGeom_Curves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Curves_ComputeUntransformedBound(usdGeom_Curves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Curves_ComputeLocalToWorldTransform(usdGeom_Curves_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Curves_ComputeParentToWorldTransform(usdGeom_Curves_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Curves_IsConcrete(usdGeom_Curves_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Curves_IsTyped(usdGeom_Curves_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Curves_IsAPISchema(usdGeom_Curves_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Curves_IsAppliedAPISchema(usdGeom_Curves_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Curves_IsMultipleApplyAPISchema(usdGeom_Curves_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Curves_GetSchemaKind(usdGeom_Curves_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Curves_GetPrim(usdGeom_Curves_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Curves_GetPath(usdGeom_Curves_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Curves_GetSchemaClassPrimDefinition(usdGeom_Curves_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Curves_new(usd_Prim_t const* param00, usdGeom_Curves_t** _result);

int usdGeom_Curves_dtor(usdGeom_Curves_t* _this);

/// The size of the cylinder's spine along the specified
/// \em axis.  If you author \em height you must also author \em extent.
/// 
/// \sa GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double height = 2` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Cylinder_GetHeightAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetHeightAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreateHeightAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The radius of the cylinder. If you author \em radius
/// you must also author \em extent.
/// 
/// \sa GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double radius = 1` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Cylinder_GetRadiusAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetRadiusAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreateRadiusAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The axis along which the spine of the cylinder is aligned
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token axis = "Z"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | X, Y, Z |
int usdGeom_Cylinder_GetAxisAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetAxisAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreateAxisAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Cylinder_GetDisplayColorAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreateDisplayColorAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Cylinder_GetDisplayOpacityAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreateDisplayOpacityAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Cylinder_GetDoubleSidedAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreateDoubleSidedAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Cylinder_GetOrientationAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreateOrientationAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Cylinder_GetDisplayColorPrimvar(usdGeom_Cylinder_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Cylinder_CreateDisplayColorPrimvar(usdGeom_Cylinder_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is re-defined on Cylinder only to provide a fallback
/// value. \sa UsdGeomGprim::GetExtentAttr().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent = [(-1, -1, -1), (1, 1, 1)]` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Cylinder_GetExtentAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreateExtentAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Cylinder_GetXformOpOrderAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Cylinder_AddXformOp(usdGeom_Cylinder_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cylinder_AddTranslateOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cylinder_AddScaleOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Cylinder_AddRotateXOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Cylinder_AddRotateYOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cylinder_AddRotateZOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cylinder_AddRotateXYZOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cylinder_AddRotateXZYOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cylinder_AddRotateYXZOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cylinder_AddRotateYZXOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cylinder_AddRotateZXYOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Cylinder_AddRotateZYXOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Cylinder_AddOrientOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Cylinder_AddTransformOp(usdGeom_Cylinder_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Cylinder_SetResetXformStack(usdGeom_Cylinder_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Cylinder_SetXformOpOrder(usdGeom_Cylinder_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Cylinder_GetOrderedXformOps(usdGeom_Cylinder_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Cylinder_ClearXformOpOrder(usdGeom_Cylinder_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Cylinder_MakeMatrixXform(usdGeom_Cylinder_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Cylinder_TransformMightBeTimeVarying(usdGeom_Cylinder_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Cylinder_TransformMightBeTimeVarying_using(usdGeom_Cylinder_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Cylinder_GetTimeSamples(usdGeom_Cylinder_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Cylinder_GetTimeSamplesInInterval(usdGeom_Cylinder_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Cylinder_GetLocalTransformation(usdGeom_Cylinder_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Cylinder_GetLocalTransformation_with_ops(usdGeom_Cylinder_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Cylinder_GetVisibilityAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreateVisibilityAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Cylinder_GetPurposeAttr(usdGeom_Cylinder_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Cylinder_CreatePurposeAttr(usdGeom_Cylinder_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Cylinder_GetProxyPrimRel(usdGeom_Cylinder_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Cylinder_CreateProxyPrimRel(usdGeom_Cylinder_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Cylinder_MakeVisible(usdGeom_Cylinder_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Cylinder_MakeInvisible(usdGeom_Cylinder_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Cylinder_ComputeVisibility(usdGeom_Cylinder_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Cylinder_GetPurposeVisibilityAttr(usdGeom_Cylinder_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Cylinder_ComputePurposeInfo(usdGeom_Cylinder_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Cylinder_ComputePurposeInfo_given_parent(usdGeom_Cylinder_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Cylinder_ComputePurpose(usdGeom_Cylinder_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Cylinder_ComputeProxyPrim(usdGeom_Cylinder_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Cylinder_SetProxyPrim(usdGeom_Cylinder_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Cylinder_ComputeWorldBound(usdGeom_Cylinder_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Cylinder_ComputeLocalBound(usdGeom_Cylinder_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Cylinder_ComputeUntransformedBound(usdGeom_Cylinder_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Cylinder_ComputeLocalToWorldTransform(usdGeom_Cylinder_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Cylinder_ComputeParentToWorldTransform(usdGeom_Cylinder_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Cylinder_IsConcrete(usdGeom_Cylinder_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Cylinder_IsTyped(usdGeom_Cylinder_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Cylinder_IsAPISchema(usdGeom_Cylinder_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Cylinder_IsAppliedAPISchema(usdGeom_Cylinder_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Cylinder_IsMultipleApplyAPISchema(usdGeom_Cylinder_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Cylinder_GetSchemaKind(usdGeom_Cylinder_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Cylinder_GetPrim(usdGeom_Cylinder_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Cylinder_GetPath(usdGeom_Cylinder_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Cylinder_GetSchemaClassPrimDefinition(usdGeom_Cylinder_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Cylinder_new(usd_Prim_t const* param00, usdGeom_Cylinder_t** _result);

int usdGeom_Cylinder_dtor(usdGeom_Cylinder_t* _this);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Gprim_GetDisplayColorAttr(usdGeom_Gprim_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Gprim_CreateDisplayColorAttr(usdGeom_Gprim_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Gprim_GetDisplayOpacityAttr(usdGeom_Gprim_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Gprim_CreateDisplayOpacityAttr(usdGeom_Gprim_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Gprim_GetDoubleSidedAttr(usdGeom_Gprim_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Gprim_CreateDoubleSidedAttr(usdGeom_Gprim_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Gprim_GetOrientationAttr(usdGeom_Gprim_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Gprim_CreateOrientationAttr(usdGeom_Gprim_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Gprim_GetDisplayColorPrimvar(usdGeom_Gprim_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Gprim_CreateDisplayColorPrimvar(usdGeom_Gprim_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Gprim_GetExtentAttr(usdGeom_Gprim_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Gprim_CreateExtentAttr(usdGeom_Gprim_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Gprim_GetXformOpOrderAttr(usdGeom_Gprim_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Gprim_AddXformOp(usdGeom_Gprim_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Gprim_AddTranslateOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Gprim_AddScaleOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Gprim_AddRotateXOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Gprim_AddRotateYOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Gprim_AddRotateZOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Gprim_AddRotateXYZOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Gprim_AddRotateXZYOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Gprim_AddRotateYXZOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Gprim_AddRotateYZXOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Gprim_AddRotateZXYOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Gprim_AddRotateZYXOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Gprim_AddOrientOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Gprim_AddTransformOp(usdGeom_Gprim_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Gprim_SetResetXformStack(usdGeom_Gprim_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Gprim_SetXformOpOrder(usdGeom_Gprim_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Gprim_GetOrderedXformOps(usdGeom_Gprim_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Gprim_ClearXformOpOrder(usdGeom_Gprim_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Gprim_MakeMatrixXform(usdGeom_Gprim_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Gprim_TransformMightBeTimeVarying(usdGeom_Gprim_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Gprim_TransformMightBeTimeVarying_using(usdGeom_Gprim_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Gprim_GetTimeSamples(usdGeom_Gprim_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Gprim_GetTimeSamplesInInterval(usdGeom_Gprim_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Gprim_GetLocalTransformation(usdGeom_Gprim_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Gprim_GetLocalTransformation_with_ops(usdGeom_Gprim_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Gprim_GetVisibilityAttr(usdGeom_Gprim_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Gprim_CreateVisibilityAttr(usdGeom_Gprim_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Gprim_GetPurposeAttr(usdGeom_Gprim_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Gprim_CreatePurposeAttr(usdGeom_Gprim_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Gprim_GetProxyPrimRel(usdGeom_Gprim_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Gprim_CreateProxyPrimRel(usdGeom_Gprim_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Gprim_MakeVisible(usdGeom_Gprim_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Gprim_MakeInvisible(usdGeom_Gprim_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Gprim_ComputeVisibility(usdGeom_Gprim_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Gprim_GetPurposeVisibilityAttr(usdGeom_Gprim_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Gprim_ComputePurposeInfo(usdGeom_Gprim_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Gprim_ComputePurposeInfo_given_parent(usdGeom_Gprim_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Gprim_ComputePurpose(usdGeom_Gprim_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Gprim_ComputeProxyPrim(usdGeom_Gprim_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Gprim_SetProxyPrim(usdGeom_Gprim_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Gprim_ComputeWorldBound(usdGeom_Gprim_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Gprim_ComputeLocalBound(usdGeom_Gprim_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Gprim_ComputeUntransformedBound(usdGeom_Gprim_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Gprim_ComputeLocalToWorldTransform(usdGeom_Gprim_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Gprim_ComputeParentToWorldTransform(usdGeom_Gprim_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Gprim_IsConcrete(usdGeom_Gprim_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Gprim_IsTyped(usdGeom_Gprim_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Gprim_IsAPISchema(usdGeom_Gprim_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Gprim_IsAppliedAPISchema(usdGeom_Gprim_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Gprim_IsMultipleApplyAPISchema(usdGeom_Gprim_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Gprim_GetSchemaKind(usdGeom_Gprim_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Gprim_GetPrim(usdGeom_Gprim_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Gprim_GetPath(usdGeom_Gprim_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Gprim_GetSchemaClassPrimDefinition(usdGeom_Gprim_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Gprim_new(usd_Prim_t const* param00, usdGeom_Gprim_t** _result);

int usdGeom_Gprim_dtor(usdGeom_Gprim_t* _this);

/// Defines the outgoing trajectory tangent for each point. 
/// Tangents should be the same size as the points attribute.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] tangents = []` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_HermiteCurves_GetTangentsAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetTangentsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateTangentsAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Curves-derived primitives can represent multiple distinct,
/// potentially disconnected curves.  The length of 'curveVertexCounts'
/// gives the number of such curves, and each element describes the
/// number of vertices in the corresponding curve
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] curveVertexCounts` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_HermiteCurves_GetCurveVertexCountsAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetCurveVertexCountsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateCurveVertexCountsAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provides width specification for the curves, whose application
/// will depend on whether the curve is oriented (normals are defined for
/// it), in which case widths are "ribbon width", or unoriented, in which
/// case widths are cylinder width.  'widths' is not a generic Primvar,
/// but the number of elements in this attribute will be determined by
/// its 'interpolation'.  See \ref SetWidthsInterpolation() .  If 'widths'
/// and 'primvars:widths' are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] widths` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_HermiteCurves_GetWidthsAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetWidthsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateWidthsAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// Although 'widths' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which means a width value is specified at the end of each curve segment.
int usdGeom_HermiteCurves_GetWidthsInterpolation(usdGeom_HermiteCurves_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the widths attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetWidthsInterpolation()
int usdGeom_HermiteCurves_SetWidthsInterpolation(usdGeom_HermiteCurves_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Returns the number of curves as defined by the size of the
/// _curveVertexCounts_ array at _timeCode_.
/// 
/// \snippetdoc snippets.dox GetCount
/// \sa GetCurveVertexCountsAttr()
int usdGeom_HermiteCurves_GetCurveCount(usdGeom_HermiteCurves_t const* _this, usd_TimeCode_t timeCode, size_t* _result);

/// The primary geometry attribute for all PointBased
/// primitives, describes points in (local) space.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `point3f[] points` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Point3fArray |
int usdGeom_HermiteCurves_GetPointsAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetPointsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreatePointsAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'velocities' should be used by renderers to 
/// 
/// compute positions between samples for the 'points' attribute, rather
/// than interpolating between neighboring 'points' samples.  This is the
/// only reasonable means of computing motion blur for topologically
/// varying PointBased primitives.  It follows that the length of each
/// 'velocities' sample must match the length of the corresponding
/// 'points' sample.  Velocity is measured in position units per second,
/// as per most simulation software. To convert to position units per
/// UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeom_VelocityInterpolation .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] velocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_HermiteCurves_GetVelocitiesAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateVelocitiesAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'accelerations' should be used with
/// velocities to compute positions between samples for the 'points'
/// attribute rather than interpolating between neighboring 'points'
/// samples. Acceleration is measured in position units per second-squared.
/// To convert to position units per squared UsdTimeCode, divide by the
/// square of UsdStage::GetTimeCodesPerSecond().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] accelerations` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_HermiteCurves_GetAccelerationsAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetAccelerationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateAccelerationsAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provide an object-space orientation for individual points, 
/// which, depending on subclass, may define a surface, curve, or free 
/// points.  Note that 'normals' should not be authored on any Mesh that
/// is subdivided, since the subdivision algorithm will define its own
/// normals. 'normals' is not a generic primvar, but the number of elements
/// in this attribute will be determined by its 'interpolation'.  See
/// \ref SetNormalsInterpolation() . If 'normals' and 'primvars:normals'
/// are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `normal3f[] normals` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Normal3fArray |
int usdGeom_HermiteCurves_GetNormalsAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetNormalsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateNormalsAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// Although 'normals' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which will generally produce smooth shading on a polygonal mesh.
/// To achieve partial or fully faceted shading of a polygonal mesh
/// with normals, one should use UsdGeomTokens->faceVarying or
/// UsdGeomTokens->uniform interpolation.
int usdGeom_HermiteCurves_GetNormalsInterpolation(usdGeom_HermiteCurves_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdGeomPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the normals attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetNormalsInterpolation()
int usdGeom_HermiteCurves_SetNormalsInterpolation(usdGeom_HermiteCurves_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Compute points given the positions, velocities and accelerations
/// at \p time. 
/// 
/// This will return \c false and leave \p points untouched if:
/// - \p points is NULL
/// - one of \p time and \p baseTime is numeric and the other is
///   UsdTimeCode::Default() (they must either both be numeric or both be
///   default)
/// - there is no authored points attribute
/// 
/// If there is no error, we will return \c true and \p points will contain
/// the computed points.
/// 
/// \param points - the out parameter for the new points.  Its size
///                 will depend on the authored data.
/// \param time - UsdTimeCode at which we want to evaluate the transforms
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em accelerations are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
int usdGeom_HermiteCurves_ComputePointsAtTime(usdGeom_HermiteCurves_t const* _this, gf_Vec3fArray_t* points, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, bool* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_HermiteCurves_GetDisplayColorAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateDisplayColorAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_HermiteCurves_GetDisplayOpacityAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateDisplayOpacityAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_HermiteCurves_GetDoubleSidedAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateDoubleSidedAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_HermiteCurves_GetOrientationAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateOrientationAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_HermiteCurves_GetDisplayColorPrimvar(usdGeom_HermiteCurves_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_HermiteCurves_CreateDisplayColorPrimvar(usdGeom_HermiteCurves_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_HermiteCurves_GetExtentAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateExtentAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_HermiteCurves_GetXformOpOrderAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_HermiteCurves_AddXformOp(usdGeom_HermiteCurves_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_HermiteCurves_AddTranslateOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_HermiteCurves_AddScaleOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_HermiteCurves_AddRotateXOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_HermiteCurves_AddRotateYOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_HermiteCurves_AddRotateZOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_HermiteCurves_AddRotateXYZOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_HermiteCurves_AddRotateXZYOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_HermiteCurves_AddRotateYXZOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_HermiteCurves_AddRotateYZXOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_HermiteCurves_AddRotateZXYOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_HermiteCurves_AddRotateZYXOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_HermiteCurves_AddOrientOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_HermiteCurves_AddTransformOp(usdGeom_HermiteCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_HermiteCurves_SetResetXformStack(usdGeom_HermiteCurves_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_HermiteCurves_SetXformOpOrder(usdGeom_HermiteCurves_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_HermiteCurves_GetOrderedXformOps(usdGeom_HermiteCurves_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_HermiteCurves_ClearXformOpOrder(usdGeom_HermiteCurves_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_HermiteCurves_MakeMatrixXform(usdGeom_HermiteCurves_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_HermiteCurves_TransformMightBeTimeVarying(usdGeom_HermiteCurves_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_HermiteCurves_TransformMightBeTimeVarying_using(usdGeom_HermiteCurves_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_HermiteCurves_GetTimeSamples(usdGeom_HermiteCurves_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_HermiteCurves_GetTimeSamplesInInterval(usdGeom_HermiteCurves_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_HermiteCurves_GetLocalTransformation(usdGeom_HermiteCurves_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_HermiteCurves_GetLocalTransformation_with_ops(usdGeom_HermiteCurves_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_HermiteCurves_GetVisibilityAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreateVisibilityAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_HermiteCurves_GetPurposeAttr(usdGeom_HermiteCurves_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_HermiteCurves_CreatePurposeAttr(usdGeom_HermiteCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_HermiteCurves_GetProxyPrimRel(usdGeom_HermiteCurves_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_HermiteCurves_CreateProxyPrimRel(usdGeom_HermiteCurves_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_HermiteCurves_MakeVisible(usdGeom_HermiteCurves_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_HermiteCurves_MakeInvisible(usdGeom_HermiteCurves_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_HermiteCurves_ComputeVisibility(usdGeom_HermiteCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_HermiteCurves_GetPurposeVisibilityAttr(usdGeom_HermiteCurves_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_HermiteCurves_ComputePurposeInfo(usdGeom_HermiteCurves_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_HermiteCurves_ComputePurposeInfo_given_parent(usdGeom_HermiteCurves_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_HermiteCurves_ComputePurpose(usdGeom_HermiteCurves_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_HermiteCurves_ComputeProxyPrim(usdGeom_HermiteCurves_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_HermiteCurves_SetProxyPrim(usdGeom_HermiteCurves_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_HermiteCurves_ComputeWorldBound(usdGeom_HermiteCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_HermiteCurves_ComputeLocalBound(usdGeom_HermiteCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_HermiteCurves_ComputeUntransformedBound(usdGeom_HermiteCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_HermiteCurves_ComputeLocalToWorldTransform(usdGeom_HermiteCurves_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_HermiteCurves_ComputeParentToWorldTransform(usdGeom_HermiteCurves_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_HermiteCurves_IsConcrete(usdGeom_HermiteCurves_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_HermiteCurves_IsTyped(usdGeom_HermiteCurves_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_HermiteCurves_IsAPISchema(usdGeom_HermiteCurves_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_HermiteCurves_IsAppliedAPISchema(usdGeom_HermiteCurves_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_HermiteCurves_IsMultipleApplyAPISchema(usdGeom_HermiteCurves_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_HermiteCurves_GetSchemaKind(usdGeom_HermiteCurves_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_HermiteCurves_GetPrim(usdGeom_HermiteCurves_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_HermiteCurves_GetPath(usdGeom_HermiteCurves_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_HermiteCurves_GetSchemaClassPrimDefinition(usdGeom_HermiteCurves_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_HermiteCurves_new(usd_Prim_t const* param00, usdGeom_HermiteCurves_t** _result);

int usdGeom_HermiteCurves_dtor(usdGeom_HermiteCurves_t* _this);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Imageable_GetVisibilityAttr(usdGeom_Imageable_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Imageable_CreateVisibilityAttr(usdGeom_Imageable_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Imageable_GetPurposeAttr(usdGeom_Imageable_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Imageable_CreatePurposeAttr(usdGeom_Imageable_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Imageable_GetProxyPrimRel(usdGeom_Imageable_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Imageable_CreateProxyPrimRel(usdGeom_Imageable_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Imageable_MakeVisible(usdGeom_Imageable_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Imageable_MakeInvisible(usdGeom_Imageable_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Imageable_ComputeVisibility(usdGeom_Imageable_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Imageable_GetPurposeVisibilityAttr(usdGeom_Imageable_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Imageable_ComputePurposeInfo(usdGeom_Imageable_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Imageable_ComputePurposeInfo_given_parent(usdGeom_Imageable_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Imageable_ComputePurpose(usdGeom_Imageable_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Imageable_ComputeProxyPrim(usdGeom_Imageable_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Imageable_SetProxyPrim(usdGeom_Imageable_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Imageable_ComputeWorldBound(usdGeom_Imageable_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Imageable_ComputeLocalBound(usdGeom_Imageable_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Imageable_ComputeUntransformedBound(usdGeom_Imageable_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Imageable_ComputeLocalToWorldTransform(usdGeom_Imageable_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Imageable_ComputeParentToWorldTransform(usdGeom_Imageable_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Imageable_IsConcrete(usdGeom_Imageable_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Imageable_IsTyped(usdGeom_Imageable_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Imageable_IsAPISchema(usdGeom_Imageable_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Imageable_IsAppliedAPISchema(usdGeom_Imageable_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Imageable_IsMultipleApplyAPISchema(usdGeom_Imageable_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Imageable_GetSchemaKind(usdGeom_Imageable_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Imageable_GetPrim(usdGeom_Imageable_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Imageable_GetPath(usdGeom_Imageable_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Imageable_GetSchemaClassPrimDefinition(usdGeom_Imageable_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Imageable_new(usd_Prim_t const* param00, usdGeom_Imageable_t** _result);

int usdGeom_Imageable_dtor(usdGeom_Imageable_t* _this);

int usdGeom_ImageablePurposeInfo_dtor(usdGeom_ImageablePurposeInfo_t* _this);

/// Flat list of the index (into the _points_ attribute) of each
/// vertex of each face in the mesh.  If this attribute has more than
/// one timeSample, the mesh is considered to be topologically varying.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] faceVertexIndices` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_Mesh_GetFaceVertexIndicesAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetFaceVertexIndicesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateFaceVertexIndicesAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provides the number of vertices in each face of the mesh, 
/// which is also the number of consecutive indices in _faceVertexIndices_
/// that define the face.  The length of this attribute is the number of
/// faces in the mesh.  If this attribute has more than
/// one timeSample, the mesh is considered to be topologically varying.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] faceVertexCounts` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_Mesh_GetFaceVertexCountsAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetFaceVertexCountsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateFaceVertexCountsAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The subdivision scheme to be applied to the surface.
/// Valid values are:
/// 
/// - __catmullClark__: The default, Catmull-Clark subdivision; preferred
/// for quad-dominant meshes (generalizes B-splines); interpolation
/// of point data is smooth (non-linear)
/// - __loop__: Loop subdivision; preferred for purely triangular meshes;
/// interpolation of point data is smooth (non-linear)
/// - __bilinear__: Subdivision reduces all faces to quads (topologically
/// similar to "catmullClark"); interpolation of point data is bilinear
/// - __none__: No subdivision, i.e. a simple polygonal mesh; interpolation
/// of point data is linear
/// 
/// Polygonal meshes are typically lighter weight and faster to render,
/// depending on renderer and render mode.  Use of "bilinear" will produce
/// a similar shape to a polygonal mesh and may offer additional guarantees
/// of watertightness and additional subdivision features (e.g. holes) but
/// may also not respect authored normals.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token subdivisionScheme = "catmullClark"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | catmullClark, loop, bilinear, none |
int usdGeom_Mesh_GetSubdivisionSchemeAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetSubdivisionSchemeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateSubdivisionSchemeAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Specifies how subdivision is applied for faces adjacent to
/// boundary edges and boundary points. Valid values correspond to choices
/// available in OpenSubdiv:
/// 
/// - __none__: No boundary interpolation is applied and boundary faces are
/// effectively treated as holes
/// - __edgeOnly__: A sequence of boundary edges defines a smooth curve to
/// which the edges of subdivided boundary faces converge
/// - __edgeAndCorner__: The default, similar to "edgeOnly" but the smooth
/// boundary curve is made sharp at corner points
/// 
/// These are illustrated and described in more detail in the OpenSubdiv
/// documentation:
/// https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html#boundary-interpolation-rules
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token interpolateBoundary = "edgeAndCorner"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | none, edgeOnly, edgeAndCorner |
int usdGeom_Mesh_GetInterpolateBoundaryAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetInterpolateBoundaryAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateInterpolateBoundaryAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Specifies how elements of a primvar of interpolation type
/// "faceVarying" are interpolated for subdivision surfaces. Interpolation
/// can be as smooth as a "vertex" primvar or constrained to be linear at
/// features specified by several options.  Valid values correspond to
/// choices available in OpenSubdiv:
/// 
/// - __none__: No linear constraints or sharpening, smooth everywhere
/// - __cornersOnly__: Sharpen corners of discontinuous boundaries only,
/// smooth everywhere else
/// - __cornersPlus1__: The default, same as "cornersOnly" plus additional
/// sharpening at points where three or more distinct face-varying
/// values occur
/// - __cornersPlus2__: Same as "cornersPlus1" plus additional sharpening
/// at points with at least one discontinuous boundary corner or
/// only one discontinuous boundary edge (a dart)
/// - __boundaries__: Piecewise linear along discontinuous boundaries,
/// smooth interior
/// - __all__: Piecewise linear everywhere
/// 
/// These are illustrated and described in more detail in the OpenSubdiv
/// documentation:
/// https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html#face-varying-interpolation-rules
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token faceVaryingLinearInterpolation = "cornersPlus1"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | none, cornersOnly, cornersPlus1, cornersPlus2, boundaries, all |
int usdGeom_Mesh_GetFaceVaryingLinearInterpolationAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetFaceVaryingLinearInterpolationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateFaceVaryingLinearInterpolationAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Specifies an option to the subdivision rules for the
/// Catmull-Clark scheme to try and improve undesirable artifacts when
/// subdividing triangles.  Valid values are "catmullClark" for the
/// standard rules (the default) and "smooth" for the improvement.
/// 
/// See https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html#triangle-subdivision-rule
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token triangleSubdivisionRule = "catmullClark"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | catmullClark, smooth |
int usdGeom_Mesh_GetTriangleSubdivisionRuleAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetTriangleSubdivisionRuleAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateTriangleSubdivisionRuleAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The indices of all faces that should be treated as holes,
/// i.e. made invisible. This is traditionally a feature of subdivision
/// surfaces and not generally applied to polygonal meshes.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] holeIndices = []` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_Mesh_GetHoleIndicesAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetHoleIndicesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateHoleIndicesAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The indices of points for which a corresponding sharpness
/// value is specified in _cornerSharpnesses_ (so the size of this array
/// must match that of _cornerSharpnesses_).
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] cornerIndices = []` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_Mesh_GetCornerIndicesAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetCornerIndicesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateCornerIndicesAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The sharpness values associated with a corresponding set of
/// points specified in _cornerIndices_ (so the size of this array must
/// match that of _cornerIndices_). Use the constant `SHARPNESS_INFINITE`
/// for a perfectly sharp corner.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] cornerSharpnesses = []` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Mesh_GetCornerSharpnessesAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetCornerSharpnessesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateCornerSharpnessesAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The indices of points grouped into sets of successive pairs
/// that identify edges to be creased. The size of this array must be
/// equal to the sum of all elements of the _creaseLengths_ attribute.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] creaseIndices = []` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_Mesh_GetCreaseIndicesAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetCreaseIndicesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateCreaseIndicesAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The length of this array specifies the number of creases
/// (sets of adjacent sharpened edges) on the mesh. Each element gives
/// the number of points of each crease, whose indices are successively
/// laid out in the _creaseIndices_ attribute. Since each crease must
/// be at least one edge long, each element of this array must be at
/// least two.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] creaseLengths = []` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_Mesh_GetCreaseLengthsAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetCreaseLengthsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateCreaseLengthsAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The per-crease or per-edge sharpness values for all creases.
/// Since _creaseLengths_ encodes the number of points in each crease,
/// the number of elements in this array will be either len(creaseLengths)
/// or the sum over all X of (creaseLengths[X] - 1). Note that while
/// the RI spec allows each crease to have either a single sharpness
/// or a value per-edge, USD will encode either a single sharpness
/// per crease on a mesh, or sharpnesses for all edges making up
/// the creases on a mesh.  Use the constant `SHARPNESS_INFINITE` for a
/// perfectly sharp crease.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] creaseSharpnesses = []` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Mesh_GetCreaseSharpnessesAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetCreaseSharpnessesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateCreaseSharpnessesAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Returns the number of faces as defined by the size of the
/// _faceVertexCounts_ array at _timeCode_.
/// 
/// \snippetdoc snippets.dox GetCount
/// \sa GetFaceVertexCountsAttr()
int usdGeom_Mesh_GetFaceCount(usdGeom_Mesh_t const* _this, usd_TimeCode_t timeCode, size_t* _result);

/// The primary geometry attribute for all PointBased
/// primitives, describes points in (local) space.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `point3f[] points` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Point3fArray |
int usdGeom_Mesh_GetPointsAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetPointsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreatePointsAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'velocities' should be used by renderers to 
/// 
/// compute positions between samples for the 'points' attribute, rather
/// than interpolating between neighboring 'points' samples.  This is the
/// only reasonable means of computing motion blur for topologically
/// varying PointBased primitives.  It follows that the length of each
/// 'velocities' sample must match the length of the corresponding
/// 'points' sample.  Velocity is measured in position units per second,
/// as per most simulation software. To convert to position units per
/// UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeom_VelocityInterpolation .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] velocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_Mesh_GetVelocitiesAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateVelocitiesAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'accelerations' should be used with
/// velocities to compute positions between samples for the 'points'
/// attribute rather than interpolating between neighboring 'points'
/// samples. Acceleration is measured in position units per second-squared.
/// To convert to position units per squared UsdTimeCode, divide by the
/// square of UsdStage::GetTimeCodesPerSecond().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] accelerations` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_Mesh_GetAccelerationsAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetAccelerationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateAccelerationsAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provide an object-space orientation for individual points, 
/// which, depending on subclass, may define a surface, curve, or free 
/// points.  Note that 'normals' should not be authored on any Mesh that
/// is subdivided, since the subdivision algorithm will define its own
/// normals. 'normals' is not a generic primvar, but the number of elements
/// in this attribute will be determined by its 'interpolation'.  See
/// \ref SetNormalsInterpolation() . If 'normals' and 'primvars:normals'
/// are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `normal3f[] normals` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Normal3fArray |
int usdGeom_Mesh_GetNormalsAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetNormalsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateNormalsAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// Although 'normals' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which will generally produce smooth shading on a polygonal mesh.
/// To achieve partial or fully faceted shading of a polygonal mesh
/// with normals, one should use UsdGeomTokens->faceVarying or
/// UsdGeomTokens->uniform interpolation.
int usdGeom_Mesh_GetNormalsInterpolation(usdGeom_Mesh_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdGeomPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the normals attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetNormalsInterpolation()
int usdGeom_Mesh_SetNormalsInterpolation(usdGeom_Mesh_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Compute points given the positions, velocities and accelerations
/// at \p time. 
/// 
/// This will return \c false and leave \p points untouched if:
/// - \p points is NULL
/// - one of \p time and \p baseTime is numeric and the other is
///   UsdTimeCode::Default() (they must either both be numeric or both be
///   default)
/// - there is no authored points attribute
/// 
/// If there is no error, we will return \c true and \p points will contain
/// the computed points.
/// 
/// \param points - the out parameter for the new points.  Its size
///                 will depend on the authored data.
/// \param time - UsdTimeCode at which we want to evaluate the transforms
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em accelerations are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
int usdGeom_Mesh_ComputePointsAtTime(usdGeom_Mesh_t const* _this, gf_Vec3fArray_t* points, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, bool* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Mesh_GetDisplayColorAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateDisplayColorAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Mesh_GetDisplayOpacityAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateDisplayOpacityAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Mesh_GetDoubleSidedAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateDoubleSidedAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Mesh_GetOrientationAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateOrientationAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Mesh_GetDisplayColorPrimvar(usdGeom_Mesh_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Mesh_CreateDisplayColorPrimvar(usdGeom_Mesh_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Mesh_GetExtentAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateExtentAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Mesh_GetXformOpOrderAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Mesh_AddXformOp(usdGeom_Mesh_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Mesh_AddTranslateOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Mesh_AddScaleOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Mesh_AddRotateXOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Mesh_AddRotateYOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Mesh_AddRotateZOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Mesh_AddRotateXYZOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Mesh_AddRotateXZYOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Mesh_AddRotateYXZOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Mesh_AddRotateYZXOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Mesh_AddRotateZXYOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Mesh_AddRotateZYXOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Mesh_AddOrientOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Mesh_AddTransformOp(usdGeom_Mesh_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Mesh_SetResetXformStack(usdGeom_Mesh_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Mesh_SetXformOpOrder(usdGeom_Mesh_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Mesh_GetOrderedXformOps(usdGeom_Mesh_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Mesh_ClearXformOpOrder(usdGeom_Mesh_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Mesh_MakeMatrixXform(usdGeom_Mesh_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Mesh_TransformMightBeTimeVarying(usdGeom_Mesh_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Mesh_TransformMightBeTimeVarying_using(usdGeom_Mesh_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Mesh_GetTimeSamples(usdGeom_Mesh_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Mesh_GetTimeSamplesInInterval(usdGeom_Mesh_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Mesh_GetLocalTransformation(usdGeom_Mesh_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Mesh_GetLocalTransformation_with_ops(usdGeom_Mesh_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Mesh_GetVisibilityAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreateVisibilityAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Mesh_GetPurposeAttr(usdGeom_Mesh_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Mesh_CreatePurposeAttr(usdGeom_Mesh_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Mesh_GetProxyPrimRel(usdGeom_Mesh_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Mesh_CreateProxyPrimRel(usdGeom_Mesh_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Mesh_MakeVisible(usdGeom_Mesh_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Mesh_MakeInvisible(usdGeom_Mesh_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Mesh_ComputeVisibility(usdGeom_Mesh_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Mesh_GetPurposeVisibilityAttr(usdGeom_Mesh_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Mesh_ComputePurposeInfo(usdGeom_Mesh_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Mesh_ComputePurposeInfo_given_parent(usdGeom_Mesh_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Mesh_ComputePurpose(usdGeom_Mesh_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Mesh_ComputeProxyPrim(usdGeom_Mesh_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Mesh_SetProxyPrim(usdGeom_Mesh_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Mesh_ComputeWorldBound(usdGeom_Mesh_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Mesh_ComputeLocalBound(usdGeom_Mesh_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Mesh_ComputeUntransformedBound(usdGeom_Mesh_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Mesh_ComputeLocalToWorldTransform(usdGeom_Mesh_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Mesh_ComputeParentToWorldTransform(usdGeom_Mesh_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Mesh_IsConcrete(usdGeom_Mesh_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Mesh_IsTyped(usdGeom_Mesh_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Mesh_IsAPISchema(usdGeom_Mesh_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Mesh_IsAppliedAPISchema(usdGeom_Mesh_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Mesh_IsMultipleApplyAPISchema(usdGeom_Mesh_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Mesh_GetSchemaKind(usdGeom_Mesh_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Mesh_GetPrim(usdGeom_Mesh_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Mesh_GetPath(usdGeom_Mesh_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Mesh_GetSchemaClassPrimDefinition(usdGeom_Mesh_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Mesh_new(usd_Prim_t const* param00, usdGeom_Mesh_t** _result);

int usdGeom_Mesh_dtor(usdGeom_Mesh_t* _this);

/// Alternate imaging mode; applied to this prim or child prims
/// where \em model:applyDrawMode is true, or where the prim
/// has kind \em component. See \ref UsdGeomModelAPI_drawMode
/// for mode descriptions.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token model:drawMode = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | origin, bounds, cards, default, inherited |
int usdGeom_ModelAPI_GetModelDrawModeAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// See GetModelDrawModeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_ModelAPI_CreateModelDrawModeAttr(usdGeom_ModelAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The base color of imaging prims inserted for alternate
/// imaging modes. For \em origin and \em bounds modes, this
/// controls line color; for \em cards mode, this controls the
/// fallback quad color.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform float3 model:drawModeColor = (0.18, 0.18, 0.18)` |
/// | C++ Type | GfVec3f |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3 |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_ModelAPI_GetModelDrawModeColorAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// See GetModelDrawModeColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_ModelAPI_CreateModelDrawModeColorAttr(usdGeom_ModelAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The geometry to generate for imaging prims inserted for \em
/// cards imaging mode. See \ref UsdGeomModelAPI_cardGeometry for
/// geometry descriptions.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token model:cardGeometry = "cross"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | cross, box, fromTexture |
int usdGeom_ModelAPI_GetModelCardGeometryAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// See GetModelCardGeometryAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_ModelAPI_CreateModelCardGeometryAttr(usdGeom_ModelAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// In \em cards imaging mode, the texture applied to the X+ quad.
/// The texture axes (s,t) are mapped to model-space axes (-y, -z).
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `asset model:cardTextureXPos` |
/// | C++ Type | SdfAssetPath |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Asset |
int usdGeom_ModelAPI_GetModelCardTextureXPosAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// See GetModelCardTextureXPosAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_ModelAPI_CreateModelCardTextureXPosAttr(usdGeom_ModelAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// In \em cards imaging mode, the texture applied to the X- quad.
/// The texture axes (s,t) are mapped to model-space axes (y, -z).
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `asset model:cardTextureXNeg` |
/// | C++ Type | SdfAssetPath |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Asset |
int usdGeom_ModelAPI_GetModelCardTextureXNegAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// See GetModelCardTextureXNegAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_ModelAPI_CreateModelCardTextureXNegAttr(usdGeom_ModelAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// In \em cards imaging mode, the texture applied to the Y+ quad.
/// The texture axes (s,t) are mapped to model-space axes (x, -z).
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `asset model:cardTextureYPos` |
/// | C++ Type | SdfAssetPath |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Asset |
int usdGeom_ModelAPI_GetModelCardTextureYPosAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// See GetModelCardTextureYPosAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_ModelAPI_CreateModelCardTextureYPosAttr(usdGeom_ModelAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// In \em cards imaging mode, the texture applied to the Y- quad.
/// The texture axes (s,t) are mapped to model-space axes (-x, -z).
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `asset model:cardTextureYNeg` |
/// | C++ Type | SdfAssetPath |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Asset |
int usdGeom_ModelAPI_GetModelCardTextureYNegAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// See GetModelCardTextureYNegAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_ModelAPI_CreateModelCardTextureYNegAttr(usdGeom_ModelAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// In \em cards imaging mode, the texture applied to the Z+ quad.
/// The texture axes (s,t) are mapped to model-space axes (x, -y).
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `asset model:cardTextureZPos` |
/// | C++ Type | SdfAssetPath |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Asset |
int usdGeom_ModelAPI_GetModelCardTextureZPosAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// See GetModelCardTextureZPosAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_ModelAPI_CreateModelCardTextureZPosAttr(usdGeom_ModelAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// In \em cards imaging mode, the texture applied to the Z- quad.
/// The texture axes (s,t) are mapped to model-space axes (-x, -y).
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `asset model:cardTextureZNeg` |
/// | C++ Type | SdfAssetPath |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Asset |
int usdGeom_ModelAPI_GetModelCardTextureZNegAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// See GetModelCardTextureZNegAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_ModelAPI_CreateModelCardTextureZNegAttr(usdGeom_ModelAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Calculate the effective model:drawMode of this prim.
/// 
/// If the draw mode is authored on this prim, it's used. Otherwise,
/// the fallback value is "inherited", which defers to the parent opinion.
/// The first non-inherited opinion found walking from this prim towards
/// the root is used.  If the attribute isn't set on any ancestors, we
/// return "default" (meaning, disable "drawMode" geometry).
/// 
/// If this function is being called in a traversal context to compute 
/// the draw mode of an entire hierarchy of prims, it would be beneficial
/// to cache and pass in the computed parent draw-mode via the 
/// \p parentDrawMode parameter. This avoids repeated upward traversal to 
/// look for ancestor opinions.
/// 
/// When \p parentDrawMode is empty (or unspecified), this function does 
/// an upward traversal to find the closest ancestor with an authored 
/// model:drawMode.
/// 
/// \sa GetModelDrawModeAttr()
int usdGeom_ModelAPI_ComputeModelDrawMode(usdGeom_ModelAPI_t const* _this, tf_Token_t const* parentDrawMode, tf_Token_t* _result);

/// Retrieve the authored value (if any) of this model's "extentsHint"
/// 
/// Persistent caching of bounds in USD is a potentially perilous endeavor,
/// given that:
/// \li It is very easy to add overrides in new super-layers that 
/// invalidate the cached bounds, and no practical way to automatically
/// detect when this happens
/// \li It is possible for references to be allowed to "float", so that
/// asset updates can flow directly into cached scenes.  Such changes in
/// referenced scene description can also invalidate cached bounds in
/// referencing layers.
/// 
/// For these reasons, as a general rule, we only persistently cache
/// leaf gprim extents in object space.  However, even with cached gprim
/// extents, computing bounds can be expensive.  Since model-level bounds
/// are so useful to many graphics applications, we make an exception,
/// with some caveats. The "extentsHint" should be considered entirely
/// optional (whereas gprim extent is not); if authored, it should 
/// contains the extents for various values of gprim purposes.
/// The extents for different values of purpose are stored in a linear Vec3f 
/// array as pairs of GfVec3f values in the order specified by 
/// UsdGeomImageable::GetOrderedPurposeTokens(). This list is trimmed to
/// only include non-empty extents. i.e., if a model has only default and 
/// render geoms, then it will only have 4 GfVec3f values in its 
/// extentsHint array.  We do not skip over zero extents, so if a model
/// has only default and proxy geom, we will author six GfVec3f's, the 
/// middle two representing an zero extent for render geometry.
/// 
/// A UsdGeomBBoxCache can be configured to first consult the cached
/// extents when evaluating model roots, rather than descending into the
/// models for the full computation.  This is not the default behavior,
/// and gives us a convenient way to validate that the cached 
/// extentsHint is still valid.
/// 
/// \return \c true if a value was fetched; \c false if no value was
/// authored, or on error.  It is an error to make this query of a prim
/// that is not a model root.
/// 
/// \sa UsdGeomImageable::GetPurposeAttr(), 
///     UsdGeomImageable::GetOrderedPurposeTokens()
int usdGeom_ModelAPI_GetExtentsHint(usdGeom_ModelAPI_t const* _this, gf_Vec3fArray_t* extents, usd_TimeCode_t const* time, bool* _result);

/// Authors the extentsHint array for this model at the given time.
/// 
/// \sa GetExtentsHint()
int usdGeom_ModelAPI_SetExtentsHint(usdGeom_ModelAPI_t const* _this, gf_Vec3fArray_t const* extents, usd_TimeCode_t const* time, bool* _result);

/// Returns the custom 'extentsHint' attribute if it exits.
int usdGeom_ModelAPI_GetExtentsHintAttr(usdGeom_ModelAPI_t const* _this, usd_Attribute_t* _result);

/// Compute a value suitable for passing to SetExtentsHint().
/// 
/// If this model is a UsdGeomBoundable, call
/// UsdGeomBoundable::ComputeExtentFromPlugins() with the \p bboxCache 's
/// time code.  If that function returns true, then populate the returned
/// array with the min and max repeated according to the number of tokens in
/// UsdGeomImageable::GetOrderedPurposeTokens().  Otherwise return an array
/// with a single empty range.
/// 
/// If this model is not a UsdGeomBoundable, populate the return value by
/// calling UsdGeomBBoxCache::ComputeUntransformedBound() (and
/// GfBBox3d::ComputeAlignedBox() on that result) for each token in
/// UsdGeomImageable::GetOrderedPurposeTokens().
/// 
/// In either case the, Nth successive pair of entries in the returned array
/// will be the min and max coordinates of the extent corresponding to the
/// Nth token in UsdGeomImageable::GetOrderedPurposeTokens(), except
/// trailing empty boxes are omitted, unless all boxes are empty in which
/// case the result is a single empty box.
/// 
/// For example, if GetOrderedPurposeTokens() is [default, render, proxy,
/// guide] and this function returns [(0,0,0), (1,1,1), (+FLT_MAX),
/// (-FLT_MIN), (0,0,0), (1,1,1)] then this means that the computed extents
/// for 'default' and 'proxy' purpose are [(0,0,0), (1,1,1)] and the extents
/// for 'render' and 'guide' purposes are empty.
/// 
/// This function modifies \p bboxCache's included purposes.
/// 
/// \note \p bboxCache must not be used concurrently during the execution of
/// this function.
int usdGeom_ModelAPI_ComputeExtentsHint(usdGeom_ModelAPI_t const* _this, usdGeom_BBoxCache_t* bboxCache, gf_Vec3fArray_t* _result);

/// Get the constraint target with the given name, \p constraintName.
/// 
/// If the requested constraint target does not exist, then an invalid 
/// UsdConstraintTarget object is returned.
int usdGeom_ModelAPI_GetConstraintTarget(usdGeom_ModelAPI_t const* _this, std_String_t const* constraintName, usdGeom_ConstraintTarget_t* _result);

/// Returns all the constraint targets belonging to the model.
/// 
/// Only valid constraint targets in the "constraintTargets" namespace 
/// are returned by this method.
int usdGeom_ModelAPI_GetConstraintTargets(usdGeom_ModelAPI_t const* _this, usdGeom_ConstraintTargetVector_t* _result);

/// Creates a new constraint target with the given name, \p constraintName.
/// 
/// If the constraint target already exists, then the existing target is 
/// returned. If it does not exist, a new one is created and returned.
int usdGeom_ModelAPI_CreateConstraintTarget(usdGeom_ModelAPI_t const* _this, std_String_t const* constraintName, usdGeom_ConstraintTarget_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_ModelAPI_IsConcrete(usdGeom_ModelAPI_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_ModelAPI_IsTyped(usdGeom_ModelAPI_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_ModelAPI_IsAPISchema(usdGeom_ModelAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_ModelAPI_IsAppliedAPISchema(usdGeom_ModelAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_ModelAPI_IsMultipleApplyAPISchema(usdGeom_ModelAPI_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_ModelAPI_GetSchemaKind(usdGeom_ModelAPI_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_ModelAPI_GetPrim(usdGeom_ModelAPI_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_ModelAPI_GetPath(usdGeom_ModelAPI_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_ModelAPI_GetSchemaClassPrimDefinition(usdGeom_ModelAPI_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_ModelAPI_new(usd_Prim_t const* param00, usdGeom_ModelAPI_t** _result);

int usdGeom_ModelAPI_dtor(usdGeom_ModelAPI_t* _this);

/// BlurScale is an __inherited__ float attribute that stipulates
/// the rendered motion blur (as typically specified via UsdGeomCamera's
/// _shutter:open_ and _shutter:close_ properties) should be scaled for
/// __all objects__ at and beneath the prim in namespace on which the
/// _motion:blurScale_ value is specified.
/// 
/// Without changing any other data in the scene, _blurScale_ allows artists to
/// "dial in" the amount of blur on a per-object basis.  A _blurScale_
/// value of zero removes all blur, a value of 0.5 reduces blur by half, 
/// and a value of 2.0 doubles the blur.  The legal range for _blurScale_
/// is [0, inf), although very high values may result in extremely expensive
/// renders, and may exceed the capabilities of some renderers.
/// 
/// Although renderers are free to implement this feature however they see
/// fit, see \ref UsdGeomMotionAPI_blurScale for our guidance on implementing
/// the feature universally and efficiently.
/// 
/// \sa ComputeMotionBlurScale()
/// 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float motion:blurScale = 1` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_MotionAPI_GetMotionBlurScaleAttr(usdGeom_MotionAPI_t const* _this, usd_Attribute_t* _result);

/// See GetMotionBlurScaleAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_MotionAPI_CreateMotionBlurScaleAttr(usdGeom_MotionAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// \deprecated
/// 
/// VelocityScale is an **inherited** float attribute that
/// velocity-based schemas (e.g. PointBased, PointInstancer) can consume
/// to compute interpolated positions and orientations by applying
/// velocity and angularVelocity, which is required for interpolating 
/// between samples when topology is varying over time.  Although these 
/// quantities are generally physically computed by a simulator, sometimes 
/// we require more or less motion-blur to achieve the desired look.  
/// VelocityScale allows artists to dial-in, as a post-sim correction, 
/// a scale factor to be applied to the velocity prior to computing 
/// interpolated positions from it.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float motion:velocityScale = 1` |
/// | C++ Type | float |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float |
int usdGeom_MotionAPI_GetVelocityScaleAttr(usdGeom_MotionAPI_t const* _this, usd_Attribute_t* _result);

/// See GetVelocityScaleAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_MotionAPI_CreateVelocityScaleAttr(usdGeom_MotionAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Determines the number of position or transformation samples
/// created when motion is described by attributes contributing non-linear
/// terms.
/// 
/// To give an example, imagine an application (such as a
/// renderer) consuming 'points' and the USD document also
/// contains 'accelerations' for the same prim. Unless the
/// application can consume these 'accelerations' itself, an
/// intermediate layer has to compute samples within the sampling
/// interval for the point positions based on the value of
/// 'points', 'velocities' and 'accelerations'. The number of these
/// samples is given by 'nonlinearSampleCount'. The samples are
/// equally spaced within the sampling interval.
/// 
/// Another example involves the PointInstancer where
/// 'nonlinearSampleCount' is relevant when 'angularVelocities'
/// or 'accelerations' are authored.
/// 
/// 'nonlinearSampleCount' is an **inherited** attribute, also
/// see ComputeNonlinearSampleCount()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int motion:nonlinearSampleCount = 3` |
/// | C++ Type | int |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Int |
int usdGeom_MotionAPI_GetNonlinearSampleCountAttr(usdGeom_MotionAPI_t const* _this, usd_Attribute_t* _result);

/// See GetNonlinearSampleCountAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_MotionAPI_CreateNonlinearSampleCountAttr(usdGeom_MotionAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// \deprecated
/// 
/// Compute the inherited value of *velocityScale* at \p time, i.e. the 
/// authored value on the prim closest to this prim in namespace, resolved
/// upwards through its ancestors in namespace.
/// 
/// \return the inherited value, or 1.0 if neither the prim nor any
/// of its ancestors possesses an authored value.
/// 
/// \note this is a reference implementation that is not particularly 
/// efficient if evaluating over many prims, because it does not share
/// inherited results.
int usdGeom_MotionAPI_ComputeVelocityScale(usdGeom_MotionAPI_t const* _this, usd_TimeCode_t time, float* _result);

/// Compute the inherited value of *motion:blurScale* at \p time, i.e. the 
/// authored value on the prim closest to this prim in namespace, resolved
/// upwards through its ancestors in namespace.
/// 
/// \return the inherited value, or 1.0 if neither the prim nor any
/// of its ancestors possesses an authored value.
/// 
/// \note this is a reference implementation that is not particularly 
/// efficient if evaluating over many prims, because it does not share
/// inherited results.
int usdGeom_MotionAPI_ComputeMotionBlurScale(usdGeom_MotionAPI_t const* _this, usd_TimeCode_t time, float* _result);

/// Compute the inherited value of *nonlinearSampleCount* at \p time,
/// i.e. the authored value on the prim closest to this prim in namespace,
/// resolved upwards through its ancestors in namespace.
/// 
/// \return the inherited value, or 3 if neither the prim nor any
/// of its ancestors possesses an authored value.
/// 
/// \note this is a reference implementation that is not particularly 
/// efficient if evaluating over many prims, because it does not share
/// inherited results.
int usdGeom_MotionAPI_ComputeNonlinearSampleCount(usdGeom_MotionAPI_t const* _this, usd_TimeCode_t time, int* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_MotionAPI_IsConcrete(usdGeom_MotionAPI_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_MotionAPI_IsTyped(usdGeom_MotionAPI_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_MotionAPI_IsAPISchema(usdGeom_MotionAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_MotionAPI_IsAppliedAPISchema(usdGeom_MotionAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_MotionAPI_IsMultipleApplyAPISchema(usdGeom_MotionAPI_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_MotionAPI_GetSchemaKind(usdGeom_MotionAPI_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_MotionAPI_GetPrim(usdGeom_MotionAPI_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_MotionAPI_GetPath(usdGeom_MotionAPI_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_MotionAPI_GetSchemaClassPrimDefinition(usdGeom_MotionAPI_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_MotionAPI_new(usd_Prim_t const* param00, usdGeom_MotionAPI_t** _result);

int usdGeom_MotionAPI_dtor(usdGeom_MotionAPI_t* _this);

/// Order of the curve.  Order must be positive and is
/// equal to the degree of the polynomial basis to be evaluated, plus 1.
/// Its value for the 'i'th curve must be less than or equal to
/// curveVertexCount[i]
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] order = []` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_NurbsCurves_GetOrderAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetOrderAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateOrderAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Knot vector providing curve parameterization.
/// The length of the slice of the array for the ith curve 
/// must be ( curveVertexCount[i] + order[i] ), and its
/// entries must take on monotonically increasing values.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double[] knots` |
/// | C++ Type | VtArray<double> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->DoubleArray |
int usdGeom_NurbsCurves_GetKnotsAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetKnotsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateKnotsAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provides the minimum and maximum parametric values (as defined
/// by knots) over which the curve is actually defined.  The minimum must 
/// be less than the maximum, and greater than or equal to the value of the 
/// knots['i'th curve slice][order[i]-1]. The maxium must be less 
/// than or equal to the last element's value in knots['i'th curve slice].
/// Range maps to (vmin, vmax) in the RenderMan spec.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double2[] ranges` |
/// | C++ Type | VtArray<GfVec2d> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double2Array |
int usdGeom_NurbsCurves_GetRangesAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetRangesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateRangesAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Optionally provides "w" components for each control point,
/// thus must be the same length as the points attribute.  If authored,
/// the curve will be rational.  If unauthored, the curve will be
/// polynomial, i.e. weight for all points is 1.0.
/// \note Some DCC's pre-weight the \em points, but in this schema, 
/// \em points are not pre-weighted.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double[] pointWeights` |
/// | C++ Type | VtArray<double> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->DoubleArray |
int usdGeom_NurbsCurves_GetPointWeightsAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetPointWeightsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreatePointWeightsAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Curves-derived primitives can represent multiple distinct,
/// potentially disconnected curves.  The length of 'curveVertexCounts'
/// gives the number of such curves, and each element describes the
/// number of vertices in the corresponding curve
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] curveVertexCounts` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_NurbsCurves_GetCurveVertexCountsAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetCurveVertexCountsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateCurveVertexCountsAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provides width specification for the curves, whose application
/// will depend on whether the curve is oriented (normals are defined for
/// it), in which case widths are "ribbon width", or unoriented, in which
/// case widths are cylinder width.  'widths' is not a generic Primvar,
/// but the number of elements in this attribute will be determined by
/// its 'interpolation'.  See \ref SetWidthsInterpolation() .  If 'widths'
/// and 'primvars:widths' are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] widths` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_NurbsCurves_GetWidthsAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetWidthsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateWidthsAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// Although 'widths' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which means a width value is specified at the end of each curve segment.
int usdGeom_NurbsCurves_GetWidthsInterpolation(usdGeom_NurbsCurves_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the widths attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetWidthsInterpolation()
int usdGeom_NurbsCurves_SetWidthsInterpolation(usdGeom_NurbsCurves_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Returns the number of curves as defined by the size of the
/// _curveVertexCounts_ array at _timeCode_.
/// 
/// \snippetdoc snippets.dox GetCount
/// \sa GetCurveVertexCountsAttr()
int usdGeom_NurbsCurves_GetCurveCount(usdGeom_NurbsCurves_t const* _this, usd_TimeCode_t timeCode, size_t* _result);

/// The primary geometry attribute for all PointBased
/// primitives, describes points in (local) space.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `point3f[] points` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Point3fArray |
int usdGeom_NurbsCurves_GetPointsAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetPointsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreatePointsAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'velocities' should be used by renderers to 
/// 
/// compute positions between samples for the 'points' attribute, rather
/// than interpolating between neighboring 'points' samples.  This is the
/// only reasonable means of computing motion blur for topologically
/// varying PointBased primitives.  It follows that the length of each
/// 'velocities' sample must match the length of the corresponding
/// 'points' sample.  Velocity is measured in position units per second,
/// as per most simulation software. To convert to position units per
/// UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeom_VelocityInterpolation .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] velocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_NurbsCurves_GetVelocitiesAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateVelocitiesAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'accelerations' should be used with
/// velocities to compute positions between samples for the 'points'
/// attribute rather than interpolating between neighboring 'points'
/// samples. Acceleration is measured in position units per second-squared.
/// To convert to position units per squared UsdTimeCode, divide by the
/// square of UsdStage::GetTimeCodesPerSecond().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] accelerations` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_NurbsCurves_GetAccelerationsAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetAccelerationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateAccelerationsAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provide an object-space orientation for individual points, 
/// which, depending on subclass, may define a surface, curve, or free 
/// points.  Note that 'normals' should not be authored on any Mesh that
/// is subdivided, since the subdivision algorithm will define its own
/// normals. 'normals' is not a generic primvar, but the number of elements
/// in this attribute will be determined by its 'interpolation'.  See
/// \ref SetNormalsInterpolation() . If 'normals' and 'primvars:normals'
/// are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `normal3f[] normals` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Normal3fArray |
int usdGeom_NurbsCurves_GetNormalsAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetNormalsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateNormalsAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// Although 'normals' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which will generally produce smooth shading on a polygonal mesh.
/// To achieve partial or fully faceted shading of a polygonal mesh
/// with normals, one should use UsdGeomTokens->faceVarying or
/// UsdGeomTokens->uniform interpolation.
int usdGeom_NurbsCurves_GetNormalsInterpolation(usdGeom_NurbsCurves_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdGeomPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the normals attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetNormalsInterpolation()
int usdGeom_NurbsCurves_SetNormalsInterpolation(usdGeom_NurbsCurves_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Compute points given the positions, velocities and accelerations
/// at \p time. 
/// 
/// This will return \c false and leave \p points untouched if:
/// - \p points is NULL
/// - one of \p time and \p baseTime is numeric and the other is
///   UsdTimeCode::Default() (they must either both be numeric or both be
///   default)
/// - there is no authored points attribute
/// 
/// If there is no error, we will return \c true and \p points will contain
/// the computed points.
/// 
/// \param points - the out parameter for the new points.  Its size
///                 will depend on the authored data.
/// \param time - UsdTimeCode at which we want to evaluate the transforms
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em accelerations are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
int usdGeom_NurbsCurves_ComputePointsAtTime(usdGeom_NurbsCurves_t const* _this, gf_Vec3fArray_t* points, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, bool* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_NurbsCurves_GetDisplayColorAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateDisplayColorAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_NurbsCurves_GetDisplayOpacityAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateDisplayOpacityAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_NurbsCurves_GetDoubleSidedAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateDoubleSidedAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_NurbsCurves_GetOrientationAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateOrientationAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_NurbsCurves_GetDisplayColorPrimvar(usdGeom_NurbsCurves_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_NurbsCurves_CreateDisplayColorPrimvar(usdGeom_NurbsCurves_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_NurbsCurves_GetExtentAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateExtentAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_NurbsCurves_GetXformOpOrderAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_NurbsCurves_AddXformOp(usdGeom_NurbsCurves_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_NurbsCurves_AddTranslateOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_NurbsCurves_AddScaleOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_NurbsCurves_AddRotateXOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_NurbsCurves_AddRotateYOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_NurbsCurves_AddRotateZOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsCurves_AddRotateXYZOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsCurves_AddRotateXZYOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsCurves_AddRotateYXZOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsCurves_AddRotateYZXOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsCurves_AddRotateZXYOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsCurves_AddRotateZYXOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_NurbsCurves_AddOrientOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_NurbsCurves_AddTransformOp(usdGeom_NurbsCurves_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_NurbsCurves_SetResetXformStack(usdGeom_NurbsCurves_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_NurbsCurves_SetXformOpOrder(usdGeom_NurbsCurves_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_NurbsCurves_GetOrderedXformOps(usdGeom_NurbsCurves_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_NurbsCurves_ClearXformOpOrder(usdGeom_NurbsCurves_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_NurbsCurves_MakeMatrixXform(usdGeom_NurbsCurves_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_NurbsCurves_TransformMightBeTimeVarying(usdGeom_NurbsCurves_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_NurbsCurves_TransformMightBeTimeVarying_using(usdGeom_NurbsCurves_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_NurbsCurves_GetTimeSamples(usdGeom_NurbsCurves_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_NurbsCurves_GetTimeSamplesInInterval(usdGeom_NurbsCurves_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_NurbsCurves_GetLocalTransformation(usdGeom_NurbsCurves_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_NurbsCurves_GetLocalTransformation_with_ops(usdGeom_NurbsCurves_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_NurbsCurves_GetVisibilityAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreateVisibilityAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_NurbsCurves_GetPurposeAttr(usdGeom_NurbsCurves_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsCurves_CreatePurposeAttr(usdGeom_NurbsCurves_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_NurbsCurves_GetProxyPrimRel(usdGeom_NurbsCurves_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_NurbsCurves_CreateProxyPrimRel(usdGeom_NurbsCurves_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_NurbsCurves_MakeVisible(usdGeom_NurbsCurves_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_NurbsCurves_MakeInvisible(usdGeom_NurbsCurves_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_NurbsCurves_ComputeVisibility(usdGeom_NurbsCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_NurbsCurves_GetPurposeVisibilityAttr(usdGeom_NurbsCurves_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_NurbsCurves_ComputePurposeInfo(usdGeom_NurbsCurves_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_NurbsCurves_ComputePurposeInfo_given_parent(usdGeom_NurbsCurves_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_NurbsCurves_ComputePurpose(usdGeom_NurbsCurves_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_NurbsCurves_ComputeProxyPrim(usdGeom_NurbsCurves_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_NurbsCurves_SetProxyPrim(usdGeom_NurbsCurves_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_NurbsCurves_ComputeWorldBound(usdGeom_NurbsCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_NurbsCurves_ComputeLocalBound(usdGeom_NurbsCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_NurbsCurves_ComputeUntransformedBound(usdGeom_NurbsCurves_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_NurbsCurves_ComputeLocalToWorldTransform(usdGeom_NurbsCurves_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_NurbsCurves_ComputeParentToWorldTransform(usdGeom_NurbsCurves_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_NurbsCurves_IsConcrete(usdGeom_NurbsCurves_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_NurbsCurves_IsTyped(usdGeom_NurbsCurves_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_NurbsCurves_IsAPISchema(usdGeom_NurbsCurves_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_NurbsCurves_IsAppliedAPISchema(usdGeom_NurbsCurves_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_NurbsCurves_IsMultipleApplyAPISchema(usdGeom_NurbsCurves_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_NurbsCurves_GetSchemaKind(usdGeom_NurbsCurves_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_NurbsCurves_GetPrim(usdGeom_NurbsCurves_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_NurbsCurves_GetPath(usdGeom_NurbsCurves_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_NurbsCurves_GetSchemaClassPrimDefinition(usdGeom_NurbsCurves_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_NurbsCurves_new(usd_Prim_t const* param00, usdGeom_NurbsCurves_t** _result);

int usdGeom_NurbsCurves_dtor(usdGeom_NurbsCurves_t* _this);

/// Number of vertices in the U direction.  Should be at least as
/// large as uOrder.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int uVertexCount` |
/// | C++ Type | int |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Int |
int usdGeom_NurbsPatch_GetUVertexCountAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetUVertexCountAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateUVertexCountAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Number of vertices in the V direction.  Should be at least as
/// large as vOrder.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int vVertexCount` |
/// | C++ Type | int |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Int |
int usdGeom_NurbsPatch_GetVVertexCountAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetVVertexCountAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateVVertexCountAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Order in the U direction.  Order must be positive and is
/// equal to the degree of the polynomial basis to be evaluated, plus 1.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int uOrder` |
/// | C++ Type | int |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Int |
int usdGeom_NurbsPatch_GetUOrderAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetUOrderAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateUOrderAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Order in the V direction.  Order must be positive and is
/// equal to the degree of the polynomial basis to be evaluated, plus 1.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int vOrder` |
/// | C++ Type | int |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Int |
int usdGeom_NurbsPatch_GetVOrderAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetVOrderAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateVOrderAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Knot vector for U direction providing U parameterization.
/// The length of this array must be ( uVertexCount + uOrder ), and its
/// entries must take on monotonically increasing values.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double[] uKnots` |
/// | C++ Type | VtArray<double> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->DoubleArray |
int usdGeom_NurbsPatch_GetUKnotsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetUKnotsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateUKnotsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Knot vector for V direction providing U parameterization.
/// The length of this array must be ( vVertexCount + vOrder ), and its
/// entries must take on monotonically increasing values.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double[] vKnots` |
/// | C++ Type | VtArray<double> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->DoubleArray |
int usdGeom_NurbsPatch_GetVKnotsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetVKnotsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateVKnotsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Interpret the control grid and knot vectors as representing
/// an open, geometrically closed, or geometrically closed and C2 continuous
/// surface along the U dimension.
/// \sa \ref UsdGeom_NurbsPatch_Form "NurbsPatch Form" 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token uForm = "open"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | open, closed, periodic |
int usdGeom_NurbsPatch_GetUFormAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetUFormAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateUFormAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Interpret the control grid and knot vectors as representing
/// an open, geometrically closed, or geometrically closed and C2 continuous
/// surface along the V dimension.
/// \sa \ref UsdGeom_NurbsPatch_Form "NurbsPatch Form" 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token vForm = "open"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | open, closed, periodic |
int usdGeom_NurbsPatch_GetVFormAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetVFormAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateVFormAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provides the minimum and maximum parametric values (as defined
/// by uKnots) over which the surface is actually defined.  The minimum
/// must be less than the maximum, and greater than or equal to the
/// value of uKnots[uOrder-1].  The maxium must be less than or equal
/// to the last element's value in uKnots.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double2 uRange` |
/// | C++ Type | GfVec2d |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double2 |
int usdGeom_NurbsPatch_GetURangeAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetURangeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateURangeAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provides the minimum and maximum parametric values (as defined
/// by vKnots) over which the surface is actually defined.  The minimum
/// must be less than the maximum, and greater than or equal to the
/// value of vKnots[vOrder-1].  The maxium must be less than or equal
/// to the last element's value in vKnots.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double2 vRange` |
/// | C++ Type | GfVec2d |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double2 |
int usdGeom_NurbsPatch_GetVRangeAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetVRangeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateVRangeAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Optionally provides "w" components for each control point,
/// thus must be the same length as the points attribute.  If authored,
/// the patch will be rational.  If unauthored, the patch will be
/// polynomial, i.e. weight for all points is 1.0.
/// \note Some DCC's pre-weight the \em points, but in this schema, 
/// \em points are not pre-weighted.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double[] pointWeights` |
/// | C++ Type | VtArray<double> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->DoubleArray |
int usdGeom_NurbsPatch_GetPointWeightsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetPointWeightsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreatePointWeightsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Each element specifies how many curves are present in each
/// "loop" of the trimCurve, and the length of the array determines how
/// many loops the trimCurve contains.  The sum of all elements is the
/// total nuber of curves in the trim, to which we will refer as 
/// \em nCurves in describing the other trim attributes.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] trimCurve:counts` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_NurbsPatch_GetTrimCurveCountsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetTrimCurveCountsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateTrimCurveCountsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Flat list of orders for each of the \em nCurves curves.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] trimCurve:orders` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_NurbsPatch_GetTrimCurveOrdersAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetTrimCurveOrdersAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateTrimCurveOrdersAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Flat list of number of vertices for each of the
/// \em nCurves curves.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] trimCurve:vertexCounts` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_NurbsPatch_GetTrimCurveVertexCountsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetTrimCurveVertexCountsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateTrimCurveVertexCountsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Flat list of parametric values for each of the
/// \em nCurves curves.  There will be as many knots as the sum over
/// all elements of \em vertexCounts plus the sum over all elements of
/// \em orders.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double[] trimCurve:knots` |
/// | C++ Type | VtArray<double> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->DoubleArray |
int usdGeom_NurbsPatch_GetTrimCurveKnotsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetTrimCurveKnotsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateTrimCurveKnotsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Flat list of minimum and maximum parametric values 
/// (as defined by \em knots) for each of the \em nCurves curves.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double2[] trimCurve:ranges` |
/// | C++ Type | VtArray<GfVec2d> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double2Array |
int usdGeom_NurbsPatch_GetTrimCurveRangesAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetTrimCurveRangesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateTrimCurveRangesAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Flat list of homogeneous 2D points (u, v, w) that comprise
/// the \em nCurves curves.  The number of points should be equal to the
/// um over all elements of \em vertexCounts.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double3[] trimCurve:points` |
/// | C++ Type | VtArray<GfVec3d> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double3Array |
int usdGeom_NurbsPatch_GetTrimCurvePointsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetTrimCurvePointsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateTrimCurvePointsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The primary geometry attribute for all PointBased
/// primitives, describes points in (local) space.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `point3f[] points` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Point3fArray |
int usdGeom_NurbsPatch_GetPointsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetPointsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreatePointsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'velocities' should be used by renderers to 
/// 
/// compute positions between samples for the 'points' attribute, rather
/// than interpolating between neighboring 'points' samples.  This is the
/// only reasonable means of computing motion blur for topologically
/// varying PointBased primitives.  It follows that the length of each
/// 'velocities' sample must match the length of the corresponding
/// 'points' sample.  Velocity is measured in position units per second,
/// as per most simulation software. To convert to position units per
/// UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeom_VelocityInterpolation .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] velocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_NurbsPatch_GetVelocitiesAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateVelocitiesAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'accelerations' should be used with
/// velocities to compute positions between samples for the 'points'
/// attribute rather than interpolating between neighboring 'points'
/// samples. Acceleration is measured in position units per second-squared.
/// To convert to position units per squared UsdTimeCode, divide by the
/// square of UsdStage::GetTimeCodesPerSecond().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] accelerations` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_NurbsPatch_GetAccelerationsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetAccelerationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateAccelerationsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provide an object-space orientation for individual points, 
/// which, depending on subclass, may define a surface, curve, or free 
/// points.  Note that 'normals' should not be authored on any Mesh that
/// is subdivided, since the subdivision algorithm will define its own
/// normals. 'normals' is not a generic primvar, but the number of elements
/// in this attribute will be determined by its 'interpolation'.  See
/// \ref SetNormalsInterpolation() . If 'normals' and 'primvars:normals'
/// are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `normal3f[] normals` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Normal3fArray |
int usdGeom_NurbsPatch_GetNormalsAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetNormalsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateNormalsAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// Although 'normals' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which will generally produce smooth shading on a polygonal mesh.
/// To achieve partial or fully faceted shading of a polygonal mesh
/// with normals, one should use UsdGeomTokens->faceVarying or
/// UsdGeomTokens->uniform interpolation.
int usdGeom_NurbsPatch_GetNormalsInterpolation(usdGeom_NurbsPatch_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdGeomPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the normals attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetNormalsInterpolation()
int usdGeom_NurbsPatch_SetNormalsInterpolation(usdGeom_NurbsPatch_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Compute points given the positions, velocities and accelerations
/// at \p time. 
/// 
/// This will return \c false and leave \p points untouched if:
/// - \p points is NULL
/// - one of \p time and \p baseTime is numeric and the other is
///   UsdTimeCode::Default() (they must either both be numeric or both be
///   default)
/// - there is no authored points attribute
/// 
/// If there is no error, we will return \c true and \p points will contain
/// the computed points.
/// 
/// \param points - the out parameter for the new points.  Its size
///                 will depend on the authored data.
/// \param time - UsdTimeCode at which we want to evaluate the transforms
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em accelerations are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
int usdGeom_NurbsPatch_ComputePointsAtTime(usdGeom_NurbsPatch_t const* _this, gf_Vec3fArray_t* points, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, bool* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_NurbsPatch_GetDisplayColorAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateDisplayColorAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_NurbsPatch_GetDisplayOpacityAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateDisplayOpacityAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_NurbsPatch_GetDoubleSidedAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateDoubleSidedAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_NurbsPatch_GetOrientationAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateOrientationAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_NurbsPatch_GetDisplayColorPrimvar(usdGeom_NurbsPatch_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_NurbsPatch_CreateDisplayColorPrimvar(usdGeom_NurbsPatch_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_NurbsPatch_GetExtentAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateExtentAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_NurbsPatch_GetXformOpOrderAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_NurbsPatch_AddXformOp(usdGeom_NurbsPatch_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_NurbsPatch_AddTranslateOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_NurbsPatch_AddScaleOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_NurbsPatch_AddRotateXOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_NurbsPatch_AddRotateYOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_NurbsPatch_AddRotateZOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsPatch_AddRotateXYZOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsPatch_AddRotateXZYOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsPatch_AddRotateYXZOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsPatch_AddRotateYZXOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsPatch_AddRotateZXYOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_NurbsPatch_AddRotateZYXOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_NurbsPatch_AddOrientOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_NurbsPatch_AddTransformOp(usdGeom_NurbsPatch_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_NurbsPatch_SetResetXformStack(usdGeom_NurbsPatch_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_NurbsPatch_SetXformOpOrder(usdGeom_NurbsPatch_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_NurbsPatch_GetOrderedXformOps(usdGeom_NurbsPatch_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_NurbsPatch_ClearXformOpOrder(usdGeom_NurbsPatch_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_NurbsPatch_MakeMatrixXform(usdGeom_NurbsPatch_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_NurbsPatch_TransformMightBeTimeVarying(usdGeom_NurbsPatch_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_NurbsPatch_TransformMightBeTimeVarying_using(usdGeom_NurbsPatch_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_NurbsPatch_GetTimeSamples(usdGeom_NurbsPatch_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_NurbsPatch_GetTimeSamplesInInterval(usdGeom_NurbsPatch_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_NurbsPatch_GetLocalTransformation(usdGeom_NurbsPatch_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_NurbsPatch_GetLocalTransformation_with_ops(usdGeom_NurbsPatch_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_NurbsPatch_GetVisibilityAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreateVisibilityAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_NurbsPatch_GetPurposeAttr(usdGeom_NurbsPatch_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_NurbsPatch_CreatePurposeAttr(usdGeom_NurbsPatch_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_NurbsPatch_GetProxyPrimRel(usdGeom_NurbsPatch_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_NurbsPatch_CreateProxyPrimRel(usdGeom_NurbsPatch_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_NurbsPatch_MakeVisible(usdGeom_NurbsPatch_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_NurbsPatch_MakeInvisible(usdGeom_NurbsPatch_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_NurbsPatch_ComputeVisibility(usdGeom_NurbsPatch_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_NurbsPatch_GetPurposeVisibilityAttr(usdGeom_NurbsPatch_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_NurbsPatch_ComputePurposeInfo(usdGeom_NurbsPatch_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_NurbsPatch_ComputePurposeInfo_given_parent(usdGeom_NurbsPatch_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_NurbsPatch_ComputePurpose(usdGeom_NurbsPatch_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_NurbsPatch_ComputeProxyPrim(usdGeom_NurbsPatch_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_NurbsPatch_SetProxyPrim(usdGeom_NurbsPatch_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_NurbsPatch_ComputeWorldBound(usdGeom_NurbsPatch_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_NurbsPatch_ComputeLocalBound(usdGeom_NurbsPatch_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_NurbsPatch_ComputeUntransformedBound(usdGeom_NurbsPatch_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_NurbsPatch_ComputeLocalToWorldTransform(usdGeom_NurbsPatch_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_NurbsPatch_ComputeParentToWorldTransform(usdGeom_NurbsPatch_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_NurbsPatch_IsConcrete(usdGeom_NurbsPatch_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_NurbsPatch_IsTyped(usdGeom_NurbsPatch_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_NurbsPatch_IsAPISchema(usdGeom_NurbsPatch_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_NurbsPatch_IsAppliedAPISchema(usdGeom_NurbsPatch_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_NurbsPatch_IsMultipleApplyAPISchema(usdGeom_NurbsPatch_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_NurbsPatch_GetSchemaKind(usdGeom_NurbsPatch_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_NurbsPatch_GetPrim(usdGeom_NurbsPatch_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_NurbsPatch_GetPath(usdGeom_NurbsPatch_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_NurbsPatch_GetSchemaClassPrimDefinition(usdGeom_NurbsPatch_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_NurbsPatch_new(usd_Prim_t const* param00, usdGeom_NurbsPatch_t** _result);

int usdGeom_NurbsPatch_dtor(usdGeom_NurbsPatch_t* _this);

/// The width of the plane, which aligns to the x-axis when \em axis is
/// 'Z' or 'Y', or to the z-axis when \em axis is 'X'.  If you author \em width 
/// you must also author \em extent.
/// 
/// \sa UsdGeomGprim::GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double width = 2` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Plane_GetWidthAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetWidthAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreateWidthAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The length of the plane, which aligns to the y-axis when \em axis is
/// 'Z' or 'X', or to the z-axis when \em axis is 'Y'.  If you author \em length 
/// you must also author \em extent.
/// 
/// \sa UsdGeomGprim::GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double length = 2` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Plane_GetLengthAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetLengthAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreateLengthAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The axis along which the surface of the plane is aligned. When set
/// to 'Z' the plane is in the xy-plane; when \em axis is 'X' the plane is in 
/// the yz-plane, and when \em axis is 'Y' the plane is in the xz-plane.
/// 
/// \sa UsdGeomGprim::GetAxisAttr().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token axis = "Z"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | X, Y, Z |
int usdGeom_Plane_GetAxisAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetAxisAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreateAxisAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Plane_GetDisplayColorAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreateDisplayColorAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Plane_GetDisplayOpacityAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreateDisplayOpacityAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Planes are double-sided by default. Clients may also support
/// single-sided planes.
/// 
/// \sa UsdGeomGprim::GetDoubleSidedAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 1` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Plane_GetDoubleSidedAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreateDoubleSidedAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Plane_GetOrientationAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreateOrientationAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Plane_GetDisplayColorPrimvar(usdGeom_Plane_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Plane_CreateDisplayColorPrimvar(usdGeom_Plane_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is re-defined on Plane only to provide a fallback
/// value. \sa UsdGeomGprim::GetExtentAttr().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent = [(-1, -1, 0), (1, 1, 0)]` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Plane_GetExtentAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreateExtentAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Plane_GetXformOpOrderAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Plane_AddXformOp(usdGeom_Plane_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Plane_AddTranslateOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Plane_AddScaleOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Plane_AddRotateXOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Plane_AddRotateYOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Plane_AddRotateZOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Plane_AddRotateXYZOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Plane_AddRotateXZYOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Plane_AddRotateYXZOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Plane_AddRotateYZXOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Plane_AddRotateZXYOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Plane_AddRotateZYXOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Plane_AddOrientOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Plane_AddTransformOp(usdGeom_Plane_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Plane_SetResetXformStack(usdGeom_Plane_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Plane_SetXformOpOrder(usdGeom_Plane_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Plane_GetOrderedXformOps(usdGeom_Plane_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Plane_ClearXformOpOrder(usdGeom_Plane_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Plane_MakeMatrixXform(usdGeom_Plane_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Plane_TransformMightBeTimeVarying(usdGeom_Plane_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Plane_TransformMightBeTimeVarying_using(usdGeom_Plane_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Plane_GetTimeSamples(usdGeom_Plane_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Plane_GetTimeSamplesInInterval(usdGeom_Plane_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Plane_GetLocalTransformation(usdGeom_Plane_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Plane_GetLocalTransformation_with_ops(usdGeom_Plane_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Plane_GetVisibilityAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreateVisibilityAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Plane_GetPurposeAttr(usdGeom_Plane_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Plane_CreatePurposeAttr(usdGeom_Plane_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Plane_GetProxyPrimRel(usdGeom_Plane_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Plane_CreateProxyPrimRel(usdGeom_Plane_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Plane_MakeVisible(usdGeom_Plane_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Plane_MakeInvisible(usdGeom_Plane_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Plane_ComputeVisibility(usdGeom_Plane_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Plane_GetPurposeVisibilityAttr(usdGeom_Plane_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Plane_ComputePurposeInfo(usdGeom_Plane_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Plane_ComputePurposeInfo_given_parent(usdGeom_Plane_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Plane_ComputePurpose(usdGeom_Plane_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Plane_ComputeProxyPrim(usdGeom_Plane_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Plane_SetProxyPrim(usdGeom_Plane_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Plane_ComputeWorldBound(usdGeom_Plane_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Plane_ComputeLocalBound(usdGeom_Plane_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Plane_ComputeUntransformedBound(usdGeom_Plane_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Plane_ComputeLocalToWorldTransform(usdGeom_Plane_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Plane_ComputeParentToWorldTransform(usdGeom_Plane_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Plane_IsConcrete(usdGeom_Plane_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Plane_IsTyped(usdGeom_Plane_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Plane_IsAPISchema(usdGeom_Plane_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Plane_IsAppliedAPISchema(usdGeom_Plane_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Plane_IsMultipleApplyAPISchema(usdGeom_Plane_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Plane_GetSchemaKind(usdGeom_Plane_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Plane_GetPrim(usdGeom_Plane_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Plane_GetPath(usdGeom_Plane_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Plane_GetSchemaClassPrimDefinition(usdGeom_Plane_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Plane_new(usd_Prim_t const* param00, usdGeom_Plane_t** _result);

int usdGeom_Plane_dtor(usdGeom_Plane_t* _this);

/// The primary geometry attribute for all PointBased
/// primitives, describes points in (local) space.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `point3f[] points` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Point3fArray |
int usdGeom_PointBased_GetPointsAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetPointsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreatePointsAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'velocities' should be used by renderers to 
/// 
/// compute positions between samples for the 'points' attribute, rather
/// than interpolating between neighboring 'points' samples.  This is the
/// only reasonable means of computing motion blur for topologically
/// varying PointBased primitives.  It follows that the length of each
/// 'velocities' sample must match the length of the corresponding
/// 'points' sample.  Velocity is measured in position units per second,
/// as per most simulation software. To convert to position units per
/// UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeom_VelocityInterpolation .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] velocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_PointBased_GetVelocitiesAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreateVelocitiesAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'accelerations' should be used with
/// velocities to compute positions between samples for the 'points'
/// attribute rather than interpolating between neighboring 'points'
/// samples. Acceleration is measured in position units per second-squared.
/// To convert to position units per squared UsdTimeCode, divide by the
/// square of UsdStage::GetTimeCodesPerSecond().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] accelerations` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_PointBased_GetAccelerationsAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetAccelerationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreateAccelerationsAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provide an object-space orientation for individual points, 
/// which, depending on subclass, may define a surface, curve, or free 
/// points.  Note that 'normals' should not be authored on any Mesh that
/// is subdivided, since the subdivision algorithm will define its own
/// normals. 'normals' is not a generic primvar, but the number of elements
/// in this attribute will be determined by its 'interpolation'.  See
/// \ref SetNormalsInterpolation() . If 'normals' and 'primvars:normals'
/// are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `normal3f[] normals` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Normal3fArray |
int usdGeom_PointBased_GetNormalsAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetNormalsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreateNormalsAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// Although 'normals' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which will generally produce smooth shading on a polygonal mesh.
/// To achieve partial or fully faceted shading of a polygonal mesh
/// with normals, one should use UsdGeomTokens->faceVarying or
/// UsdGeomTokens->uniform interpolation.
int usdGeom_PointBased_GetNormalsInterpolation(usdGeom_PointBased_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdGeomPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the normals attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetNormalsInterpolation()
int usdGeom_PointBased_SetNormalsInterpolation(usdGeom_PointBased_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Compute points given the positions, velocities and accelerations
/// at \p time. 
/// 
/// This will return \c false and leave \p points untouched if:
/// - \p points is NULL
/// - one of \p time and \p baseTime is numeric and the other is
///   UsdTimeCode::Default() (they must either both be numeric or both be
///   default)
/// - there is no authored points attribute
/// 
/// If there is no error, we will return \c true and \p points will contain
/// the computed points.
/// 
/// \param points - the out parameter for the new points.  Its size
///                 will depend on the authored data.
/// \param time - UsdTimeCode at which we want to evaluate the transforms
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em accelerations are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
int usdGeom_PointBased_ComputePointsAtTime(usdGeom_PointBased_t const* _this, gf_Vec3fArray_t* points, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, bool* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_PointBased_GetDisplayColorAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreateDisplayColorAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_PointBased_GetDisplayOpacityAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreateDisplayOpacityAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_PointBased_GetDoubleSidedAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreateDoubleSidedAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_PointBased_GetOrientationAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreateOrientationAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_PointBased_GetDisplayColorPrimvar(usdGeom_PointBased_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_PointBased_CreateDisplayColorPrimvar(usdGeom_PointBased_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_PointBased_GetExtentAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreateExtentAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_PointBased_GetXformOpOrderAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_PointBased_AddXformOp(usdGeom_PointBased_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_PointBased_AddTranslateOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_PointBased_AddScaleOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_PointBased_AddRotateXOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_PointBased_AddRotateYOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_PointBased_AddRotateZOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointBased_AddRotateXYZOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointBased_AddRotateXZYOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointBased_AddRotateYXZOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointBased_AddRotateYZXOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointBased_AddRotateZXYOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointBased_AddRotateZYXOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_PointBased_AddOrientOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_PointBased_AddTransformOp(usdGeom_PointBased_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_PointBased_SetResetXformStack(usdGeom_PointBased_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_PointBased_SetXformOpOrder(usdGeom_PointBased_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_PointBased_GetOrderedXformOps(usdGeom_PointBased_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_PointBased_ClearXformOpOrder(usdGeom_PointBased_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_PointBased_MakeMatrixXform(usdGeom_PointBased_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_PointBased_TransformMightBeTimeVarying(usdGeom_PointBased_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_PointBased_TransformMightBeTimeVarying_using(usdGeom_PointBased_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_PointBased_GetTimeSamples(usdGeom_PointBased_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_PointBased_GetTimeSamplesInInterval(usdGeom_PointBased_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_PointBased_GetLocalTransformation(usdGeom_PointBased_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_PointBased_GetLocalTransformation_with_ops(usdGeom_PointBased_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_PointBased_GetVisibilityAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreateVisibilityAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_PointBased_GetPurposeAttr(usdGeom_PointBased_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointBased_CreatePurposeAttr(usdGeom_PointBased_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_PointBased_GetProxyPrimRel(usdGeom_PointBased_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_PointBased_CreateProxyPrimRel(usdGeom_PointBased_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_PointBased_MakeVisible(usdGeom_PointBased_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_PointBased_MakeInvisible(usdGeom_PointBased_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_PointBased_ComputeVisibility(usdGeom_PointBased_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_PointBased_GetPurposeVisibilityAttr(usdGeom_PointBased_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_PointBased_ComputePurposeInfo(usdGeom_PointBased_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_PointBased_ComputePurposeInfo_given_parent(usdGeom_PointBased_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_PointBased_ComputePurpose(usdGeom_PointBased_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_PointBased_ComputeProxyPrim(usdGeom_PointBased_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_PointBased_SetProxyPrim(usdGeom_PointBased_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_PointBased_ComputeWorldBound(usdGeom_PointBased_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_PointBased_ComputeLocalBound(usdGeom_PointBased_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_PointBased_ComputeUntransformedBound(usdGeom_PointBased_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_PointBased_ComputeLocalToWorldTransform(usdGeom_PointBased_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_PointBased_ComputeParentToWorldTransform(usdGeom_PointBased_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_PointBased_IsConcrete(usdGeom_PointBased_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_PointBased_IsTyped(usdGeom_PointBased_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_PointBased_IsAPISchema(usdGeom_PointBased_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_PointBased_IsAppliedAPISchema(usdGeom_PointBased_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_PointBased_IsMultipleApplyAPISchema(usdGeom_PointBased_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_PointBased_GetSchemaKind(usdGeom_PointBased_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_PointBased_GetPrim(usdGeom_PointBased_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_PointBased_GetPath(usdGeom_PointBased_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_PointBased_GetSchemaClassPrimDefinition(usdGeom_PointBased_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_PointBased_new(usd_Prim_t const* param00, usdGeom_PointBased_t** _result);

int usdGeom_PointBased_dtor(usdGeom_PointBased_t* _this);

/// <b>Required property</b>. Per-instance index into 
/// \em prototypes relationship that identifies what geometry should be 
/// drawn for each instance.  <b>Topology attribute</b> - can be animated, 
/// but at a potential performance impact for streaming.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] protoIndices` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_PointInstancer_GetProtoIndicesAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetProtoIndicesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreateProtoIndicesAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Ids are optional; if authored, the ids array should be the same
/// length as the \em protoIndices array, specifying (at each timeSample if
/// instance identities are changing) the id of each instance. The
/// type is signed intentionally, so that clients can encode some
/// binary state on Id'd instances without adding a separate primvar.
/// See also \ref UsdGeomPointInstancer_varyingTopo
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int64[] ids` |
/// | C++ Type | VtArray<int64_t> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Int64Array |
int usdGeom_PointInstancer_GetIdsAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetIdsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreateIdsAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// <b>Required property</b>. Per-instance position.  See also 
/// \ref UsdGeomPointInstancer_transform .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `point3f[] positions` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Point3fArray |
int usdGeom_PointInstancer_GetPositionsAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetPositionsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreatePositionsAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// See GetOrientationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreateOrientationsAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If authored, per-instance orientation of each instance about its 
/// prototype's origin, represented as a unit length quaternion, which
/// allows us to encode it with sufficient precision in a compact GfQuath.
/// 
/// It is client's responsibility to ensure that authored quaternions are
/// unit length; the convenience API below for authoring orientations from
/// rotation matrices will ensure that quaternions are unit length, though
/// it will not make any attempt to select the "better (for interpolation
/// with respect to neighboring samples)" of the two possible quaternions
/// that encode the rotation. 
/// 
/// See also \ref UsdGeomPointInstancer_transform .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `quath[] orientations` |
/// | C++ Type | VtArray<GfQuath> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->QuathArray |
int usdGeom_PointInstancer_GetOrientationsAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// If authored, per-instance scale to be applied to 
/// each instance, before any rotation is applied.
/// 
/// See also \ref UsdGeomPointInstancer_transform .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] scales` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_PointInstancer_GetScalesAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetScalesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreateScalesAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, per-instance 'velocities' will be used to 
/// compute positions between samples for the 'positions' attribute,
/// rather than interpolating between neighboring 'positions' samples.
/// Velocities should be considered mandatory if both \em protoIndices
/// and \em positions are animated.  Velocity is measured in position
/// units per second, as per most simulation software. To convert to
/// position units per UsdTimeCode, divide by
/// UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeomPointInstancer_transform, 
/// \ref UsdGeom_VelocityInterpolation .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] velocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_PointInstancer_GetVelocitiesAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreateVelocitiesAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If authored, per-instance 'accelerations' will be used with
/// velocities to compute positions between samples for the 'positions'
/// attribute rather than interpolating between neighboring 'positions'
/// samples. Acceleration is measured in position units per second-squared.
/// To convert to position units per squared UsdTimeCode, divide by the
/// square of UsdStage::GetTimeCodesPerSecond().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] accelerations` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_PointInstancer_GetAccelerationsAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetAccelerationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreateAccelerationsAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If authored, per-instance angular velocity vector to be used for
/// interoplating orientations.  Angular velocities should be considered
/// mandatory if both \em protoIndices and \em orientations are animated.
/// Angular velocity is measured in <b>degrees</b> per second. To convert
/// to degrees per UsdTimeCode, divide by
/// UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeomPointInstancer_transform .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] angularVelocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_PointInstancer_GetAngularVelocitiesAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetAngularVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreateAngularVelocitiesAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// <b>Required property</b>. Orders and targets the prototype root 
/// prims, which can be located anywhere in the scenegraph that is convenient,
/// although we promote organizing prototypes as children of the 
/// PointInstancer.  The position of a prototype in this relationship defines
/// the value an instance would specify in the \em protoIndices attribute to 
/// instance that prototype. Since relationships are uniform, this property
/// cannot be animated.
int usdGeom_PointInstancer_GetPrototypesRel(usdGeom_PointInstancer_t const* _this, usd_Relationship_t* _result);

/// See GetPrototypesRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_PointInstancer_CreatePrototypesRel(usdGeom_PointInstancer_t const* _this, usd_Relationship_t* _result);

/// Compute the per-instance, "PointInstancer relative" transforms given
/// the positions, scales, orientations, velocities and angularVelocities
/// at \p time, as described in \ref UsdGeomPointInstancer_transform .
/// 
/// This will return \c false and leave \p xforms untouched if:
/// - \p xforms is NULL
/// - one of \p time and \p baseTime is numeric and the other is
///   UsdTimeCode::Default() (they must either both be numeric or both be
///   default)
/// - there is no authored \em protoIndices attribute or \em positions
///   attribute
/// - the size of any of the per-instance attributes does not match the
///   size of \em protoIndices
/// - \p doProtoXforms is \c IncludeProtoXform but an index value in
///   \em protoIndices is outside the range [0, prototypes.size())
/// - \p applyMask is \c ApplyMask and a mask is set but the size of the
///   mask does not match the size of \em protoIndices.
/// 
/// If there is no error, we will return \c true and \p xforms will contain
/// the computed transformations.
/// 
/// \param xforms - the out parameter for the transformations.  Its size
///                 will depend on the authored data and \p applyMask
/// \param time - UsdTimeCode at which we want to evaluate the transforms
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em angularVelocities are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
///                   Selecting sample times with respect to baseTime will
///                   be performed independently for positions and
///                   orientations.
/// \param doProtoXforms - specifies whether to include the root 
///                   transformation of each instance's prototype in the
///                   instance's transform.  Default is to include it, but
///                   some clients may want to apply the proto transform as
///                   part of the prototype itself, so they can specify
///                   \c ExcludeProtoXform instead.
/// \param applyMask - specifies whether to apply ApplyMaskToArray() to the
///                    computed result.  The default is \c ApplyMask.
int usdGeom_PointInstancer_ComputeInstanceTransformsAtTime(usdGeom_PointInstancer_t const* _this, gf_Matrix4dArray_t* xforms, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, int doProtoXforms, int applyMask, bool* _result);

/// Compute the per-instance transforms as in
/// ComputeInstanceTransformsAtTime, but using multiple sample times. An
/// array of matrix arrays is returned where each matrix array contains the
/// instance transforms for the corresponding time in \p times .
/// 
/// \param times - A vector containing the UsdTimeCodes at which we want to
///                sample.
int usdGeom_PointInstancer_ComputeInstanceTransformsAtTimes(usdGeom_PointInstancer_t const* _this, gf_Matrix4dArrayVector_t* xformsArray, usd_TimeCodeVector_t const* times, usd_TimeCode_t const baseTime, int doProtoXforms, int applyMask, bool* _result);

/// Compute the extent of the point instancer based on the per-instance,
/// "PointInstancer relative" transforms at \p time, as described in
/// \ref UsdGeomPointInstancer_transform .
/// 
/// If there is no error, we return \c true and \p extent will be the
/// tightest bounds we can compute efficiently.  If an error occurs,
/// \c false will be returned and \p extent will be left untouched.
/// 
/// For now, this uses a UsdGeomBBoxCache with the "default", "proxy", and
/// "render" purposes.
/// 
/// \param extent - the out parameter for the extent.  On success, it will
///                 contain two elements representing the min and max.
/// \param time - UsdTimeCode at which we want to evaluate the extent
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em angularVelocities are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
int usdGeom_PointInstancer_ComputeExtentAtTime(usdGeom_PointInstancer_t const* _this, gf_Vec3fArray_t* extent, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, bool* _result);

/// \overload
/// Computes the extent as if the matrix \p transform was first applied.
int usdGeom_PointInstancer_ComputeExtentAtTime_with_transform(usdGeom_PointInstancer_t const* _this, gf_Vec3fArray_t* extent, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, gf_Matrix4d_t const* transform, bool* _result);

/// Compute the extent of the point instancer as in
/// \ref ComputeExtentAtTime , but across multiple \p times . This is
/// equivalent to, but more efficient than, calling ComputeExtentAtTime
/// several times. Each element in \p extents is the computed extent at the
/// corresponding time in \p times .
/// 
/// As in \ref ComputeExtentAtTime, if there is no error, we return \c true
/// and \p extents will be the tightest bounds we can compute efficiently.
/// If an error occurs computing the extent at any time, \c false will be
/// returned and \p extents will be left untouched.
/// 
/// \param times - A vector containing the UsdTimeCodes at which we want to
///                sample.
int usdGeom_PointInstancer_ComputeExtentAtTimes(usdGeom_PointInstancer_t const* _this, gf_Vec3fArrayVector_t* extents, usd_TimeCodeVector_t const* times, usd_TimeCode_t const baseTime, bool* _result);

/// \overload
/// Computes the extent as if the matrix \p transform was first applied at
/// each time.
int usdGeom_PointInstancer_ComputeExtentAtTimes_with_transform(usdGeom_PointInstancer_t const* _this, gf_Vec3fArrayVector_t* extents, usd_TimeCodeVector_t const* times, usd_TimeCode_t const baseTime, gf_Matrix4d_t const* transform, bool* _result);

/// Returns the number of instances as defined by the size of the
/// _protoIndices_ array at _timeCode_.
/// 
/// \snippetdoc snippets.dox GetCount
/// \sa GetProtoIndicesAttr()
int usdGeom_PointInstancer_GetInstanceCount(usdGeom_PointInstancer_t const* _this, usd_TimeCode_t timeCode, size_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_PointInstancer_GetExtentAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreateExtentAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_PointInstancer_GetXformOpOrderAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_PointInstancer_AddXformOp(usdGeom_PointInstancer_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_PointInstancer_AddTranslateOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_PointInstancer_AddScaleOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_PointInstancer_AddRotateXOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_PointInstancer_AddRotateYOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_PointInstancer_AddRotateZOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointInstancer_AddRotateXYZOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointInstancer_AddRotateXZYOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointInstancer_AddRotateYXZOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointInstancer_AddRotateYZXOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointInstancer_AddRotateZXYOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_PointInstancer_AddRotateZYXOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_PointInstancer_AddOrientOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_PointInstancer_AddTransformOp(usdGeom_PointInstancer_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_PointInstancer_SetResetXformStack(usdGeom_PointInstancer_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_PointInstancer_SetXformOpOrder(usdGeom_PointInstancer_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_PointInstancer_GetOrderedXformOps(usdGeom_PointInstancer_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_PointInstancer_ClearXformOpOrder(usdGeom_PointInstancer_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_PointInstancer_MakeMatrixXform(usdGeom_PointInstancer_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_PointInstancer_TransformMightBeTimeVarying(usdGeom_PointInstancer_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_PointInstancer_TransformMightBeTimeVarying_using(usdGeom_PointInstancer_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_PointInstancer_GetTimeSamples(usdGeom_PointInstancer_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_PointInstancer_GetTimeSamplesInInterval(usdGeom_PointInstancer_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_PointInstancer_GetLocalTransformation(usdGeom_PointInstancer_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_PointInstancer_GetLocalTransformation_with_ops(usdGeom_PointInstancer_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_PointInstancer_GetVisibilityAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreateVisibilityAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_PointInstancer_GetPurposeAttr(usdGeom_PointInstancer_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_PointInstancer_CreatePurposeAttr(usdGeom_PointInstancer_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_PointInstancer_GetProxyPrimRel(usdGeom_PointInstancer_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_PointInstancer_CreateProxyPrimRel(usdGeom_PointInstancer_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_PointInstancer_MakeVisible(usdGeom_PointInstancer_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_PointInstancer_MakeInvisible(usdGeom_PointInstancer_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_PointInstancer_ComputeVisibility(usdGeom_PointInstancer_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_PointInstancer_GetPurposeVisibilityAttr(usdGeom_PointInstancer_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_PointInstancer_ComputePurposeInfo(usdGeom_PointInstancer_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_PointInstancer_ComputePurposeInfo_given_parent(usdGeom_PointInstancer_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_PointInstancer_ComputePurpose(usdGeom_PointInstancer_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_PointInstancer_ComputeProxyPrim(usdGeom_PointInstancer_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_PointInstancer_SetProxyPrim(usdGeom_PointInstancer_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_PointInstancer_ComputeWorldBound(usdGeom_PointInstancer_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_PointInstancer_ComputeLocalBound(usdGeom_PointInstancer_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_PointInstancer_ComputeUntransformedBound(usdGeom_PointInstancer_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_PointInstancer_ComputeLocalToWorldTransform(usdGeom_PointInstancer_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_PointInstancer_ComputeParentToWorldTransform(usdGeom_PointInstancer_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_PointInstancer_IsConcrete(usdGeom_PointInstancer_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_PointInstancer_IsTyped(usdGeom_PointInstancer_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_PointInstancer_IsAPISchema(usdGeom_PointInstancer_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_PointInstancer_IsAppliedAPISchema(usdGeom_PointInstancer_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_PointInstancer_IsMultipleApplyAPISchema(usdGeom_PointInstancer_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_PointInstancer_GetSchemaKind(usdGeom_PointInstancer_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_PointInstancer_GetPrim(usdGeom_PointInstancer_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_PointInstancer_GetPath(usdGeom_PointInstancer_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_PointInstancer_GetSchemaClassPrimDefinition(usdGeom_PointInstancer_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_PointInstancer_new(usd_Prim_t const* param00, usdGeom_PointInstancer_t** _result);

int usdGeom_PointInstancer_dtor(usdGeom_PointInstancer_t* _this);

/// Widths are defined as the \em diameter of the points, in 
/// object space.  'widths' is not a generic Primvar, but
/// the number of elements in this attribute will be determined by
/// its 'interpolation'.  See \ref SetWidthsInterpolation() .  If
/// 'widths' and 'primvars:widths' are both specified, the latter
/// has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] widths` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Points_GetWidthsAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetWidthsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateWidthsAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Ids are optional; if authored, the ids array should be the same
/// length as the points array, specifying (at each timesample if
/// point identities are changing) the id of each point. The
/// type is signed intentionally, so that clients can encode some
/// binary state on Id'd points without adding a separate 
/// primvar.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int64[] ids` |
/// | C++ Type | VtArray<int64_t> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Int64Array |
int usdGeom_Points_GetIdsAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetIdsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateIdsAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// Although 'widths' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which means a width value is specified for each point.
int usdGeom_Points_GetWidthsInterpolation(usdGeom_Points_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em widths
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the widths attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetWidthsInterpolation()
int usdGeom_Points_SetWidthsInterpolation(usdGeom_Points_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Returns the number of points as defined by the size of the
/// _points_ array at _timeCode_.
/// 
/// \snippetdoc snippets.dox GetCount
/// \sa GetPointsAttr()
int usdGeom_Points_GetPointCount(usdGeom_Points_t const* _this, usd_TimeCode_t timeCode, size_t* _result);

/// The primary geometry attribute for all PointBased
/// primitives, describes points in (local) space.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `point3f[] points` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Point3fArray |
int usdGeom_Points_GetPointsAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetPointsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreatePointsAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'velocities' should be used by renderers to 
/// 
/// compute positions between samples for the 'points' attribute, rather
/// than interpolating between neighboring 'points' samples.  This is the
/// only reasonable means of computing motion blur for topologically
/// varying PointBased primitives.  It follows that the length of each
/// 'velocities' sample must match the length of the corresponding
/// 'points' sample.  Velocity is measured in position units per second,
/// as per most simulation software. To convert to position units per
/// UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
/// 
/// See also \ref UsdGeom_VelocityInterpolation .
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] velocities` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_Points_GetVelocitiesAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetVelocitiesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateVelocitiesAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// If provided, 'accelerations' should be used with
/// velocities to compute positions between samples for the 'points'
/// attribute rather than interpolating between neighboring 'points'
/// samples. Acceleration is measured in position units per second-squared.
/// To convert to position units per squared UsdTimeCode, divide by the
/// square of UsdStage::GetTimeCodesPerSecond().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `vector3f[] accelerations` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Vector3fArray |
int usdGeom_Points_GetAccelerationsAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetAccelerationsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateAccelerationsAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Provide an object-space orientation for individual points, 
/// which, depending on subclass, may define a surface, curve, or free 
/// points.  Note that 'normals' should not be authored on any Mesh that
/// is subdivided, since the subdivision algorithm will define its own
/// normals. 'normals' is not a generic primvar, but the number of elements
/// in this attribute will be determined by its 'interpolation'.  See
/// \ref SetNormalsInterpolation() . If 'normals' and 'primvars:normals'
/// are both specified, the latter has precedence.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `normal3f[] normals` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Normal3fArray |
int usdGeom_Points_GetNormalsAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetNormalsAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateNormalsAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Get the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// Although 'normals' is not classified as a generic UsdGeomPrimvar (and
/// will not be included in the results of UsdGeomPrimvarsAPI::GetPrimvars() )
/// it does require an interpolation specification.  The fallback
/// interpolation, if left unspecified, is UsdGeomTokens->vertex , 
/// which will generally produce smooth shading on a polygonal mesh.
/// To achieve partial or fully faceted shading of a polygonal mesh
/// with normals, one should use UsdGeomTokens->faceVarying or
/// UsdGeomTokens->uniform interpolation.
int usdGeom_Points_GetNormalsInterpolation(usdGeom_Points_t const* _this, tf_Token_t* _result);

/// Set the \ref Usd_InterpolationVals "interpolation" for the \em normals
/// attribute.
/// 
/// \return true upon success, false if \p interpolation is not a legal
/// value as defined by UsdGeomPrimvar::IsValidInterpolation(), or if there 
/// was a problem setting the value.  No attempt is made to validate
/// that the normals attr's value contains the right number of elements
/// to match its interpolation to its prim's topology.
/// 
/// \sa GetNormalsInterpolation()
int usdGeom_Points_SetNormalsInterpolation(usdGeom_Points_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Compute points given the positions, velocities and accelerations
/// at \p time. 
/// 
/// This will return \c false and leave \p points untouched if:
/// - \p points is NULL
/// - one of \p time and \p baseTime is numeric and the other is
///   UsdTimeCode::Default() (they must either both be numeric or both be
///   default)
/// - there is no authored points attribute
/// 
/// If there is no error, we will return \c true and \p points will contain
/// the computed points.
/// 
/// \param points - the out parameter for the new points.  Its size
///                 will depend on the authored data.
/// \param time - UsdTimeCode at which we want to evaluate the transforms
/// \param baseTime - required for correct interpolation between samples
///                   when \em velocities or \em accelerations are
///                   present. If there are samples for \em positions and
///                   \em velocities at t1 and t2, normal value resolution
///                   would attempt to interpolate between the two samples,
///                   and if they could not be interpolated because they
///                   differ in size (common in cases where velocity is
///                   authored), will choose the sample at t1.  When
///                   sampling for the purposes of motion-blur, for example,
///                   it is common, when rendering the frame at t2, to 
///                   sample at [ t2-shutter/2, t2+shutter/2 ] for a
///                   shutter interval of \em shutter.  The first sample
///                   falls between t1 and t2, but we must sample at t2
///                   and apply velocity-based interpolation based on those
///                   samples to get a correct result.  In such scenarios,
///                   one should provide a \p baseTime of t2 when querying
///                   \em both samples. If your application does not care
///                   about off-sample interpolation, it can supply the
///                   same value for \p baseTime that it does for \p time.
///                   When \p baseTime is less than or equal to \p time,
///                   we will choose the lower bracketing timeSample.
int usdGeom_Points_ComputePointsAtTime(usdGeom_Points_t const* _this, gf_Vec3fArray_t* points, usd_TimeCode_t const time, usd_TimeCode_t const baseTime, bool* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Points_GetDisplayColorAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateDisplayColorAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Points_GetDisplayOpacityAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateDisplayOpacityAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Points_GetDoubleSidedAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateDoubleSidedAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Points_GetOrientationAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateOrientationAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Points_GetDisplayColorPrimvar(usdGeom_Points_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Points_CreateDisplayColorPrimvar(usdGeom_Points_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is a three dimensional range measuring the geometric
/// extent of the authored gprim in its own local space (i.e. its own
/// transform not applied), \em without accounting for any shader-induced
/// displacement. If __any__ extent value has been authored for a given 
/// Boundable, then it should be authored at every timeSample at which 
/// geometry-affecting properties are authored, to ensure correct 
/// evaluation via ComputeExtent(). If __no__ extent value has been 
/// authored, then ComputeExtent() will call the Boundable's registered 
/// ComputeExtentFunction(), which may be expensive, which is why we 
/// strongly encourage proper authoring of extent.
/// \sa ComputeExtent()
/// \sa \ref UsdGeom_Boundable_Extent.
/// 
/// An authored extent on a prim which has children is expected to include
/// the extent of all children, as they will be pruned from BBox computation
/// during traversal.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Points_GetExtentAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateExtentAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Points_GetXformOpOrderAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Points_AddXformOp(usdGeom_Points_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Points_AddTranslateOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Points_AddScaleOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Points_AddRotateXOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Points_AddRotateYOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Points_AddRotateZOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Points_AddRotateXYZOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Points_AddRotateXZYOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Points_AddRotateYXZOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Points_AddRotateYZXOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Points_AddRotateZXYOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Points_AddRotateZYXOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Points_AddOrientOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Points_AddTransformOp(usdGeom_Points_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Points_SetResetXformStack(usdGeom_Points_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Points_SetXformOpOrder(usdGeom_Points_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Points_GetOrderedXformOps(usdGeom_Points_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Points_ClearXformOpOrder(usdGeom_Points_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Points_MakeMatrixXform(usdGeom_Points_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Points_TransformMightBeTimeVarying(usdGeom_Points_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Points_TransformMightBeTimeVarying_using(usdGeom_Points_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Points_GetTimeSamples(usdGeom_Points_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Points_GetTimeSamplesInInterval(usdGeom_Points_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Points_GetLocalTransformation(usdGeom_Points_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Points_GetLocalTransformation_with_ops(usdGeom_Points_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Points_GetVisibilityAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreateVisibilityAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Points_GetPurposeAttr(usdGeom_Points_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Points_CreatePurposeAttr(usdGeom_Points_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Points_GetProxyPrimRel(usdGeom_Points_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Points_CreateProxyPrimRel(usdGeom_Points_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Points_MakeVisible(usdGeom_Points_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Points_MakeInvisible(usdGeom_Points_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Points_ComputeVisibility(usdGeom_Points_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Points_GetPurposeVisibilityAttr(usdGeom_Points_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Points_ComputePurposeInfo(usdGeom_Points_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Points_ComputePurposeInfo_given_parent(usdGeom_Points_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Points_ComputePurpose(usdGeom_Points_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Points_ComputeProxyPrim(usdGeom_Points_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Points_SetProxyPrim(usdGeom_Points_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Points_ComputeWorldBound(usdGeom_Points_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Points_ComputeLocalBound(usdGeom_Points_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Points_ComputeUntransformedBound(usdGeom_Points_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Points_ComputeLocalToWorldTransform(usdGeom_Points_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Points_ComputeParentToWorldTransform(usdGeom_Points_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Points_IsConcrete(usdGeom_Points_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Points_IsTyped(usdGeom_Points_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Points_IsAPISchema(usdGeom_Points_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Points_IsAppliedAPISchema(usdGeom_Points_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Points_IsMultipleApplyAPISchema(usdGeom_Points_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Points_GetSchemaKind(usdGeom_Points_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Points_GetPrim(usdGeom_Points_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Points_GetPath(usdGeom_Points_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Points_GetSchemaClassPrimDefinition(usdGeom_Points_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Points_new(usd_Prim_t const* param00, usdGeom_Points_t** _result);

int usdGeom_Points_dtor(usdGeom_Points_t* _this);

/// Return the Primvar's interpolation, which is 
/// \ref Usd_InterpolationVals "UsdGeomTokens->constant" if unauthored
/// 
/// Interpolation determines how the Primvar interpolates over
/// a geometric primitive.  See \ref Usd_InterpolationVals
int usdGeom_Primvar_GetInterpolation(usdGeom_Primvar_t const* _this, tf_Token_t* _result);

/// Set the Primvar's interpolation.
/// 
/// Errors and returns false if \p interpolation is out of range as
/// defined by IsValidInterpolation().  No attempt is made to validate
/// that the Primvar's value contains the right number of elements
/// to match its interpolation to its topology.
/// 
/// \sa GetInterpolation(), \ref Usd_InterpolationVals
int usdGeom_Primvar_SetInterpolation(usdGeom_Primvar_t* _this, tf_Token_t const* interpolation, bool* _result);

/// Has interpolation been explicitly authored on this Primvar?
/// 
/// \sa GetInterpolationSize()
int usdGeom_Primvar_HasAuthoredInterpolation(usdGeom_Primvar_t const* _this, bool* _result);

/// Return the "element size" for this Primvar, which is 1 if
/// unauthored.  If this Primvar's type is \em not an array type,
/// (e.g. "Vec3f[]"), then elementSize is irrelevant.
/// 
/// ElementSize does \em not generally encode the length of an array-type
/// primvar, and rarely needs to be authored.  ElementSize can be thought
/// of as a way to create an "aggregate interpolatable type", by
/// dictating how many consecutive elements in the value array should be
/// taken as an atomic element to be interpolated over a gprim. 
/// 
/// For example, spherical harmonics are often represented as a
/// collection of nine floating-point coefficients, and the coefficients
/// need to be sampled across a gprim's surface: a perfect case for
/// primvars.  However, USD has no <tt>float9</tt> datatype.  But we can
/// communicate the aggregation of nine floats successfully to renderers
/// by declaring a simple float-array valued primvar, and setting its
/// \em elementSize to 9.  To author a \em uniform spherical harmonic
/// primvar on a Mesh of 42 faces, the primvar's array value would contain
/// 9*42 = 378 float elements.
int usdGeom_Primvar_GetElementSize(usdGeom_Primvar_t const* _this, int* _result);

/// Set the elementSize for this Primvar.
/// 
/// Errors and returns false if \p eltSize less than 1.
/// 
/// \sa GetElementSize()
int usdGeom_Primvar_SetElementSize(usdGeom_Primvar_t* _this, int eltSize, bool* _result);

/// Has elementSize been explicitly authored on this Primvar?
/// 
/// \sa GetElementSize()
int usdGeom_Primvar_HasAuthoredElementSize(usdGeom_Primvar_t const* _this, bool* _result);

/// Convenience function for fetching all information required to 
/// properly declare this Primvar.  The \p name returned is the
/// "client name", stripped of the "primvars" namespace, i.e. equivalent to
/// GetPrimvarName()
/// 
/// May also be more efficient than querying key individually.
int usdGeom_Primvar_GetDeclarationInfo(usdGeom_Primvar_t const* _this, tf_Token_t* name, sdf_ValueTypeName_t* typeName, tf_Token_t* interpolation, int* elementSize);

int usdGeom_Primvar_Get(usdGeom_Primvar_t const* _this, vt_Value_t* value, usd_TimeCode_t time, bool* _result);

/// Explicit UsdAttribute extractor
int usdGeom_Primvar_GetAttr(usdGeom_Primvar_t const* _this, usd_Attribute_t const** _result);

/// Return true if the underlying UsdAttribute::IsDefined(), and in
/// addition the attribute is identified as a Primvar.  Does not imply
/// that the primvar provides a value
int usdGeom_Primvar_IsDefined(usdGeom_Primvar_t const* _this, bool* _result);

/// Return true if the underlying attribute has a value, either from
/// authored scene description or a fallback.
int usdGeom_Primvar_HasValue(usdGeom_Primvar_t const* _this, bool* _result);

/// Return true if the underlying attribute has an unblocked, authored
/// value.
int usdGeom_Primvar_HasAuthoredValue(usdGeom_Primvar_t const* _this, bool* _result);

/// Returns the primvar's name, devoid of the "primvars:" namespace.
/// This is the name by which clients should refer to the primvar, if
/// not by its full attribute name - i.e. they should **not**, in general,
/// use GetBaseName().  In the error condition in which this Primvar
/// object is not backed by a properly namespaced UsdAttribute, return
/// an empty TfToken.
int usdGeom_Primvar_GetPrimvarName(usdGeom_Primvar_t const* _this, tf_Token_t* _result);

/// \sa UsdAttribute::GetName()
int usdGeom_Primvar_GetName(usdGeom_Primvar_t const* _this, tf_Token_t const** _result);

/// Does this primvar contain any namespaces other than the "primvars:"
/// namespace?
/// 
/// Some clients may only wish to consume primvars that have no extra
/// namespaces in their names, for ease of translating to other systems
/// that do not allow namespaces.
int usdGeom_Primvar_NameContainsNamespaces(usdGeom_Primvar_t const* _this, bool* _result);

/// \sa UsdAttribute::GetBaseName()
int usdGeom_Primvar_GetBaseName(usdGeom_Primvar_t const* _this, tf_Token_t* _result);

/// \sa UsdAttribute::GetNamespace()
int usdGeom_Primvar_GetNamespace(usdGeom_Primvar_t const* _this, tf_Token_t* _result);

/// \sa UsdAttribute::GetTypeName()
int usdGeom_Primvar_GetTypeName(usdGeom_Primvar_t const* _this, sdf_ValueTypeName_t* _result);

/// \sa UsdAttribute::SplitName()
int usdGeom_Primvar_SplitName(usdGeom_Primvar_t const* _this, std_StringVector_t* _result);

/// Populates a vector with authored sample times for this primvar.
/// Returns false on error.
/// 
/// This considers any timeSamples authored on the associated "indices"
/// attribute if the primvar is indexed.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Primvar_GetTimeSamples(usdGeom_Primvar_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Populates a vector with authored sample times in \p interval. 
/// 
/// This considers any timeSamples authored on the associated "indices"
/// attribute if the primvar is indexed.
/// 
/// \sa UsdAttribute::GetTimeSamplesInInterval
int usdGeom_Primvar_GetTimeSamplesInInterval(usdGeom_Primvar_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Return true if it is possible, but not certain, that this primvar's
/// value changes over time, false otherwise. 
/// 
/// This considers time-varyingness of the associated "indices" attribute 
/// if the primvar is indexed.
/// 
/// \sa UsdAttribute::ValueMightBeTimeVarying
int usdGeom_Primvar_ValueMightBeTimeVarying(usdGeom_Primvar_t const* _this, bool* _result);

/// Returns true if the primvar is an Id primvar.
/// 
/// \sa \ref UsdGeomPrimvar_Id_primvars
int usdGeom_Primvar_IsIdTarget(usdGeom_Primvar_t const* _this, bool* _result);

/// This primvar must be of String or StringArray type for this method to
/// succeed.  If not, a coding error is raised.
/// 
/// \sa \ref UsdGeomPrimvar_Id_primvars
int usdGeom_Primvar_SetIdTarget(usdGeom_Primvar_t const* _this, sdf_Path_t const* path, bool* _result);

/// Test whether a given UsdAttribute represents valid Primvar, which
/// implies that creating a UsdGeomPrimvar from the attribute will succeed.
/// 
/// Success implies that \c attr.IsDefined() is true.
int usdGeom_Primvar_IsPrimvar(usd_Attribute_t const* attr, bool* _result);

/// Test whether a given \p name represents a valid name of a primvar, 
/// which implies that creating a UsdGeomPrimvar with the given name will 
/// succeed.
int usdGeom_Primvar_IsValidPrimvarName(tf_Token_t const* name, bool* _result);

/// Returns the \p name, devoid of the "primvars:" token if present,
/// otherwise returns the \p name unchanged
int usdGeom_Primvar_StripPrimvarsName(tf_Token_t const* name, tf_Token_t* _result);

/// Validate that the provided \p interpolation is a valid setting for 
/// interpolation as defined by \ref Usd_InterpolationVals.  
int usdGeom_Primvar_IsValidInterpolation(tf_Token_t const* interpolation, bool* _result);

int usdGeom_Primvar_new(usd_Attribute_t const* param00, usdGeom_Primvar_t** _result);

int usdGeom_Primvar_dtor(usdGeom_Primvar_t* _this);

int usdGeom_PrimvarVector_data(usdGeom_PrimvarVector_t* _this, usdGeom_Primvar_t** _result);

int usdGeom_PrimvarVector_data_const(usdGeom_PrimvarVector_t const* _this, usdGeom_Primvar_t const** _result);

int usdGeom_PrimvarVector_empty(usdGeom_PrimvarVector_t const* _this, bool* _result);

int usdGeom_PrimvarVector_size(usdGeom_PrimvarVector_t const* _this, size_t* _result);

int usdGeom_PrimvarVector_max_size(usdGeom_PrimvarVector_t const* _this, size_t* _result);

int usdGeom_PrimvarVector_reserve(usdGeom_PrimvarVector_t* _this, size_t const _Newcapacity);

int usdGeom_PrimvarVector_capacity(usdGeom_PrimvarVector_t const* _this, size_t* _result);

int usdGeom_PrimvarVector_clear(usdGeom_PrimvarVector_t* _this);

int usdGeom_PrimvarVector_push_back(usdGeom_PrimvarVector_t* _this, usdGeom_Primvar_t const* _Val);

int usdGeom_PrimvarVector_pop_back(usdGeom_PrimvarVector_t* _this);

int usdGeom_PrimvarVector_resize(usdGeom_PrimvarVector_t* _this, size_t const _Newsize);

int usdGeom_PrimvarVector_resize_with(usdGeom_PrimvarVector_t* _this, size_t const _Newsize, usdGeom_Primvar_t const* _Val);

int usdGeom_PrimvarVector_op_index(usdGeom_PrimvarVector_t const* _this, size_t const _Pos, usdGeom_Primvar_t const** _result);

int usdGeom_PrimvarVector_default(usdGeom_PrimvarVector_t** _result);

int usdGeom_PrimvarVector_dtor(usdGeom_PrimvarVector_t* _this);

/// Author scene description to create an attribute on this prim that
/// will be recognized as Primvar (i.e. will present as a valid
/// UsdGeomPrimvar).
/// 
/// The name of the created attribute may or may not be the specified
/// \p name, due to the possible need to apply property namespacing
/// for primvars.  See \ref Usd_Creating_and_Accessing_Primvars
/// for more information.  Creation may fail and return an invalid
/// Primvar if \p name contains a reserved keyword, such as the 
/// "indices" suffix we use for indexed primvars.
/// 
/// The behavior with respect to the provided \p typeName
/// is the same as for UsdAttributes::Create(), and
/// \p interpolation and \p elementSize are as described in
/// UsdGeomPrimvar::GetInterpolation() and UsdGeomPrimvar::GetElementSize().
/// 
/// If \p interpolation and/or \p elementSize are left unspecified, we
/// will author no opinions for them, which means any (strongest) opinion
/// already authored in any contributing layer for these fields will
/// become the Primvar's values, or the fallbacks if no opinions
/// have been authored.
/// 
/// \return an invalid UsdGeomPrimvar if we failed to create a valid
/// attribute, a valid UsdGeomPrimvar otherwise.  It is not an
/// error to create over an existing, compatible attribute.
/// 
/// \sa UsdPrim::CreateAttribute(), UsdGeomPrimvar::IsPrimvar()
int usdGeom_PrimvarsAPI_CreatePrimvar(usdGeom_PrimvarsAPI_t const* _this, tf_Token_t const* name, sdf_ValueTypeName_t const* typeName, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Author scene description to delete an attribute on this prim that
/// was recognized as Primvar (i.e. will present as a valid UsdGeomPrimvar),
/// <em>in the current UsdEditTarget</em>.
/// 
/// Because this method can only remove opinions about the primvar 
/// from the current EditTarget, you may generally find it more useful to 
/// use BlockPrimvar() which will ensure that all values from the EditTarget 
/// and weaker layers for the primvar and its indices will be ignored.
/// 
/// Removal may fail and return false if \p name contains a reserved 
/// keyword, such as the "indices" suffix we use for indexed primvars.
/// 
/// Note this will also remove the indices attribute associated with an
/// indiced primvar. 
/// 
/// \return true if UsdGeomPrimvar and indices attribute was successfully 
/// removed, false otherwise.
/// 
/// \sa UsdPrim::RemoveProperty())
int usdGeom_PrimvarsAPI_RemovePrimvar(usdGeom_PrimvarsAPI_t* _this, tf_Token_t const* name, bool* _result);

/// Remove all time samples on the primvar and its associated indices attr, 
/// and author a *block* \c default value. This will cause authored opinions
/// in weaker layers to be ignored.
/// 
/// \sa UsdAttribute::Block(), UsdGeomPrimvar::BlockIndices
int usdGeom_PrimvarsAPI_BlockPrimvar(usdGeom_PrimvarsAPI_t* _this, tf_Token_t const* name);

/// Return the Primvar object named by \p name, which will
/// be valid if a Primvar attribute definition already exists.
/// 
/// Name lookup will account for Primvar namespacing, which means
/// that this method will succeed in some cases where
/// \code
/// UsdGeomPrimvar(prim->GetAttribute(name))
/// \endcode
/// will not, unless \p name is properly namespace prefixed.
/// 
/// \note Just because a Primvar is valid and defined, and *even if* its
/// underlying UsdAttribute (GetAttr()) answers HasValue() affirmatively,
/// one must still check the return value of Get(), due to the potential
/// of time-varying value blocks (see \ref Usd_AttributeBlocking).
/// 
/// \sa HasPrimvar(), \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_GetPrimvar(usdGeom_PrimvarsAPI_t const* _this, tf_Token_t const* name, usdGeom_Primvar_t* _result);

/// Return valid UsdGeomPrimvar objects for all defined Primvars on
/// this prim, similarly to UsdPrim::GetAttributes().
/// 
/// The returned primvars may not possess any values, and therefore not
/// be useful to some clients. For the primvars useful for inheritance
/// computations, see GetPrimvarsWithAuthoredValues(), and for primvars
/// useful for direct consumption, see GetPrimvarsWithValues().
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_GetPrimvars(usdGeom_PrimvarsAPI_t const* _this, usdGeom_PrimvarVector_t* _result);

/// Like GetPrimvars(), but include only primvars that have some
/// authored scene description (though not necessarily a value).
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_GetAuthoredPrimvars(usdGeom_PrimvarsAPI_t const* _this, usdGeom_PrimvarVector_t* _result);

/// Like GetPrimvars(), but include only primvars that have some
/// value, whether it comes from authored scene description or a schema
/// fallback.
/// 
/// For most purposes, this method is more useful than GetPrimvars().
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_GetPrimvarsWithValues(usdGeom_PrimvarsAPI_t const* _this, usdGeom_PrimvarVector_t* _result);

/// Like GetPrimvars(), but include only primvars that have an **authored**
/// value.
/// 
/// This is the query used when computing inheritable primvars, and is
/// generally more useful than GetAuthoredPrimvars().
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_GetPrimvarsWithAuthoredValues(usdGeom_PrimvarsAPI_t const* _this, usdGeom_PrimvarVector_t* _result);

/// Compute the primvars that can be inherited from this prim by its
/// child prims, including the primvars that **this** prim inherits from
/// ancestor prims.  Inherited primvars will be bound to attributes on
/// the corresponding ancestor prims.
/// 
/// Only primvars with **authored**, **non-blocked**,
/// **constant interpolation** values are inheritable;
/// fallback values are not inherited.   The order of the returned
/// primvars is undefined.
/// 
/// It is not generally useful to call this method on UsdGeomGprim leaf
/// prims, and furthermore likely to be expensive since *most* primvars
/// are defined on Gprims.
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_FindInheritablePrimvars(usdGeom_PrimvarsAPI_t const* _this, usdGeom_PrimvarVector_t* _result);

/// Compute the primvars that can be inherited from this prim by its
/// child prims, starting from the set of primvars inherited from
/// this prim's ancestors.  If this method returns an empty vector, then
/// this prim's children should inherit the same set of primvars available
/// to this prim, i.e. the input `inheritedFromAncestors` .
/// 
/// As opposed to FindInheritablePrimvars(), which always recurses up
/// through all of the prim's ancestors, this method allows more
/// efficient computation of inheritable primvars by starting with the
/// list of primvars inherited from this prim's ancestors, and returning
/// a newly allocated vector only when this prim makes a change to the
/// set of inherited primvars.  This enables O(n) inherited primvar
/// computation for all prims on a Stage, with potential to share
/// computed results that are identical (i.e. when this method returns an
/// empty vector, its parent's result can (and must!) be reused for all
/// of the prim's children.
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_FindIncrementallyInheritablePrimvars(usdGeom_PrimvarsAPI_t const* _this, usdGeom_PrimvarVector_t const* inheritedFromAncestors, usdGeom_PrimvarVector_t* _result);

/// Like GetPrimvar(), but if the named primvar does not exist or has no
/// authored value on this prim, search for the named, value-producing
/// primvar on ancestor prims.
/// 
/// The returned primvar will be bound to the attribute on the 
/// corresponding ancestor prim on which it was found (if any).  If neither
/// this prim nor any ancestor contains a value-producing primvar, then
/// the returned primvar will be the same as that returned by GetPrimvar().
/// 
/// This is probably the method you want to call when needing to consume
/// a primvar of a particular name.
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_FindPrimvarWithInheritance(usdGeom_PrimvarsAPI_t const* _this, tf_Token_t const* name, usdGeom_Primvar_t* _result);

/// \overload
/// 
/// This version of FindPrimvarWithInheritance() takes the pre-computed
/// set of primvars inherited from this prim's ancestors, as computed
/// by FindInheritablePrimvars() or FindIncrementallyInheritablePrimvars()
/// on the prim's parent.
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_FindPrimvarWIthInheritance_from(usdGeom_PrimvarsAPI_t const* _this, tf_Token_t const* name, usdGeom_PrimvarVector_t const* inheritedFromAncestors, usdGeom_Primvar_t* _result);

/// Find all of the value-producing primvars either defined on this prim,
/// or inherited from ancestor prims.
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_FindPrimvarsWithInheritance(usdGeom_PrimvarsAPI_t const* _this, usdGeom_PrimvarVector_t* _result);

/// \overload
/// 
/// This version of FindPrimvarsWithInheritance() takes the pre-computed
/// set of primvars inherited from this prim's ancestors, as computed
/// by FindInheritablePrimvars() or FindIncrementallyInheritablePrimvars()
/// on the prim's parent.
/// 
/// \sa \ref usdGeom_PrimvarFetchingAPI
int usdGeom_PrimvarsAPI_FindPrimvarsWIthInheritance_from(usdGeom_PrimvarsAPI_t const* _this, usdGeom_PrimvarVector_t const* inheritedFromAncestors, usdGeom_PrimvarVector_t* _result);

/// Is there a defined Primvar \p name on this prim?
/// 
/// Name lookup will account for Primvar namespacing.
/// 
/// Like GetPrimvar(), a return value of `true` for HasPrimvar() does not
/// guarantee the primvar will produce a value.
int usdGeom_PrimvarsAPI_HasPrimvar(usdGeom_PrimvarsAPI_t const* _this, tf_Token_t const* name, bool* _result);

/// Is there a Primvar named \p name with an authored value on this
/// prim or any of its ancestors?
/// 
/// This is probably the method you want to call when wanting to know
/// whether or not the prim "has" a primvar of a particular name.
/// 
/// \sa FindPrimvarWithInheritance()
int usdGeom_PrimvarsAPI_HasPossiblyInheritedPrimvar(usdGeom_PrimvarsAPI_t const* _this, tf_Token_t const* name, bool* _result);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes.  Does not include attributes that
/// may be authored by custom/extended methods of the schemas involved.
int usdGeom_PrimvarsAPI_GetSchemaAttributeNames(bool includeInherited, tf_TokenVector_t const** _result);

/// Return a UsdGeomPrimvarsAPI holding the prim adhering to this
/// schema at \p path on \p stage.  If no prim exists at \p path on
/// \p stage, or if the prim at that path does not adhere to this schema,
/// return an invalid schema object.  This is shorthand for the following:
/// 
/// \code
/// UsdGeomPrimvarsAPI(stage->GetPrimAtPath(path));
/// \endcode
int usdGeom_PrimvarsAPI_Get(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usdGeom_PrimvarsAPI_t* _result);

/// Test whether a given \p name contains the "primvars:" prefix
int usdGeom_PrimvarsAPI_CanContainPropertyName(tf_Token_t const* name, bool* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_PrimvarsAPI_IsConcrete(usdGeom_PrimvarsAPI_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_PrimvarsAPI_IsTyped(usdGeom_PrimvarsAPI_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_PrimvarsAPI_IsAPISchema(usdGeom_PrimvarsAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_PrimvarsAPI_IsAppliedAPISchema(usdGeom_PrimvarsAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_PrimvarsAPI_IsMultipleApplyAPISchema(usdGeom_PrimvarsAPI_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_PrimvarsAPI_GetSchemaKind(usdGeom_PrimvarsAPI_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_PrimvarsAPI_GetPrim(usdGeom_PrimvarsAPI_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_PrimvarsAPI_GetPath(usdGeom_PrimvarsAPI_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_PrimvarsAPI_GetSchemaClassPrimDefinition(usdGeom_PrimvarsAPI_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_PrimvarsAPI_new(usd_Prim_t const* param00, usdGeom_PrimvarsAPI_t** _result);

int usdGeom_PrimvarsAPI_dtor(usdGeom_PrimvarsAPI_t* _this);

/// Return a UsdGeomScope holding the prim adhering to this
/// schema at \p path on \p stage.  If no prim exists at \p path on
/// \p stage, or if the prim at that path does not adhere to this schema,
/// return an invalid schema object.  This is shorthand for the following:
/// 
/// \code
/// UsdGeomScope(stage->GetPrimAtPath(path));
/// \endcode
int usdGeom_Scope_Get(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usdGeom_Scope_t* _result);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes.  Does not include attributes that
/// may be authored by custom/extended methods of the schemas involved.
int usdGeom_Scope_GetSchemaAttributeNames(bool includeInherited, tf_TokenVector_t const** _result);

/// Attempt to ensure a \a UsdPrim adhering to this schema at \p path
/// is defined (according to UsdPrim::IsDefined()) on this stage.
/// 
/// If a prim adhering to this schema at \p path is already defined on this
/// stage, return that prim.  Otherwise author an \a SdfPrimSpec with
/// \a specifier == \a SdfSpecifierDef and this schema's prim type name for
/// the prim at \p path at the current EditTarget.  Author \a SdfPrimSpec s
/// with \p specifier == \a SdfSpecifierDef and empty typeName at the
/// current EditTarget for any nonexistent, or existing but not \a Defined
/// ancestors.
/// 
/// The given \a path must be an absolute prim path that does not contain
/// any variant selections.
/// 
/// If it is impossible to author any of the necessary PrimSpecs, (for
/// example, in case \a path cannot map to the current UsdEditTarget's
/// namespace) issue an error and return an invalid \a UsdPrim.
/// 
/// Note that this method may return a defined prim whose typeName does not
/// specify this schema class, in case a stronger typeName opinion overrides
/// the opinion at the current EditTarget.
int usdGeom_Scope_Define(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usdGeom_Scope_t* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Scope_GetVisibilityAttr(usdGeom_Scope_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Scope_CreateVisibilityAttr(usdGeom_Scope_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Scope_GetPurposeAttr(usdGeom_Scope_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Scope_CreatePurposeAttr(usdGeom_Scope_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Scope_GetProxyPrimRel(usdGeom_Scope_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Scope_CreateProxyPrimRel(usdGeom_Scope_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Scope_MakeVisible(usdGeom_Scope_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Scope_MakeInvisible(usdGeom_Scope_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Scope_ComputeVisibility(usdGeom_Scope_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Scope_GetPurposeVisibilityAttr(usdGeom_Scope_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Scope_ComputePurposeInfo(usdGeom_Scope_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Scope_ComputePurposeInfo_given_parent(usdGeom_Scope_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Scope_ComputePurpose(usdGeom_Scope_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Scope_ComputeProxyPrim(usdGeom_Scope_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Scope_SetProxyPrim(usdGeom_Scope_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Scope_ComputeWorldBound(usdGeom_Scope_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Scope_ComputeLocalBound(usdGeom_Scope_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Scope_ComputeUntransformedBound(usdGeom_Scope_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Scope_ComputeLocalToWorldTransform(usdGeom_Scope_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Scope_ComputeParentToWorldTransform(usdGeom_Scope_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Scope_IsConcrete(usdGeom_Scope_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Scope_IsTyped(usdGeom_Scope_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Scope_IsAPISchema(usdGeom_Scope_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Scope_IsAppliedAPISchema(usdGeom_Scope_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Scope_IsMultipleApplyAPISchema(usdGeom_Scope_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Scope_GetSchemaKind(usdGeom_Scope_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Scope_GetPrim(usdGeom_Scope_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Scope_GetPath(usdGeom_Scope_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Scope_GetSchemaClassPrimDefinition(usdGeom_Scope_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Scope_new(usd_Prim_t const* param00, usdGeom_Scope_t** _result);

int usdGeom_Scope_dtor(usdGeom_Scope_t* _this);

/// Indicates the sphere's radius.  If you
/// author \em radius you must also author \em extent.
/// 
/// \sa GetExtentAttr()
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `double radius = 1` |
/// | C++ Type | double |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Double |
int usdGeom_Sphere_GetRadiusAttr(usdGeom_Sphere_t const* _this, usd_Attribute_t* _result);

/// See GetRadiusAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Sphere_CreateRadiusAttr(usdGeom_Sphere_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// It is useful to have an "official" colorSet that can be used
/// as a display or modeling color, even in the absence of any specified
/// shader for a gprim.  DisplayColor serves this role; because it is a
/// UsdGeomPrimvar, it can also be used as a gprim override for any shader
/// that consumes a \em displayColor parameter.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `color3f[] primvars:displayColor` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Color3fArray |
int usdGeom_Sphere_GetDisplayColorAttr(usdGeom_Sphere_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayColorAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Sphere_CreateDisplayColorAttr(usdGeom_Sphere_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Companion to \em displayColor that specifies opacity, broken
/// out as an independent attribute rather than an rgba color, both so that
/// each can be independently overridden, and because shaders rarely consume
/// rgba parameters.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float[] primvars:displayOpacity` |
/// | C++ Type | VtArray<float> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->FloatArray |
int usdGeom_Sphere_GetDisplayOpacityAttr(usdGeom_Sphere_t const* _this, usd_Attribute_t* _result);

/// See GetDisplayOpacityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Sphere_CreateDisplayOpacityAttr(usdGeom_Sphere_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Although some renderers treat all parametric or polygonal
/// surfaces as if they were effectively laminae with outward-facing
/// normals on both sides, some renderers derive significant optimizations
/// by considering these surfaces to have only a single outward side,
/// typically determined by control-point winding order and/or 
/// \em orientation.  By doing so they can perform "backface culling" to
/// avoid drawing the many polygons of most closed surfaces that face away
/// from the viewer.
/// 
/// However, it is often advantageous to model thin objects such as paper
/// and cloth as single, open surfaces that must be viewable from both
/// sides, always.  Setting a gprim's \em doubleSided attribute to 
/// \c true instructs all renderers to disable optimizations such as
/// backface culling for the gprim, and attempt (not all renderers are able
/// to do so, but the USD reference GL renderer always will) to provide
/// forward-facing normals on each side of the surface for lighting
/// calculations.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool doubleSided = 0` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Sphere_GetDoubleSidedAttr(usdGeom_Sphere_t const* _this, usd_Attribute_t* _result);

/// See GetDoubleSidedAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Sphere_CreateDoubleSidedAttr(usdGeom_Sphere_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Orientation specifies whether the gprim's surface normal 
/// should be computed using the right hand rule, or the left hand rule.
/// Please see \ref UsdGeom_WindingOrder for a deeper explanation and
/// generalization of orientation to composed scenes with transformation
/// hierarchies.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token orientation = "rightHanded"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | rightHanded, leftHanded |
int usdGeom_Sphere_GetOrientationAttr(usdGeom_Sphere_t const* _this, usd_Attribute_t* _result);

/// See GetOrientationAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Sphere_CreateOrientationAttr(usdGeom_Sphere_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Convenience function to get the displayColor Attribute as a Primvar.
/// 
/// \sa GetDisplayColorAttr(), CreateDisplayColorPrimvar()
int usdGeom_Sphere_GetDisplayColorPrimvar(usdGeom_Sphere_t const* _this, usdGeom_Primvar_t* _result);

/// Convenience function to create the displayColor primvar, optionally
/// specifying interpolation and elementSize
/// 
/// \sa CreateDisplayColorAttr(), GetDisplayColorPrimvar()
int usdGeom_Sphere_CreateDisplayColorPrimvar(usdGeom_Sphere_t const* _this, tf_Token_t const* interpolation, int elementSize, usdGeom_Primvar_t* _result);

/// Extent is re-defined on Sphere only to provide a fallback
/// value. \sa UsdGeomGprim::GetExtentAttr().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `float3[] extent = [(-1, -1, -1), (1, 1, 1)]` |
/// | C++ Type | VtArray<GfVec3f> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Float3Array |
int usdGeom_Sphere_GetExtentAttr(usdGeom_Sphere_t const* _this, usd_Attribute_t* _result);

/// See GetExtentAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Sphere_CreateExtentAttr(usdGeom_Sphere_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Sphere_GetXformOpOrderAttr(usdGeom_Sphere_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Sphere_AddXformOp(usdGeom_Sphere_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Sphere_AddTranslateOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Sphere_AddScaleOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Sphere_AddRotateXOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Sphere_AddRotateYOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Sphere_AddRotateZOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Sphere_AddRotateXYZOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Sphere_AddRotateXZYOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Sphere_AddRotateYXZOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Sphere_AddRotateYZXOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Sphere_AddRotateZXYOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Sphere_AddRotateZYXOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Sphere_AddOrientOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Sphere_AddTransformOp(usdGeom_Sphere_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Sphere_SetResetXformStack(usdGeom_Sphere_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Sphere_SetXformOpOrder(usdGeom_Sphere_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Sphere_GetOrderedXformOps(usdGeom_Sphere_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Sphere_ClearXformOpOrder(usdGeom_Sphere_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Sphere_MakeMatrixXform(usdGeom_Sphere_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Sphere_TransformMightBeTimeVarying(usdGeom_Sphere_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Sphere_TransformMightBeTimeVarying_using(usdGeom_Sphere_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Sphere_GetTimeSamples(usdGeom_Sphere_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Sphere_GetTimeSamplesInInterval(usdGeom_Sphere_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Sphere_GetLocalTransformation(usdGeom_Sphere_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Sphere_GetLocalTransformation_with_ops(usdGeom_Sphere_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Sphere_GetVisibilityAttr(usdGeom_Sphere_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Sphere_CreateVisibilityAttr(usdGeom_Sphere_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Sphere_GetPurposeAttr(usdGeom_Sphere_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Sphere_CreatePurposeAttr(usdGeom_Sphere_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Sphere_GetProxyPrimRel(usdGeom_Sphere_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Sphere_CreateProxyPrimRel(usdGeom_Sphere_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Sphere_MakeVisible(usdGeom_Sphere_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Sphere_MakeInvisible(usdGeom_Sphere_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Sphere_ComputeVisibility(usdGeom_Sphere_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Sphere_GetPurposeVisibilityAttr(usdGeom_Sphere_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Sphere_ComputePurposeInfo(usdGeom_Sphere_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Sphere_ComputePurposeInfo_given_parent(usdGeom_Sphere_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Sphere_ComputePurpose(usdGeom_Sphere_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Sphere_ComputeProxyPrim(usdGeom_Sphere_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Sphere_SetProxyPrim(usdGeom_Sphere_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Sphere_ComputeWorldBound(usdGeom_Sphere_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Sphere_ComputeLocalBound(usdGeom_Sphere_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Sphere_ComputeUntransformedBound(usdGeom_Sphere_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Sphere_ComputeLocalToWorldTransform(usdGeom_Sphere_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Sphere_ComputeParentToWorldTransform(usdGeom_Sphere_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Sphere_IsConcrete(usdGeom_Sphere_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Sphere_IsTyped(usdGeom_Sphere_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Sphere_IsAPISchema(usdGeom_Sphere_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Sphere_IsAppliedAPISchema(usdGeom_Sphere_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Sphere_IsMultipleApplyAPISchema(usdGeom_Sphere_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Sphere_GetSchemaKind(usdGeom_Sphere_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Sphere_GetPrim(usdGeom_Sphere_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Sphere_GetPath(usdGeom_Sphere_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Sphere_GetSchemaClassPrimDefinition(usdGeom_Sphere_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Sphere_new(usd_Prim_t const* param00, usdGeom_Sphere_t** _result);

int usdGeom_Sphere_dtor(usdGeom_Sphere_t* _this);

/// The type of element that the indices target. Currently only 
/// allows "face" and defaults to it.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token elementType = "face"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | face |
int usdGeom_Subset_GetElementTypeAttr(usdGeom_Subset_t const* _this, usd_Attribute_t* _result);

/// See GetElementTypeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Subset_CreateElementTypeAttr(usdGeom_Subset_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The set of indices included in this subset. The indices need not 
/// be sorted, but the same index should not appear more than once.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `int[] indices = []` |
/// | C++ Type | VtArray<int> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->IntArray |
int usdGeom_Subset_GetIndicesAttr(usdGeom_Subset_t const* _this, usd_Attribute_t* _result);

/// See GetIndicesAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Subset_CreateIndicesAttr(usdGeom_Subset_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The name of the family of subsets that this subset belongs to. 
/// This is optional and is primarily useful when there are multiple 
/// families of subsets under a geometric prim. In some cases, this could 
/// also be used for achieving proper roundtripping of subset data between 
/// DCC apps.
/// When multiple subsets belonging to a prim have the same familyName, they 
/// are said to belong to the family. A <i>familyType</i> value can be 
/// encoded on the owner of a family of subsets as a token using the static 
/// method UsdGeomSubset::SetFamilyType(). "familyType" can have one of the 
/// following values:
/// <ul><li><b>UsdGeomTokens->partition</b>: implies that every element of 
/// the whole geometry appears exactly once in only one of the subsets
/// belonging to the family.</li>
/// <li><b>UsdGeomTokens->nonOverlapping</b>: an element that appears in one 
/// subset may not appear in any other subset belonging to the family.</li>
/// <li><b>UsdGeomTokens->unrestricted</b>: implies that there are no
/// restrictions w.r.t. the membership of elements in the subsets. They 
/// could be overlapping and the union of all subsets in the family may 
/// not represent the whole.</li>
/// </ul>
/// \note The validity of subset data is not enforced by the authoring 
/// APIs, however they can be checked using UsdGeomSubset::ValidateFamily().
/// 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token familyName = ""` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Subset_GetFamilyNameAttr(usdGeom_Subset_t const* _this, usd_Attribute_t* _result);

/// See GetFamilyNameAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Subset_CreateFamilyNameAttr(usdGeom_Subset_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Return a UsdGeomSubset holding the prim adhering to this
/// schema at \p path on \p stage.  If no prim exists at \p path on
/// \p stage, or if the prim at that path does not adhere to this schema,
/// return an invalid schema object.  This is shorthand for the following:
/// 
/// \code
/// UsdGeomSubset(stage->GetPrimAtPath(path));
/// \endcode
int usdGeom_Subset_Get(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usdGeom_Subset_t* _result);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes.  Does not include attributes that
/// may be authored by custom/extended methods of the schemas involved.
int usdGeom_Subset_GetSchemaAttributeNames(bool includeInherited, tf_TokenVector_t const** _result);

/// Attempt to ensure a \a UsdPrim adhering to this schema at \p path
/// is defined (according to UsdPrim::IsDefined()) on this stage.
/// 
/// If a prim adhering to this schema at \p path is already defined on this
/// stage, return that prim.  Otherwise author an \a SdfPrimSpec with
/// \a specifier == \a SdfSpecifierDef and this schema's prim type name for
/// the prim at \p path at the current EditTarget.  Author \a SdfPrimSpec s
/// with \p specifier == \a SdfSpecifierDef and empty typeName at the
/// current EditTarget for any nonexistent, or existing but not \a Defined
/// ancestors.
/// 
/// The given \a path must be an absolute prim path that does not contain
/// any variant selections.
/// 
/// If it is impossible to author any of the necessary PrimSpecs, (for
/// example, in case \a path cannot map to the current UsdEditTarget's
/// namespace) issue an error and return an invalid \a UsdPrim.
/// 
/// Note that this method may return a defined prim whose typeName does not
/// specify this schema class, in case a stronger typeName opinion overrides
/// the opinion at the current EditTarget.
int usdGeom_Subset_Define(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usdGeom_Subset_t* _result);

/// Creates a new GeomSubset below the given \p geom with the given 
/// name, \p subsetName, element type, \p elementType and \p indices.
/// 
/// If a subset named \p subsetName already exists below \p geom, then 
/// this updates its attributes with the values of the provided arguments 
/// (indices value at time 'default' will be updated) and returns it. 
/// 
/// The family type is set / updated on \p geom only if a non-empty value 
/// is passed in for \p familyType and \p familyName.
int usdGeom_Subset_CreateGeomSubset(usdGeom_Imageable_t const* geom, tf_Token_t const* subsetName, tf_Token_t const* elementType, vt_IntArray_t const* indices, tf_Token_t const* familyName, tf_Token_t const* familyType, usdGeom_Subset_t* _result);

/// Creates a new GeomSubset below the given imageable, \p geom with the 
/// given name, \p subsetName, element type, \p elementType and \p indices.
/// 
/// If a subset named \p subsetName already exists below \p geom, then 
/// this creates a new subset by appending a suitable index as suffix to 
/// \p subsetName (eg, subsetName_1) to avoid name collisions.
/// 
/// The family type is set / updated on \p geom only if a non-empty value 
/// is passed in for \p familyType and \p familyName.
int usdGeom_Subset_CreateUniqueGeomSubset(usdGeom_Imageable_t const* geom, tf_Token_t const* subsetName, tf_Token_t const* elementType, vt_IntArray_t const* indices, tf_Token_t const* familyName, tf_Token_t const* familyType, usdGeom_Subset_t* _result);

/// Returns all the GeomSubsets defined on the given imageable, \p geom. 
int usdGeom_Subset_GetAllGeomSubsets(usdGeom_Imageable_t const* geom, usdGeom_SubsetVector_t* _result);

/// Returns all the GeomSubsets of the given \p elementType belonging to 
/// the specified family, \p familyName on the given imageable, \p geom.
/// If \p elementType is empty, then subsets containing all element types 
/// are returned.
/// If \p familyName is left empty, then all subsets of the specified 
/// \p elementType will be returned.
int usdGeom_Subset_GetGeomSubsets(usdGeom_Imageable_t const* geom, tf_Token_t const* elementType, tf_Token_t const* familyName, usdGeom_SubsetVector_t* _result);

/// This method is used to encode the type of family that the GeomSubsets 
/// on the given geometric prim \p geom, with the given family name, 
/// \p familyName belong to. 
/// 
/// See \ref UsdGeomSubset::GetFamilyNameAttr for the possible values for 
/// \p familyType.
/// 
/// When a family of GeomSubsets is tagged as a UsdGeomTokens->partition or 
/// UsdGeomTokens->nonOverlapping, the validity of the data (i.e. 
/// mutual exclusivity and/or wholeness) is not enforced by the authoring 
/// APIs. Use ValidateFamily() to validate the data in a family of 
/// GeomSubsets.
/// 
/// \return Returns false upon failure to create or set the appropriate
/// attribute on \p geom.
int usdGeom_Subset_SetFamilyType(usdGeom_Imageable_t const* geom, tf_Token_t const* familyName, tf_Token_t const* familyType, bool* _result);

/// Returns the type of family that the GeomSubsets on the given geometric 
/// prim \p geom, with the given family name, \p familyName belong to. 
/// 
/// This only returns the token that's encoded on \p geom and does not perform 
/// any actual validation on the family of GeomSubsets. Please use 
/// ValidateFamily() for such validation.
/// 
/// When familyType is not set on \p geom, the fallback value 
/// UsdTokens->unrestricted is returned.
int usdGeom_Subset_GetFamilyType(usdGeom_Imageable_t const* geom, tf_Token_t const* familyName, tf_Token_t* _result);

/// Utility for getting the list of indices that are not assigned to any of 
/// the GeomSubsets in \p subsets at the timeCode, \p time, given the 
/// element count (total number of indices in the array being subdivided), 
/// \p elementCount.
int usdGeom_Subset_GetUnassignedIndices(usdGeom_SubsetVector_t const* subsets, size_t const elementCount, usd_TimeCode_t const* time, vt_IntArray_t* _result);

/// Validates the data in the given set of GeomSubsets, \p subsets, given 
/// the total number of elements in the array being subdivided,
/// \p elementCount and the \p familyType that the subsets belong to.  
/// 
/// For proper validation of indices in \p subsets, all of the GeomSubsets 
/// must have the same 'elementType'.
/// 
/// If one or more subsets contain invalid data, then false is returned and 
/// \p reason is populated with a string explaining the reason why it is 
/// invalid.
/// 
/// The python version of this method returns a tuple containing 
/// a (bool, string), where the bool has the validity of the subsets and 
/// the string contains the reason (if they're invalid).
int usdGeom_Subset_ValidateSubsets(usdGeom_SubsetVector_t const* subsets, size_t const elementCount, tf_Token_t const* familyType, std_String_t* const reason, bool* _result);

/// Validates whether the family of subsets identified by the given 
/// \p familyName and \p elementType on the given imageable, \p geom contain 
/// valid data. If the family is designated as a partition or as 
/// non-overlapping using SetFamilyType(), then the validity of the data 
/// is checked. If the familyType is "unrestricted", then this performs only
/// bounds checking of the values in the "indices" arrays.
/// 
/// If \p reason is not NULL, then it is populated with a string explaining 
/// why the family is invalid, if it is invalid.
/// 
/// The python version of this method returns a tuple containing 
/// a (bool, string), where the bool has the validity of the family and 
/// the string contains the reason (if it's invalid).
int usdGeom_Subset_ValidateFamily(usdGeom_Imageable_t const* geom, tf_Token_t const* elementType, tf_Token_t const* familyName, std_String_t* const reason, bool* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Subset_IsConcrete(usdGeom_Subset_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Subset_IsTyped(usdGeom_Subset_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Subset_IsAPISchema(usdGeom_Subset_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Subset_IsAppliedAPISchema(usdGeom_Subset_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Subset_IsMultipleApplyAPISchema(usdGeom_Subset_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Subset_GetSchemaKind(usdGeom_Subset_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Subset_GetPrim(usdGeom_Subset_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Subset_GetPath(usdGeom_Subset_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Subset_GetSchemaClassPrimDefinition(usdGeom_Subset_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Subset_new(usd_Prim_t const* param00, usdGeom_Subset_t** _result);

int usdGeom_Subset_dtor(usdGeom_Subset_t* _this);

int usdGeom_SubsetVector_data(usdGeom_SubsetVector_t* _this, usdGeom_Subset_t** _result);

int usdGeom_SubsetVector_data_const(usdGeom_SubsetVector_t const* _this, usdGeom_Subset_t const** _result);

int usdGeom_SubsetVector_empty(usdGeom_SubsetVector_t const* _this, bool* _result);

int usdGeom_SubsetVector_size(usdGeom_SubsetVector_t const* _this, size_t* _result);

int usdGeom_SubsetVector_max_size(usdGeom_SubsetVector_t const* _this, size_t* _result);

int usdGeom_SubsetVector_reserve(usdGeom_SubsetVector_t* _this, size_t const _Newcapacity);

int usdGeom_SubsetVector_capacity(usdGeom_SubsetVector_t const* _this, size_t* _result);

int usdGeom_SubsetVector_clear(usdGeom_SubsetVector_t* _this);

int usdGeom_SubsetVector_push_back(usdGeom_SubsetVector_t* _this, usdGeom_Subset_t const* _Val);

int usdGeom_SubsetVector_pop_back(usdGeom_SubsetVector_t* _this);

int usdGeom_SubsetVector_resize(usdGeom_SubsetVector_t* _this, size_t const _Newsize);

int usdGeom_SubsetVector_resize_with(usdGeom_SubsetVector_t* _this, size_t const _Newsize, usdGeom_Subset_t const* _Val);

int usdGeom_SubsetVector_op_index(usdGeom_SubsetVector_t const* _this, size_t const _Pos, usdGeom_Subset_t const** _result);

int usdGeom_SubsetVector_default(usdGeom_SubsetVector_t** _result);

int usdGeom_SubsetVector_dtor(usdGeom_SubsetVector_t* _this);

/// 
/// This attribute controls visibility for geometry with purpose "guide".
/// 
/// Unlike overall _visibility_, _guideVisibility_ is uniform, and
/// therefore cannot be animated.
/// 
/// Also unlike overall _visibility_, _guideVisibility_ is tri-state, in
/// that a descendant with an opinion of "visible" overrides an ancestor
/// opinion of "invisible".
/// 
/// The _guideVisibility_ attribute works in concert with the overall
/// _visibility_ attribute: The visibility of a prim with purpose "guide"
/// is determined by the inherited values it receives for the _visibility_
/// and _guideVisibility_ attributes. If _visibility_ evaluates to
/// "invisible", the prim is invisible. If _visibility_ evaluates to
/// "inherited" and _guideVisibility_ evaluates to "visible", then the
/// prim is visible. __Otherwise, it is invisible.__
/// 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token guideVisibility = "invisible"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible, visible |
int usdGeom_VisibilityAPI_GetGuideVisibilityAttr(usdGeom_VisibilityAPI_t const* _this, usd_Attribute_t* _result);

/// See GetGuideVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_VisibilityAPI_CreateGuideVisibilityAttr(usdGeom_VisibilityAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// 
/// This attribute controls visibility for geometry with purpose "proxy".
/// 
/// Unlike overall _visibility_, _proxyVisibility_ is uniform, and
/// therefore cannot be animated.
/// 
/// Also unlike overall _visibility_, _proxyVisibility_ is tri-state, in
/// that a descendant with an opinion of "visible" overrides an ancestor
/// opinion of "invisible".
/// 
/// The _proxyVisibility_ attribute works in concert with the overall
/// _visibility_ attribute: The visibility of a prim with purpose "proxy"
/// is determined by the inherited values it receives for the _visibility_
/// and _proxyVisibility_ attributes. If _visibility_ evaluates to
/// "invisible", the prim is invisible. If _visibility_ evaluates to
/// "inherited" then: If _proxyVisibility_ evaluates to "visible", then
/// the prim is visible; if _proxyVisibility_ evaluates to "invisible",
/// then the prim is invisible; if _proxyVisibility_ evaluates to
/// "inherited", then the prim may either be visible or invisible,
/// depending on a fallback value determined by the calling context.
/// 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token proxyVisibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible, visible |
int usdGeom_VisibilityAPI_GetProxyVisibilityAttr(usdGeom_VisibilityAPI_t const* _this, usd_Attribute_t* _result);

/// See GetProxyVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_VisibilityAPI_CreateProxyVisibilityAttr(usdGeom_VisibilityAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// 
/// This attribute controls visibility for geometry with purpose
/// "render".
/// 
/// Unlike overall _visibility_, _renderVisibility_ is uniform, and
/// therefore cannot be animated.
/// 
/// Also unlike overall _visibility_, _renderVisibility_ is tri-state, in
/// that a descendant with an opinion of "visible" overrides an ancestor
/// opinion of "invisible".
/// 
/// The _renderVisibility_ attribute works in concert with the overall
/// _visibility_ attribute: The visibility of a prim with purpose "render"
/// is determined by the inherited values it receives for the _visibility_
/// and _renderVisibility_ attributes. If _visibility_ evaluates to
/// "invisible", the prim is invisible. If _visibility_ evaluates to
/// "inherited" then: If _renderVisibility_ evaluates to "visible", then
/// the prim is visible; if _renderVisibility_ evaluates to "invisible",
/// then the prim is invisible; if _renderVisibility_ evaluates to
/// "inherited", then the prim may either be visible or invisible,
/// depending on a fallback value determined by the calling context.
/// 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token renderVisibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible, visible |
int usdGeom_VisibilityAPI_GetRenderVisibilityAttr(usdGeom_VisibilityAPI_t const* _this, usd_Attribute_t* _result);

/// See GetRenderVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_VisibilityAPI_CreateRenderVisibilityAttr(usdGeom_VisibilityAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// The valid purpose tokens are "guide", "proxy", and "render" which
/// return the attributes *guideVisibility*, *proxyVisibility*, and 
/// *renderVisibility* respectively.
/// 
/// Note that while "default" is a valid purpose token for 
/// UsdGeomImageable::GetPurposeVisibilityAttr, it is not a valid purpose
/// for this function, as UsdGeomVisibilityAPI itself does not have a 
/// default visibility attribute. Calling this function with "default
/// will result in a coding error.
int usdGeom_VisibilityAPI_GetPurposeVisibilityAttr(usdGeom_VisibilityAPI_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes.  Does not include attributes that
/// may be authored by custom/extended methods of the schemas involved.
int usdGeom_VisibilityAPI_GetSchemaAttributeNames(bool includeInherited, tf_TokenVector_t const** _result);

/// Return a UsdGeomVisibilityAPI holding the prim adhering to this
/// schema at \p path on \p stage.  If no prim exists at \p path on
/// \p stage, or if the prim at that path does not adhere to this schema,
/// return an invalid schema object.  This is shorthand for the following:
/// 
/// \code
/// UsdGeomVisibilityAPI(stage->GetPrimAtPath(path));
/// \endcode
int usdGeom_VisibilityAPI_Get(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usdGeom_VisibilityAPI_t* _result);

/// Returns true if this <b>single-apply</b> API schema can be applied to 
/// the given \p prim. If this schema can not be a applied to the prim, 
/// this returns false and, if provided, populates \p whyNot with the 
/// reason it can not be applied.
/// 
/// Note that if CanApply returns false, that does not necessarily imply
/// that calling Apply will fail. Callers are expected to call CanApply
/// before calling Apply if they want to ensure that it is valid to 
/// apply a schema.
/// 
/// \sa UsdPrim::GetAppliedSchemas()
/// \sa UsdPrim::HasAPI()
/// \sa UsdPrim::CanApplyAPI()
/// \sa UsdPrim::ApplyAPI()
/// \sa UsdPrim::RemoveAPI()
int usdGeom_VisibilityAPI_CanApply(usd_Prim_t const* prim, std_String_t* whyNot, bool* _result);

/// Applies this <b>single-apply</b> API schema to the given \p prim.
/// This information is stored by adding "VisibilityAPI" to the 
/// token-valued, listOp metadata \em apiSchemas on the prim.
/// 
/// \return A valid UsdGeomVisibilityAPI object is returned upon success. 
/// An invalid (or empty) UsdGeomVisibilityAPI object is returned upon 
/// failure. See \ref UsdPrim::ApplyAPI() for conditions 
/// resulting in failure. 
/// 
/// \sa UsdPrim::GetAppliedSchemas()
/// \sa UsdPrim::HasAPI()
/// \sa UsdPrim::CanApplyAPI()
/// \sa UsdPrim::ApplyAPI()
/// \sa UsdPrim::RemoveAPI()
int usdGeom_VisibilityAPI_Apply(usd_Prim_t const* prim, usdGeom_VisibilityAPI_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_VisibilityAPI_IsConcrete(usdGeom_VisibilityAPI_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_VisibilityAPI_IsTyped(usdGeom_VisibilityAPI_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_VisibilityAPI_IsAPISchema(usdGeom_VisibilityAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_VisibilityAPI_IsAppliedAPISchema(usdGeom_VisibilityAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_VisibilityAPI_IsMultipleApplyAPISchema(usdGeom_VisibilityAPI_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_VisibilityAPI_GetSchemaKind(usdGeom_VisibilityAPI_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_VisibilityAPI_GetPrim(usdGeom_VisibilityAPI_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_VisibilityAPI_GetPath(usdGeom_VisibilityAPI_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_VisibilityAPI_GetSchemaClassPrimDefinition(usdGeom_VisibilityAPI_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_VisibilityAPI_new(usd_Prim_t const* param00, usdGeom_VisibilityAPI_t** _result);

int usdGeom_VisibilityAPI_dtor(usdGeom_VisibilityAPI_t* _this);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes.  Does not include attributes that
/// may be authored by custom/extended methods of the schemas involved.
int usdGeom_Xform_GetSchemaAttributeNames(bool includeInherited, tf_TokenVector_t const** _result);

/// Return a UsdGeomXform holding the prim adhering to this
/// schema at \p path on \p stage.  If no prim exists at \p path on
/// \p stage, or if the prim at that path does not adhere to this schema,
/// return an invalid schema object.  This is shorthand for the following:
/// 
/// \code
/// UsdGeomXform(stage->GetPrimAtPath(path));
/// \endcode
int usdGeom_Xform_Get(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usdGeom_Xform_t* _result);

/// Attempt to ensure a \a UsdPrim adhering to this schema at \p path
/// is defined (according to UsdPrim::IsDefined()) on this stage.
/// 
/// If a prim adhering to this schema at \p path is already defined on this
/// stage, return that prim.  Otherwise author an \a SdfPrimSpec with
/// \a specifier == \a SdfSpecifierDef and this schema's prim type name for
/// the prim at \p path at the current EditTarget.  Author \a SdfPrimSpec s
/// with \p specifier == \a SdfSpecifierDef and empty typeName at the
/// current EditTarget for any nonexistent, or existing but not \a Defined
/// ancestors.
/// 
/// The given \a path must be an absolute prim path that does not contain
/// any variant selections.
/// 
/// If it is impossible to author any of the necessary PrimSpecs, (for
/// example, in case \a path cannot map to the current UsdEditTarget's
/// namespace) issue an error and return an invalid \a UsdPrim.
/// 
/// Note that this method may return a defined prim whose typeName does not
/// specify this schema class, in case a stronger typeName opinion overrides
/// the opinion at the current EditTarget.
int usdGeom_Xform_Define(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usdGeom_Xform_t* _result);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Xform_GetXformOpOrderAttr(usdGeom_Xform_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Xform_AddXformOp(usdGeom_Xform_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Xform_AddTranslateOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Xform_AddScaleOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Xform_AddRotateXOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Xform_AddRotateYOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Xform_AddRotateZOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xform_AddRotateXYZOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xform_AddRotateXZYOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xform_AddRotateYXZOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xform_AddRotateYZXOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xform_AddRotateZXYOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xform_AddRotateZYXOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Xform_AddOrientOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Xform_AddTransformOp(usdGeom_Xform_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Xform_SetResetXformStack(usdGeom_Xform_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Xform_SetXformOpOrder(usdGeom_Xform_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Xform_GetOrderedXformOps(usdGeom_Xform_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Xform_ClearXformOpOrder(usdGeom_Xform_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Xform_MakeMatrixXform(usdGeom_Xform_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Xform_TransformMightBeTimeVarying(usdGeom_Xform_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Xform_TransformMightBeTimeVarying_using(usdGeom_Xform_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Xform_GetTimeSamples(usdGeom_Xform_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Xform_GetTimeSamplesInInterval(usdGeom_Xform_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Xform_GetLocalTransformation(usdGeom_Xform_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Xform_GetLocalTransformation_with_ops(usdGeom_Xform_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Xform_GetVisibilityAttr(usdGeom_Xform_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Xform_CreateVisibilityAttr(usdGeom_Xform_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Xform_GetPurposeAttr(usdGeom_Xform_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Xform_CreatePurposeAttr(usdGeom_Xform_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Xform_GetProxyPrimRel(usdGeom_Xform_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Xform_CreateProxyPrimRel(usdGeom_Xform_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Xform_MakeVisible(usdGeom_Xform_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Xform_MakeInvisible(usdGeom_Xform_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Xform_ComputeVisibility(usdGeom_Xform_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Xform_GetPurposeVisibilityAttr(usdGeom_Xform_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Xform_ComputePurposeInfo(usdGeom_Xform_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Xform_ComputePurposeInfo_given_parent(usdGeom_Xform_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Xform_ComputePurpose(usdGeom_Xform_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Xform_ComputeProxyPrim(usdGeom_Xform_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Xform_SetProxyPrim(usdGeom_Xform_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Xform_ComputeWorldBound(usdGeom_Xform_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Xform_ComputeLocalBound(usdGeom_Xform_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Xform_ComputeUntransformedBound(usdGeom_Xform_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Xform_ComputeLocalToWorldTransform(usdGeom_Xform_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Xform_ComputeParentToWorldTransform(usdGeom_Xform_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Xform_IsConcrete(usdGeom_Xform_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Xform_IsTyped(usdGeom_Xform_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Xform_IsAPISchema(usdGeom_Xform_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Xform_IsAppliedAPISchema(usdGeom_Xform_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Xform_IsMultipleApplyAPISchema(usdGeom_Xform_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Xform_GetSchemaKind(usdGeom_Xform_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Xform_GetPrim(usdGeom_Xform_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Xform_GetPath(usdGeom_Xform_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Xform_GetSchemaClassPrimDefinition(usdGeom_Xform_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Xform_new(usdGeom_Xform_t** _result);

int usdGeom_Xform_dtor(usdGeom_Xform_t* _this);

/// Compute the transformation matrix for the given \p prim, including the
/// transform authored on the Prim itself, if present.
/// 
/// \note This method may mutate internal cache state and is not thread
/// safe.
int usdGeom_XformCache_GetLocalToWorldTransform(usdGeom_XformCache_t* _this, usd_Prim_t const* prim, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for the given \p prim, but do NOT
/// include the transform authored on the prim itself.
/// 
/// \note This method may mutate internal cache state and is not thread
/// safe.
int usdGeom_XformCache_GetParentToWorldTransform(usdGeom_XformCache_t* _this, usd_Prim_t const* prim, gf_Matrix4d_t* _result);

/// Returns the local transformation of the prim. Uses the cached 
/// XformQuery to compute the result quickly. The \p resetsXformStack
/// pointer must be valid. It will be set to true if \p prim resets
/// the transform stack.
/// The result of this call is cached.
int usdGeom_XformCache_GetLocalTransformation(usdGeom_XformCache_t* _this, usd_Prim_t const* prim, bool* resetsXformStack, gf_Matrix4d_t* _result);

/// Returns the result of concatenating all transforms beneath \p ancestor
/// that affect \p prim. This includes the local transform of \p prim
/// itself, but not the local transform of \p ancestor. If \p ancestor is
/// not an ancestor of \p prim, the resulting transform is the
/// local-to-world transformation of \p prim.    
/// The \p resetXformTsack pointer must be valid. If any intermediate prims
/// reset the transform stack, \p resetXformStack will be set to true.
/// Intermediate transforms are cached, but the result of this call itself
/// is not cached.
int usdGeom_XformCache_ComputeRelativeTransform(usdGeom_XformCache_t* _this, usd_Prim_t const* prim, usd_Prim_t const* ancestor, bool* resetXformStack, gf_Matrix4d_t* _result);

/// Whether the attribute named \p attrName, belonging to the 
/// given \p prim affects the local transform value at the prim.
/// 
/// \note This method may mutate internal cache state and is not thread
/// safe.
int usdGeom_XformCache_IsAttributeIncludedInLocalTransform(usdGeom_XformCache_t* _this, usd_Prim_t const* prim, tf_Token_t const* attrName, bool* _result);

/// Whether the local transformation value at the prim may vary over time.
/// 
/// \note This method may mutate internal cache state and is not thread
/// safe.
int usdGeom_XformCache_TransformMightBeTimeVarying(usdGeom_XformCache_t* _this, usd_Prim_t const* prim, bool* _result);

/// Whether the xform stack is reset at the given prim.
/// 
/// \note This method may mutate internal cache state and is not thread
/// safe.
int usdGeom_XformCache_GetResetXformStack(usdGeom_XformCache_t* _this, usd_Prim_t const* prim, bool* _result);

/// Clears all pre-cached values.
int usdGeom_XformCache_Clear(usdGeom_XformCache_t* _this);

/// Get the current time from which this cache is reading values.
int usdGeom_XformCache_GetTime(usdGeom_XformCache_t* _this, usd_TimeCode_t* _result);

/// Use the new \p time when computing values and may clear any existing
/// values cached for the previous time. Setting \p time to the current time
/// is a no-op.
int usdGeom_XformCache_SetTime(usdGeom_XformCache_t* _this, usd_TimeCode_t time);

/// Swap the contents of this XformCache with \p other.
int usdGeom_XformCache_Swap(usdGeom_XformCache_t* _this, usdGeom_XformCache_t* other);

int usdGeom_XformCache_new(usd_TimeCode_t time, usdGeom_XformCache_t** _result);

int usdGeom_XformCache_dtor(usdGeom_XformCache_t* _this);

/// Set values for the various component xformOps at a given \p time.
/// 
/// Calling this method will call all of the supported ops to be created,
/// even if they only contain default (identity) values.
/// 
/// To author individual operations selectively, use the Set[OpType]()
/// API.
/// 
/// \note Once the rotation order has been established for a given xformable
/// (either because of an already defined (and compatible) rotate op or 
/// from calling SetXformVectors() or SetRotate()), it cannot be changed.
int usdGeom_XformCommonAPI_SetXformVectors(usdGeom_XformCommonAPI_t const* _this, gf_Vec3d_t const* translation, gf_Vec3f_t const* rotation, gf_Vec3f_t const* scale, gf_Vec3f_t const* pivot, int rotOrder, usd_TimeCode_t const time, bool* _result);

/// Returns whether the xformable resets the transform stack. 
/// i.e., does not inherit the parent transformation.
int usdGeom_XformCommonAPI_GetResetXformStack(usdGeom_XformCommonAPI_t const* _this, bool* _result);

/// Set whether the xformable resets the transform stack. 
/// i.e., does not inherit the parent transformation.
int usdGeom_XformCommonAPI_SetResetXformStack(usdGeom_XformCommonAPI_t const* _this, bool resetXformStack, bool* _result);

/// Set translation at \p time to \p translation.
int usdGeom_XformCommonAPI_SetTranslate(usdGeom_XformCommonAPI_t const* _this, gf_Vec3d_t const* translation, usd_TimeCode_t const time, bool* _result);

/// Set pivot position at \p time to \p pivot.
int usdGeom_XformCommonAPI_SetPivot(usdGeom_XformCommonAPI_t const* _this, gf_Vec3f_t const* pivot, usd_TimeCode_t const time, bool* _result);

/// Set rotation at \p time to \p rotation.
int usdGeom_XformCommonAPI_SetRotate(usdGeom_XformCommonAPI_t const* _this, gf_Vec3f_t const* rotation, int rotOrder, usd_TimeCode_t const time, bool* _result);

/// Set scale at \p time to \p scale.
int usdGeom_XformCommonAPI_SetScale(usdGeom_XformCommonAPI_t const* _this, gf_Vec3f_t const* scale, usd_TimeCode_t const time, bool* _result);

/// Creates the specified XformCommonAPI-compatible xform ops, or returns
/// the existing ops if they already exist. If successful, returns an Ops
/// object with all the ops on this prim, identified by type. If the
/// requested xform ops couldn't be created or the prim is not
/// XformCommonAPI-compatible, returns an Ops object with all invalid ops.
/// 
/// The \p rotOrder is only used if OpRotate is specified. Otherwise,
/// it is ignored. (If you don't need to create a rotate op, you might find
/// it helpful to use the other overload that takes no rotation order.)
int usdGeom_XformCommonAPI_CreateXformOps_with_rotation_order(usdGeom_XformCommonAPI_t const* _this, int rotOrder, int op1, int op2, int op3, int op4, usdGeom_XformCommonAPIOps_t* _result);

/// \overload
/// This overload does not take a rotation order. If you specify
/// OpRotate, then this overload assumes RotationOrderXYZ or the
/// previously-authored rotation order. (If you do need to create a rotate
/// op, you might find it helpful to use the other overload that explicitly
/// takes a rotation order.)
int usdGeom_XformCommonAPI_CreateXformOps(usdGeom_XformCommonAPI_t const* _this, int op1, int op2, int op3, int op4, usdGeom_XformCommonAPIOps_t* _result);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes.  Does not include attributes that
/// may be authored by custom/extended methods of the schemas involved.
int usdGeom_XformCommonAPI_GetSchemaAttributeNames(bool includeInherited, tf_TokenVector_t const** _result);

/// Return a UsdGeomXformCommonAPI holding the prim adhering to this
/// schema at \p path on \p stage.  If no prim exists at \p path on
/// \p stage, or if the prim at that path does not adhere to this schema,
/// return an invalid schema object.  This is shorthand for the following:
/// 
/// \code
/// UsdGeomXformCommonAPI(stage->GetPrimAtPath(path));
/// \endcode
int usdGeom_XformCommonAPI_Get(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usdGeom_XformCommonAPI_t* _result);

/// Converts the given \p rotOrder to the corresponding value in the
/// UsdGeomXformOp::Type enum. For example, RotationOrderYZX corresponds to
/// TypeRotateYZX. Raises a coding error if \p rotOrder is not one of the
/// named enumerators of RotationOrder.
int usdGeom_XformCommonAPI_ConvertRotationOrderToOpType(int rotOrder, int* _result);

/// Converts the given \p opType to the corresponding value in the
/// UsdGeomXformCommonAPI::RotationOrder enum. For example, TypeRotateYZX
/// corresponds to RotationOrderYZX. Raises a coding error if \p opType is
/// not convertible to RotationOrder (i.e., if it isn't a three-axis
/// rotation) and returns the default RotationOrderXYZ instead.
int usdGeom_XformCommonAPI_ConvertOpTypeToRotationOrder(int opType, int* _result);

/// Whether the given \p opType has a corresponding value in the
/// UsdGeomXformCommonAPI::RotationOrder enum (i.e., whether it is a
/// three-axis rotation).
int usdGeom_XformCommonAPI_CanConvertOpTypeToRotationOrder(int opType, bool* _result);

/// Return the 4x4 matrix that applies the rotation encoded by rotation
/// vector \p rotation using the rotation order \p rotationOrder.
/// 
/// \deprecated Please use the result of ConvertRotationOrderToOpType()
/// along with UsdGeomXformOp::GetOpTransform() instead.
int usdGeom_XformCommonAPI_GetRotationTransform(gf_Vec3f_t const* rotation, int rotationOrder, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_XformCommonAPI_IsConcrete(usdGeom_XformCommonAPI_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_XformCommonAPI_IsTyped(usdGeom_XformCommonAPI_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_XformCommonAPI_IsAPISchema(usdGeom_XformCommonAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_XformCommonAPI_IsAppliedAPISchema(usdGeom_XformCommonAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_XformCommonAPI_IsMultipleApplyAPISchema(usdGeom_XformCommonAPI_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_XformCommonAPI_GetSchemaKind(usdGeom_XformCommonAPI_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_XformCommonAPI_GetPrim(usdGeom_XformCommonAPI_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_XformCommonAPI_GetPath(usdGeom_XformCommonAPI_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_XformCommonAPI_GetSchemaClassPrimDefinition(usdGeom_XformCommonAPI_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_XformCommonAPI_new(usd_Prim_t const* param00, usdGeom_XformCommonAPI_t** _result);

int usdGeom_XformCommonAPI_dtor(usdGeom_XformCommonAPI_t* _this);

int usdGeom_XformCommonAPIOps_dtor(usdGeom_XformCommonAPIOps_t* _this);

/// Encodes the sequence of transformation operations in the
/// order in which they should be pushed onto a transform stack while
/// visiting a UsdStage's prims in a graph traversal that will effect
/// the desired positioning for this prim and its descendant prims.
/// 
/// You should rarely, if ever, need to manipulate this attribute directly.
/// It is managed by the AddXformOp(), SetResetXformStack(), and
/// SetXformOpOrder(), and consulted by GetOrderedXformOps() and
/// GetLocalTransformation().
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token[] xformOpOrder` |
/// | C++ Type | VtArray<TfToken> |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->TokenArray |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usdGeom_Xformable_GetXformOpOrderAttr(usdGeom_Xformable_t const* _this, usd_Attribute_t* _result);

/// Add an affine transformation to the local stack represented by this 
/// Xformable.  This will fail if there is already a transform operation
/// of the same name in the ordered ops on this prim (i.e. as returned
/// by GetOrderedXformOps()), or if an op of the same name exists at all
/// on the prim with a different precision than that specified.
/// 
/// The newly created operation will become the most-locally applied
/// transformation on the prim, and will appear last in the list
/// returned by GetOrderedXformOps(). It is OK to begin authoring values
/// to the returned UsdGeomXformOp immediately, interspersed with
/// subsequent calls to AddXformOp() - just note the order of application,
/// which \em can be changed at any time (and in stronger layers) via
/// SetXformOpOrder().
/// 
/// \param opType is the type of transform operation, one of 
///        \ref UsdGeomXformOp::Type.  
/// \param precision allows you to specify the precision with which you
///        desire to encode the data. This should be one of the values in 
///        the enum \ref UsdGeomXformOp::Precision .
/// \param opSuffix allows you to specify the purpose/meaning of the op in 
///        the stack. When opSuffix is specified, the associated attribute's 
///        name is set to "xformOp:<opType>:<opSuffix>".
/// \param isInverseOp is used to indicate an inverse transformation 
///        operation.
/// 
/// \return a UsdGeomXformOp that can be used to author to the operation.
///         An error is issued and the returned object will be invalid 
///         (evaluate to false) if the op being added already exists in 
///         \ref GetXformOpOrderAttr() "xformOpOrder" or if the 
///         arguments supplied are invalid.
/// 
/// \note If the attribute associated with the op already exists, but isn't 
/// of the requested precision, a coding error is issued, but a valid 
/// xformOp is returned with the existing attribute.
int usdGeom_Xformable_AddXformOp(usdGeom_Xformable_t const* _this, int opType, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a translate operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Xformable_AddTranslateOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a scale operation to the local stack represented by this 
/// xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Xformable_AddScaleOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the X-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Xformable_AddRotateXOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the YX-axis to the local stack represented by 
/// this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp()
int usdGeom_Xformable_AddRotateYOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation about the Z-axis to the local stack represented by 
/// this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Xformable_AddRotateZOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XYZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle value of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xformable_AddRotateXYZOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with XZY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xformable_AddRotateXZYOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YXZ rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xformable_AddRotateYXZOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with YZX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xformable_AddRotateYZXOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZXY rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xformable_AddRotateZXYOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a rotation op with ZYX rotation order to the local stack 
/// represented by this xformable.
/// 
/// Set the angle values of the resulting UsdGeomXformOp <b>in degrees</b>
/// \sa AddXformOp(), \ref usdGeom_rotationPackingOrder "note on angle packing order"
int usdGeom_Xformable_AddRotateZYXOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a orient op (arbitrary axis/angle rotation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
int usdGeom_Xformable_AddOrientOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Add a tranform op (4x4 matrix transformation) to the local stack 
/// represented by this xformable.
/// 
/// \sa AddXformOp()
/// 
/// Note: This method takes a precision argument only to be consistent 
/// with the other types of xformOps. The only valid precision here is 
/// double since matrix values cannot be encoded in floating-pt precision
/// in Sdf.
int usdGeom_Xformable_AddTransformOp(usdGeom_Xformable_t const* _this, int precision, tf_Token_t const* opSuffix, bool isInverseOp, usdGeom_XformOp_t* _result);

/// Specify whether this prim's transform should reset the transformation
/// stack inherited from its parent prim.  
/// 
/// By default, parent transforms are inherited. SetResetXformStack() can be 
/// called at any time during authoring, but will always add a 
/// '!resetXformStack!' op as the \em first op in the ordered list, if one 
/// does not exist already.  If one already exists, and \p resetXform is 
/// false, it will remove all ops upto and including the last 
/// "!resetXformStack!" op.
int usdGeom_Xformable_SetResetXformStack(usdGeom_Xformable_t const* _this, bool resetXform, bool* _result);

/// Reorder the already-existing transform ops on this prim.
/// 
/// All elements in \p orderedXformOps must be valid and represent attributes
/// on this prim.  Note that it is \em not required that all the existing
/// operations be present in \p orderedXformOps, so this method can be used to
/// completely change the transformation structure applied to the prim.
/// 
/// If \p resetXformStack is set to true, then "!resetXformOp! will be
/// set as the first op in xformOpOrder, to indicate that the prim does 
/// not inherit its parent's transformation.
/// 
/// \note If you wish to re-specify a prim's transformation completely in
/// a stronger layer, you should first call this method with an \em empty
/// \p orderedXformOps vector.  From there you can call AddXformOp() just as if
/// you were authoring to the prim from scratch.
/// 
/// \return false if any of the elements of \p orderedXformOps are not extant
/// on this prim, or if an error occurred while authoring the ordering 
/// metadata.  Under either condition, no scene description is authored.
/// 
/// \sa GetOrderedXformOps()
int usdGeom_Xformable_SetXformOpOrder(usdGeom_Xformable_t const* _this, usdGeom_XformOpVector_t const* orderedXformOps, bool resetXformStack, bool* _result);

/// Return the ordered list of transform operations to be applied to
/// this prim, in least-to-most-local order.  This is determined by the
/// intersection of authored op-attributes and the explicit ordering of
/// those attributes encoded in the \c xformOpOrder attribute on this prim.
/// Any entries in \c xformOpOrder that do not correspond to valid 
/// attributes on the xformable prim are skipped and a warning is issued.
/// 
/// A UsdGeomTransformable that has not had any ops added via AddXformOp()
/// will return an empty vector.
/// 
/// The function also sets \p resetsXformStack to true if "!resetXformStack!"
/// appears \em anywhere in xformOpOrder (i.e., if the prim resets its 
/// parent's inherited transformation). 
/// 
/// \note A coding error is issued if resetsXformStack is NULL. 
/// 
/// \sa GetResetXformStack()
int usdGeom_Xformable_GetOrderedXformOps(usdGeom_Xformable_t const* _this, bool* resetsXformStack, usdGeom_XformOpVector_t* _result);

/// Clears the local transform stack.
int usdGeom_Xformable_ClearXformOpOrder(usdGeom_Xformable_t const* _this, bool* _result);

/// Clears the existing local transform stack and creates a new xform op of 
/// type 'transform'. 
/// 
/// This API is provided for convenience since this is the most common 
/// xform authoring operation.
/// 
/// \sa ClearXformOpOrder()
/// \sa AddTransformOp()
int usdGeom_Xformable_MakeMatrixXform(usdGeom_Xformable_t const* _this, usdGeom_XformOp_t* _result);

/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Xformable_TransformMightBeTimeVarying(usdGeom_Xformable_t const* _this, bool* _result);

/// \overload
/// Determine whether there is any possibility that this prim's \em local
/// transformation may vary over time, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op attributes on the prim, and may become invalid in the face of
/// further authoring.
int usdGeom_Xformable_TransformMightBeTimeVarying_using(usdGeom_Xformable_t const* _this, usdGeom_XformOpVector_t const* ops, bool* _result);

/// Sets \p times to the union of all the timesamples at which xformOps that 
/// are included in the xformOpOrder attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Xformable_GetTimeSamples(usdGeom_Xformable_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Sets \p times to the union of all the timesamples in the interval, 
/// \p interval, at which xformOps that are included in the xformOpOrder
/// attribute are authored. 
/// 
/// This clears the \p times vector before accumulating sample times 
/// from all the xformOps.
/// 
/// \sa UsdAttribute::GetTimeSamples
int usdGeom_Xformable_GetTimeSamplesInInterval(usdGeom_Xformable_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Computes the fully-combined, local-to-parent transformation for this prim.
/// 
/// If a client does not need to manipulate the individual ops themselves, 
/// and requires only the combined transform on this prim, this method will 
/// take care of all the data marshalling and linear algebra needed to 
/// combine the ops into a 4x4 affine transformation matrix, in 
/// double-precision, regardless of the precision of the op inputs.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Xformable_GetLocalTransformation(usdGeom_Xformable_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usd_TimeCode_t const time, bool* _result);

/// \overload 
/// Computes the fully-combined, local-to-parent transformation for this 
/// prim as efficiently as possible, using a pre-fetched (cached) list of 
/// ordered xform ops supplied by the client.
/// 
/// \param transform is the output parameter that will hold the local 
///        transform.
/// \param resetsXformStack is the output parameter that informs client 
///        whether they need to reset the transform stack before pushing
///        \p transform.
/// \param ops is the ordered set of xform ops for this prim, and will be 
///        queried without any validity checking. Passing this in can save
///        significant value-resolution costs, if the client is able to 
///        retain this data from a call to GetOrderedXformOps().
/// \param time is the UsdTimeCode at which to sample the ops.
/// 
/// \return true on success, false if there was an error reading data.
/// 
/// \note A coding error is issued if \p transform or \p resetsXformStack 
///       is NULL. 
int usdGeom_Xformable_GetLocalTransformation_with_ops(usdGeom_Xformable_t const* _this, gf_Matrix4d_t* transform, bool* resetsXformStack, usdGeom_XformOpVector_t const* ops, usd_TimeCode_t const time, bool* _result);

/// Visibility is meant to be the simplest form of "pruning" 
/// visibility that is supported by most DCC apps.  Visibility is 
/// animatable, allowing a sub-tree of geometry to be present for some 
/// segment of a shot, and absent from others; unlike the action of 
/// deactivating geometry prims, invisible geometry is still 
/// available for inspection, for positioning, for defining volumes, etc.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `token visibility = "inherited"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref UsdGeomTokens "Allowed Values" | inherited, invisible |
int usdGeom_Xformable_GetVisibilityAttr(usdGeom_Xformable_t const* _this, usd_Attribute_t* _result);

/// See GetVisibilityAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Xformable_CreateVisibilityAttr(usdGeom_Xformable_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Purpose is a classification of geometry into categories that 
/// can each be independently included or excluded from traversals of prims 
/// on a stage, such as rendering or bounding-box computation traversals.
/// 
/// See \ref UsdGeom_ImageablePurpose for more detail about how 
/// \em purpose is computed and used.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token purpose = "default"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdGeomTokens "Allowed Values" | default, render, proxy, guide |
int usdGeom_Xformable_GetPurposeAttr(usdGeom_Xformable_t const* _this, usd_Attribute_t* _result);

/// See GetPurposeAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usdGeom_Xformable_CreatePurposeAttr(usdGeom_Xformable_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// The \em proxyPrim relationship allows us to link a
/// prim whose \em purpose is "render" to its (single target)
/// purpose="proxy" prim.  This is entirely optional, but can be
/// useful in several scenarios:
/// 
/// \li In a pipeline that does pruning (for complexity management)
/// by deactivating prims composed from asset references, when we
/// deactivate a purpose="render" prim, we will be able to discover
/// and additionally deactivate its associated purpose="proxy" prim,
/// so that preview renders reflect the pruning accurately.
/// 
/// \li DCC importers may be able to make more aggressive optimizations
/// for interactive processing and display if they can discover the proxy
/// for a given render prim.
/// 
/// \li With a little more work, a Hydra-based application will be able
/// to map a picked proxy prim back to its render geometry for selection.
/// 
/// \note It is only valid to author the proxyPrim relationship on
/// prims whose purpose is "render".
int usdGeom_Xformable_GetProxyPrimRel(usdGeom_Xformable_t const* _this, usd_Relationship_t* _result);

/// See GetProxyPrimRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usdGeom_Xformable_CreateProxyPrimRel(usdGeom_Xformable_t const* _this, usd_Relationship_t* _result);

/// Make the imageable visible if it is invisible at the given time.
/// 
/// Since visibility is pruning, this may need to override some 
/// ancestor's visibility and all-but-one of the ancestor's children's 
/// visibility, for all the ancestors of this prim up to the highest 
/// ancestor that is explicitly invisible, to preserve the visibility state.
/// 
/// If MakeVisible() (or MakeInvisible()) is going to be applied to all 
/// the prims on a stage, ancestors must be processed prior to descendants 
/// to get the correct behavior.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note This will only work properly if all ancestor prims of the 
/// imageable are <b>defined</b>, as the imageable schema is only valid on 
/// defined prims.
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeInvisible()
/// \sa ComputeVisibility()
int usdGeom_Xformable_MakeVisible(usdGeom_Xformable_t const* _this, usd_TimeCode_t const* time);

/// Makes the imageable invisible if it is visible at the given time.
/// 
/// \note When visibility is animated, this only works when it is 
/// invoked sequentially at increasing time samples. If visibility is 
/// already authored and animated in the scene, calling MakeVisible() at 
/// an arbitrary (in-between) frame isn't guaranteed to work. 
/// 
/// \note Be sure to set the edit target to the layer containing the 
/// strongest visibility opinion or to a stronger layer.
/// 
/// \sa MakeVisible()
/// \sa ComputeVisibility()
int usdGeom_Xformable_MakeInvisible(usdGeom_Xformable_t const* _this, usd_TimeCode_t const* time);

/// Calculate the effective visibility of this prim, as defined by its
/// most ancestral authored "invisible" opinion, if any.
/// 
/// A prim is considered visible at the current \p time if none of its
/// Imageable ancestors express an authored "invisible" opinion, which is
/// what leads to the "simple pruning" behavior described in 
/// GetVisibilityAttr().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage visibility
/// on a stack as you traverse.
/// 
/// \sa GetVisibilityAttr()
int usdGeom_Xformable_ComputeVisibility(usdGeom_Xformable_t const* _this, usd_TimeCode_t const* time, tf_Token_t* _result);

/// Return the attribute that is used for expressing visibility opinions
/// for the given \p purpose.
/// 
/// For "default" purpose, return the overall *visibility* attribute.
/// For "guide", "proxy", or "render" purpose, return *guideVisibility*,
/// *proxyVisibility*, or *renderVisibility* if UsdGeomVisibilityAPI is
/// applied to the prim. If UsdGeomvVisibiltyAPI is not applied, an
/// empty attribute is returned for purposes other than default.
/// 
/// \sa UsdGeomVisibilityAPI::Apply
/// \sa UsdGeomVisibilityAPI::GetPurposeVisibilityAttr
int usdGeom_Xformable_GetPurposeVisibilityAttr(usdGeom_Xformable_t const* _this, tf_Token_t const* purpose, usd_Attribute_t* _result);

/// Calculate the effective purpose information about this prim which 
/// includes final computed purpose value of the prim as well as whether
/// the purpose value should be inherited by namespace children without 
/// their own purpose opinions.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Xformable_ComputePurposeInfo(usdGeom_Xformable_t const* _this, usdGeom_ImageablePurposeInfo_t* _result);

/// \overload
/// Calculates the effective purpose information about this prim, given the
/// computed purpose information of its parent prim. This can be much more 
/// efficient than using CommputePurposeInfo() when PurposeInfo values are 
/// properly computed and cached for a hierarchy of prims using this 
/// function.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Xformable_ComputePurposeInfo_given_parent(usdGeom_Xformable_t const* _this, usdGeom_ImageablePurposeInfo_t const* parentPurposeInfo, usdGeom_ImageablePurposeInfo_t* _result);

/// Calculate the effective purpose information about this prim. This is 
/// equivalent to extracting the purpose from the value returned by
/// ComputePurposeInfo().
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to manage purpose, along
/// with visibility, on a stack as you traverse.
/// 
/// \sa GetPurposeAttr(), \ref UsdGeom_ImageablePurpose
int usdGeom_Xformable_ComputePurpose(usdGeom_Xformable_t const* _this, tf_Token_t* _result);

/// Find the prim whose purpose is \em proxy that serves as the proxy
/// for this prim, as established by the GetProxyPrimRel(), or an
/// invalid UsdPrim if this prim has no proxy.
/// 
/// This method will find the proxy for \em any prim whose computed
/// purpose (see ComputePurpose()) is \em render.  If provided and a proxy 
/// was found, we will set *renderPrim to the root of the \em render
/// subtree upon which the renderProxy relationship was authored.
/// 
/// If the renderProxy relationship has more than one target, we will
/// issue a warning and return an invalid UsdPrim.  If the targeted prim
/// does not have a resolved purpose of \em proxy, we will warn and
/// return an invalid prim.
/// 
/// This function should be considered a reference implementation for
/// correctness. <b>If called on each prim in the context of a traversal
/// we will perform massive overcomputation, because sibling prims share
/// sub-problems in the query that can be efficiently cached, but are not
/// (cannot be) by this simple implementation.</b> If you have control of
/// your traversal, it will be far more efficient to compute proxy-prims
/// on a stack as you traverse.
/// 
/// \note Currently the returned prim will not contain any instancing
/// context if it is inside a prototype - its path will be relative to the
/// prototype's root.  Once UsdPrim is instancing-aware in the core, we can
/// change this method to return a context-aware result.
/// 
/// \sa SetProxyPrim(), GetProxyPrimRel()
int usdGeom_Xformable_ComputeProxyPrim(usdGeom_Xformable_t const* _this, usd_Prim_t* renderPrim, usd_Prim_t* _result);

/// Convenience function for authoring the \em renderProxy rel on this
/// prim to target the given \p proxy prim.
/// 
/// To facilitate authoring on sparse or unloaded stages, we do not
/// perform any validation of this prim's purpose or the type or
/// purpose of the specified prim.
/// 
/// \sa ComputeProxyPrim(), GetProxyPrimRel()
int usdGeom_Xformable_SetProxyPrim(usdGeom_Xformable_t const* _this, usd_Prim_t const* proxy, bool* _result);

/// Compute the bound of this prim in world space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself, and then transformed to world space.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Xformable_ComputeWorldBound(usdGeom_Xformable_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the bound of this prim in local space, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed, including the transform (if any)
/// authored on the node itself.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Xformable_ComputeLocalBound(usdGeom_Xformable_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the untransformed bound of this prim, at the specified
/// \p time, and for the specified purposes.
/// 
/// The bound of the prim is computed in its object space, ignoring
/// any transforms authored on or above the prim.
/// 
/// It is an error to not specify any purposes, which will result in the
/// return of an empty box.
/// 
/// <b>If you need to compute bounds for multiple prims on a stage, it
/// will be much, much more efficient to instantiate a UsdGeomBBoxCache
/// and query it directly;  doing so will reuse sub-computations shared 
/// by the prims.</b>
int usdGeom_Xformable_ComputeUntransformedBound(usdGeom_Xformable_t const* _this, usd_TimeCode_t const* time, tf_Token_t const* purpose1, tf_Token_t const* purpose2, tf_Token_t const* purpose3, tf_Token_t const* purpose4, gf_BBox3d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// including the transform authored on the Prim itself, if present.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Xformable_ComputeLocalToWorldTransform(usdGeom_Xformable_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Compute the transformation matrix for this prim at the given time,
/// \em NOT including the transform authored on the prim itself.
/// 
/// <b>If you need to compute the transform for multiple prims on a
/// stage, it will be much, much more efficient to instantiate a
/// UsdGeomXformCache and query it directly; doing so will reuse
/// sub-computations shared by the prims.</b>
int usdGeom_Xformable_ComputeParentToWorldTransform(usdGeom_Xformable_t const* _this, usd_TimeCode_t const* time, gf_Matrix4d_t* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usdGeom_Xformable_IsConcrete(usdGeom_Xformable_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usdGeom_Xformable_IsTyped(usdGeom_Xformable_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usdGeom_Xformable_IsAPISchema(usdGeom_Xformable_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usdGeom_Xformable_IsAppliedAPISchema(usdGeom_Xformable_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usdGeom_Xformable_IsMultipleApplyAPISchema(usdGeom_Xformable_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usdGeom_Xformable_GetSchemaKind(usdGeom_Xformable_t const* _this, int* _result);

/// Return this schema object's held prim.
int usdGeom_Xformable_GetPrim(usdGeom_Xformable_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usdGeom_Xformable_GetPath(usdGeom_Xformable_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usdGeom_Xformable_GetSchemaClassPrimDefinition(usdGeom_Xformable_t const* _this, usd_PrimDefinition_t const** _result);

int usdGeom_Xformable_new(usdGeom_Xformable_t** _result);

int usdGeom_Xformable_dtor(usdGeom_Xformable_t* _this);

/// Return the operation type of this op, one of \ref UsdGeomXformOp::Type
int usdGeom_XformOp_GetOpType(usdGeom_XformOp_t const* _this, int* _result);

/// Returns the precision level of the xform op.
int usdGeom_XformOp_GetPrecision(usdGeom_XformOp_t const* _this, int* _result);

/// Returns whether the xformOp represents an inverse operation.
int usdGeom_XformOp_IsInverseOp(usdGeom_XformOp_t const* _this, bool* _result);

/// Returns the opName as it appears in the xformOpOrder attribute.
/// 
/// This will begin with "!invert!:xformOp:" if it is an inverse xform 
/// operation. If it is not an inverse xformOp, it will begin with 'xformOp:'.
/// 
/// This will be empty for an invalid xformOp.
int usdGeom_XformOp_GetOpName(usdGeom_XformOp_t const* _this, tf_Token_t* _result);

/// Does this op have the given suffix in its name.
int usdGeom_XformOp_HasSuffix(usdGeom_XformOp_t const* _this, tf_Token_t const* suffix, bool* _result);

/// Explicit UsdAttribute extractor
int usdGeom_XformOp_GetAttr(usdGeom_XformOp_t const* _this, usd_Attribute_t const** _result);

/// Return true if the wrapped UsdAttribute::IsDefined(), and in
/// addition the attribute is identified as a XformOp.
int usdGeom_XformOp_IsDefined(usdGeom_XformOp_t const* _this, bool* _result);

/// \sa UsdAttribute::GetName()
int usdGeom_XformOp_GetName(usdGeom_XformOp_t const* _this, tf_Token_t const** _result);

/// \sa UsdAttribute::GetBaseName()
int usdGeom_XformOp_GetBaseName(usdGeom_XformOp_t const* _this, tf_Token_t* _result);

/// \sa UsdAttribute::GetNamespace()
int usdGeom_XformOp_GetNamespace(usdGeom_XformOp_t const* _this, tf_Token_t* _result);

/// \sa UsdAttribute::SplitName()
int usdGeom_XformOp_SplitName(usdGeom_XformOp_t const* _this, std_StringVector_t* _result);

/// \sa UsdAttribute::GetTypeName()
int usdGeom_XformOp_GetTypeName(usdGeom_XformOp_t const* _this, sdf_ValueTypeName_t* _result);

/// Populates the list of time samples at which the associated attribute 
/// is authored.
int usdGeom_XformOp_GetTimeSamples(usdGeom_XformOp_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Populates the list of time samples within the given \p interval, 
/// at which the associated attribute is authored.
int usdGeom_XformOp_GetTimeSamplesInInterval(usdGeom_XformOp_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Returns the number of time samples authored for this xformOp.
int usdGeom_XformOp_GetNumTimeSamples(usdGeom_XformOp_t const* _this, size_t* _result);

/// Return the 4x4 matrix that applies the transformation encoded
/// in this op at \p time.
/// 
/// Returns the identity matrix and issues a coding error if the op is 
/// invalid. 
/// 
/// If the op is valid, but has no authored value, the identity 
/// matrix is returned and no error is issued.
int usdGeom_XformOp_GetOpTransform(usdGeom_XformOp_t const* _this, usd_TimeCode_t time, gf_Matrix4d_t* _result);

/// Determine whether there is any possibility that this op's value
/// may vary over time.
/// 
/// The determination is based on a snapshot of the authored state of the
/// op, and may become invalid in the face of further authoring.
int usdGeom_XformOp_MightBeTimeVarying(usdGeom_XformOp_t const* _this, bool* _result);

int usdGeom_XformOp_new(usd_Attribute_t const* attr, bool isInverseOp, usdGeom_XformOp_t** _result);

int usdGeom_XformOp_dtor(usdGeom_XformOp_t* _this);

int usdGeom_XformOpVector_data(usdGeom_XformOpVector_t* _this, usdGeom_XformOp_t** _result);

int usdGeom_XformOpVector_data_const(usdGeom_XformOpVector_t const* _this, usdGeom_XformOp_t const** _result);

int usdGeom_XformOpVector_empty(usdGeom_XformOpVector_t const* _this, bool* _result);

int usdGeom_XformOpVector_size(usdGeom_XformOpVector_t const* _this, size_t* _result);

int usdGeom_XformOpVector_max_size(usdGeom_XformOpVector_t const* _this, size_t* _result);

int usdGeom_XformOpVector_reserve(usdGeom_XformOpVector_t* _this, size_t const _Newcapacity);

int usdGeom_XformOpVector_capacity(usdGeom_XformOpVector_t const* _this, size_t* _result);

int usdGeom_XformOpVector_clear(usdGeom_XformOpVector_t* _this);

int usdGeom_XformOpVector_push_back(usdGeom_XformOpVector_t* _this, usdGeom_XformOp_t const* _Val);

int usdGeom_XformOpVector_pop_back(usdGeom_XformOpVector_t* _this);

int usdGeom_XformOpVector_resize(usdGeom_XformOpVector_t* _this, size_t const _Newsize);

int usdGeom_XformOpVector_resize_with(usdGeom_XformOpVector_t* _this, size_t const _Newsize, usdGeom_XformOp_t const* _Val);

int usdGeom_XformOpVector_op_index(usdGeom_XformOpVector_t const* _this, size_t const _Pos, usdGeom_XformOp_t const** _result);

int usdGeom_XformOpVector_default(usdGeom_XformOpVector_t** _result);

int usdGeom_XformOpVector_dtor(usdGeom_XformOpVector_t* _this);

/// Return the prim's full type info composed from its type name, applied
/// API schemas, and any fallback types defined on the stage for 
/// unrecognized prim type names. The returned type structure contains the 
/// "true" schema type used to create this prim's prim definition and answer
/// the IsA query. This value is cached and efficient to query. The cached
/// values are guaranteed to exist for (at least) as long as the prim's
/// stage is open.
/// \sa GetTypeName
/// \sa GetAppliedSchemas
/// \sa \ref Usd_OM_FallbackPrimTypes
int usd_Prim_GetPrimTypeInfo(usd_Prim_t const* _this, usd_PrimTypeInfo_t const** _result);

/// Return this prim's definition based on the prim's type if the type
/// is a registered prim type. Returns an empty prim definition if it is 
/// not.
int usd_Prim_GetPrimDefinition(usd_Prim_t const* _this, usd_PrimDefinition_t const** _result);

/// Return this prim's composed specifier.
int usd_Prim_GetSpecifier(usd_Prim_t const* _this, int* _result);

/// Author an opinion for this Prim's specifier at the current edit
/// target.
int usd_Prim_SetSpecifier(usd_Prim_t const* _this, int specifier, bool* _result);

/// Return all the authored SdfPrimSpecs that may contain opinions for this
/// prim in order from strong to weak.
/// 
/// This does not include all the places where contributing prim specs could
/// potentially be created; rather, it includes only those prim specs that
/// already exist.  To discover all the places that prim specs could be
/// authored that would contribute opinions, see
/// \ref "Composition Structure"
/// 
/// \note Use this method for debugging and diagnostic purposes.  It is
/// **not** advisable to retain a PrimStack for expedited metadata value
/// resolution, since not all metadata resolves with simple "strongest
/// opinion wins" semantics.
int usd_Prim_GetPrimStack(usd_Prim_t const* _this, sdf_PrimSpecHandleVector_t* _result);

/// Return all the authored SdfPrimSpecs that may contain opinions for this
/// prim in order from strong to weak paired with the cumulative layer 
/// offset from the stage's root layer to the layer containing the prim 
/// spec.
/// 
/// This behaves exactly the same as UsdPrim::GetPrimStack with the 
/// addition of providing the cumulative layer offset of each spec's layer.
/// 
/// \note Use this method for debugging and diagnostic purposes.  It is
/// **not** advisable to retain a PrimStack for expedited metadata value
/// resolution, since not all metadata resolves with simple "strongest
/// opinion wins" semantics.
int usd_Prim_GetPrimStackWithLayerOffsets(usd_Prim_t const* _this, sdf_PrimSpecHandleOffsetPairVector_t* _result);

/// Return this prim's composed type name. This value is cached and is 
/// efficient to query. 
/// Note that this is just the composed type name as authored and may not 
/// represent the full type of the prim and its prim definition. If you 
/// need to reason about the actual type of the prim, use GetPrimTypeInfo 
/// instead as it accounts for recognized schemas, applied API schemas,
/// fallback types, etc.
int usd_Prim_GetTypeName(usd_Prim_t const* _this, tf_Token_t const** _result);

/// Author this Prim's typeName at the current EditTarget.
int usd_Prim_SetTypeName(usd_Prim_t const* _this, tf_Token_t const* typeName, bool* _result);

/// Clear the opinion for this Prim's typeName at the current edit
/// target.
int usd_Prim_ClearTypeName(usd_Prim_t const* _this, bool* _result);

/// Return true if a typeName has been authored.
int usd_Prim_HasAuthoredTypeName(usd_Prim_t const* _this, bool* _result);

/// Return true if this prim is active, meaning neither it nor any of its
/// ancestors have active=false.  Return false otherwise.
/// 
/// See \ref Usd_ActiveInactive for what it means for a prim to be active.
int usd_Prim_IsActive(usd_Prim_t const* _this, bool* _result);

/// Author 'active' metadata for this prim at the current EditTarget.
/// 
/// See \ref Usd_ActiveInactive for the effects of activating or deactivating
/// a prim.
int usd_Prim_SetActive(usd_Prim_t const* _this, bool active, bool* _result);

/// Remove the authored 'active' opinion at the current EditTarget.  Do
/// nothing if there is no authored opinion.
/// 
/// See \ref Usd_ActiveInactive for the effects of activating or deactivating
/// a prim.
int usd_Prim_ClearActive(usd_Prim_t const* _this, bool* _result);

/// Return true if this prim has an authored opinion for 'active', false
/// otherwise.
/// 
/// See \ref Usd_ActiveInactive for what it means for a prim to be active.
int usd_Prim_HasAuthoredActive(usd_Prim_t const* _this, bool* _result);

/// Return true if this prim is active, and \em either it is loadable and
/// it is loaded, \em or its nearest loadable ancestor is loaded, \em or it
/// has no loadable ancestor; false otherwise.
int usd_Prim_IsLoaded(usd_Prim_t const* _this, bool* _result);

/// Return true if this prim is a model based on its kind metadata, false
/// otherwise.
int usd_Prim_IsModel(usd_Prim_t const* _this, bool* _result);

/// Return true if this prim is a model group based on its kind metadata,
/// false otherwise.  If this prim is a group, it is also necessarily a
/// model.
int usd_Prim_IsGroup(usd_Prim_t const* _this, bool* _result);

/// Return true if this prim or any of its ancestors is a class.
int usd_Prim_IsAbstract(usd_Prim_t const* _this, bool* _result);

/// Return true if this prim and all its ancestors have defining specifiers,
/// false otherwise. \sa SdfIsDefiningSpecifier.
int usd_Prim_IsDefined(usd_Prim_t const* _this, bool* _result);

/// Return the full name of this object, i.e. the last component of its
/// SdfPath in namespace.
/// 
/// This is equivalent to, but generally cheaper than,
/// GetPath().GetNameToken()
int usd_Prim_GetName(usd_Prim_t const* _this, tf_Token_t const** _result);

/// Return true if this prim has a specifier of type SdfSpecifierDef
/// or SdfSpecifierClass. \sa SdfIsDefiningSpecifier
int usd_Prim_HasDefiningSpecifier(usd_Prim_t const* _this, bool* _result);

/// Return a vector containing the names of API schemas which have
/// been applied to this prim. This includes both the authored API schemas
/// applied using the Apply() method on the particular schema class as 
/// well as any built-in API schemas that are automatically included 
/// through the prim type's prim definition.
/// To get only the authored API schemas use GetPrimTypeInfo instead.
int usd_Prim_GetAppliedSchemas(usd_Prim_t const* _this, tf_TokenVector_t* _result);

/// \overload
/// \p namespaces must be an already-concatenated ordered set of namespaces,
/// and may or may not terminate with the namespace-separator character. If
/// \p namespaces is empty, this method is equivalent to GetProperties().
int usd_Prim_GetPropertiesInNamespace(usd_Prim_t const* _this, std_String_t const* namespaces, usd_PropertyVector_t* _result);

/// \overload
/// \p namespaces must be an already-concatenated ordered set of namespaces,
/// and may or may not terminate with the namespace-separator character. If
/// \p namespaces is empty, this method is equivalent to
/// GetAuthoredProperties().
int usd_Prim_GetAuthoredPropertiesInNamespace(usd_Prim_t const* _this, std_String_t const* namespaces, usd_PropertyVector_t* _result);

/// Return the strongest propertyOrder metadata value authored on this prim.
int usd_Prim_GetPropertyOrder(usd_Prim_t const* _this, tf_TokenVector_t* _result);

/// Author an opinion for propertyOrder metadata on this prim at the current
/// EditTarget.
int usd_Prim_SetPropertyOrder(usd_Prim_t const* _this, tf_TokenVector_t const* order);

/// Remove the opinion for propertyOrder metadata on this prim at the current
/// EditTarget.
int usd_Prim_ClearPropertyOrder(usd_Prim_t const* _this);

/// Remove all scene description for the property with the
/// given \p propName <em>in the current UsdEditTarget</em>.
/// Return true if the property is removed, false otherwise.
/// 
/// Because this method can only remove opinions about the property from
/// the current EditTarget, you may generally find it more useful to use
/// UsdAttribute::Block(), which will ensure that all values from the 
/// EditTarget and weaker layers for the property will be ignored.
int usd_Prim_RemoveProperty(usd_Prim_t* _this, tf_Token_t const* propName, bool* _result);

/// Return a UsdProperty with the name \a propName. The property 
/// returned may or may not \b actually exist so it must be checked for
/// validity. Suggested use:
/// 
/// \code
/// if (UsdProperty myProp = prim.GetProperty("myProp")) {
///    // myProp is safe to use. 
///    // Edits to the owning stage requires subsequent validation.
/// } else {
///    // myProp was not defined/authored
/// }
/// \endcode
int usd_Prim_GetProperty(usd_Prim_t const* _this, tf_Token_t const* propName, usd_Property_t* _result);

/// Return true if this prim has an property named \p propName, false
/// otherwise.
int usd_Prim_HasProperty(usd_Prim_t const* _this, tf_Token_t const* propName, bool* _result);

/// Adds the applied API schema name token \p appliedSchemaName to the 
/// \em apiSchemas metadata for this prim at the current edit target. For
/// multiple-apply schemas the name token should include the instance name
/// for the applied schema, for example 'CollectionAPI:plasticStuff'.
/// 
/// The name will only be added if the \ref SdfListOp "list operation" at
/// the edit target does not already have this applied schema in its 
/// explicit, prepended, or appended lists and is always added to the end 
/// of either the prepended or explicit items.
/// 
/// Returns true upon success or if the API schema is already applied in 
/// the current edit target.
/// 
/// An error is issued and false returned for any of the following 
/// conditions:
/// \li this prim is not a valid prim for editing
/// \li this prim is valid, but cannot be reached or overridden in the 
/// current edit target
/// \li the schema name cannot be added to the apiSchemas listOp metadata
/// 
/// Unlike ApplyAPI this method does not require that the name token 
/// refer to a valid API schema type. ApplyAPI is the preferred method
/// for applying valid API schemas.
int usd_Prim_AddAppliedSchema(usd_Prim_t const* _this, tf_Token_t const* appliedSchemaName, bool* _result);

/// Removes the applied API schema name token \p appliedSchemaName from the 
/// \em apiSchemas metadata for this prim at the current edit target. For
/// multiple-apply schemas the name token should include the instance name
/// for the applied schema, for example 'CollectionAPI:plasticStuff'
/// 
/// For an explicit \ref SdfListOp "list operation", this removes the 
/// applied schema name from the explicit items list if it was present. For 
/// a non-explicit \ref SdfListOp "list operation", this will remove any 
/// occurrence of the applied schema name from the prepended and appended 
/// item as well as adding it to the deleted items list.
/// 
/// Returns true upon success or if the API schema is already deleted in 
/// the current edit target.
/// 
/// An error is issued and false returned for any of the following 
/// conditions:
/// \li this prim is not a valid prim for editing
/// \li this prim is valid, but cannot be reached or overridden in the 
/// current edit target
/// \li the schema name cannot be deleted in the apiSchemas listOp metadata
/// 
/// Unlike RemoveAPI this method does not require that the name token 
/// refer to a valid API schema type. RemoveAPI is the preferred method 
/// for removing valid API schemas.
int usd_Prim_RemoveAppliedSchema(usd_Prim_t const* _this, tf_Token_t const* appliedSchemaName, bool* _result);

/// This is an overload of \ref IsA that takes a \p schemaIdentifier to 
/// determine the schema type. 
int usd_Prim_IsA(usd_Prim_t const* _this, tf_Token_t const* schemaIdentifier, bool* _result);

/// This is an overload of \ref IsA that takes a \p schemaFamily and 
/// \p schemaVersion to determine the schema type. 
int usd_Prim_IsA_with_version(usd_Prim_t const* _this, tf_Token_t const* schemaFamily, unsigned int schemaVersion, bool* _result);

/// Return true if the prim's schema type is or inherits from the schema 
/// type of any version of the schemas in the given \p schemaFamily.
int usd_Prim_IsInFamily(usd_Prim_t const* _this, tf_Token_t const* schemaFamily, bool* _result);

/// Overload for convenience of 
/// \ref IsInFamily(const TfToken&, UsdSchemaVersion, UsdSchemaRegistry::VersionPolicy) const "IsInFamily"
/// that parses the schema family and version to use from the given 
/// \p schemaIdentifier.
/// 
/// Note that the schema identifier is not required to be a registered
/// schema as it only parsed to get what its family and version would be 
/// See UsdSchemaRegistry::ParseSchemaFamilyAndVersionFromIdentifier.
int usd_Prim_IsInFamily_with_policy(usd_Prim_t const* _this, tf_Token_t const* schemaIdentifier, int versionPolicy, bool* _result);

/// Return true if the prim's schema type, is or inherits from the schema 
/// type of any schema in the given \p schemaFamily that matches the version
/// filter provided by \p schemaVersion and \p versionPolicy.
int usd_Prim_IsInFamily_with_policy_and_version(usd_Prim_t const* _this, tf_Token_t const* schemaFamily, unsigned int schemaVersion, int versionPolicy, bool* _result);

/// Overload for convenience of 
/// \ref IsInFamily(const TfToken&, UsdSchemaVersion, UsdSchemaRegistry::VersionPolicy) const "IsInFamily"
/// that finds a registered schema for the given \p schemaType and uses that
/// schema's family and version.
int usd_Prim_IsInFamily_with_type(usd_Prim_t const* _this, tf_Type_t const* schemaType, int versionPolicy, bool* _result);

/// Return true if the prim's schema type, is or inherits from the schema 
/// type of any version the schema in the given \p schemaFamily and if so,
/// populates \p schemaVersion with the version of the schema that this 
/// prim \ref IsA.
int usd_Prim_GetVersionIfIsInFamily(usd_Prim_t const* _this, tf_Token_t const* schemaFamily, unsigned int* schemaVersion, bool* _result);

/// This is an overload of \ref HasAPI that takes a TfType \p schemaType . 
int usd_Prim_HasAPI(usd_Prim_t const* _this, tf_Type_t const* schemaType, bool* _result);

/// This is an overload of \ref HasAPI(const TfToken &) const "HasAPI" with
/// \p instanceName that takes a TfType \p schemaType . 
int usd_Prim_HasAPI_with_instance_name(usd_Prim_t const* _this, tf_Type_t const* schemaType, tf_Token_t const* instanceName, bool* _result);

/// This is an overload of \ref HasAPI that takes a \p schemaIdentifier to 
/// determine the schema type. 
int usd_Prim_HasAPI_with_schema_identifier(usd_Prim_t const* _this, tf_Token_t const* schemaIdentifier, bool* _result);

/// This is an overload of \ref HasAPI(const TfToken &) const "HasAPI" with
/// \p instanceName that takes a \p schemaIdentifier to determine the schema
/// type. 
int usd_Prim_HasAPI_with_instance_name_and_schema_identifier(usd_Prim_t const* _this, tf_Token_t const* schemaIdentifier, tf_Token_t const* instanceName, bool* _result);

/// Return true if the prim has an applied API schema that is any version of 
/// the schemas in the given \p schemaFamily.
/// 
/// This function will consider both single-apply and multiple-apply API 
/// schemas in the schema family. For the multiple-apply API schemas, this
/// will return true if any instance of one of the schemas has been applied.
int usd_Prim_HasAPIInFamily(usd_Prim_t const* _this, tf_Token_t const* schemaFamily, bool* _result);

/// Return true if the prim has a specific instance \p instanceName of an
/// applied multiple-apply API schema that is any version the schemas in
/// the given \p schemaFamily and if so, populates \p schemaVersion with the
/// version of the schema that this prim 
/// \ref HasAPI(const TfToken &) const "HasAPI".
/// 
/// \p instanceName must be non-empty, otherwise it is a coding error.
/// 
/// Note that if more than one version of the schemas in \p schemaFamily
/// is multiple-apply and applied to this prim with the given 
/// \p instanceName, the highest version number of these schemas will be 
/// populated in \p schemaVersion.
int usd_Prim_GetVersionIfHasAPIInFamily(usd_Prim_t const* _this, tf_Token_t const* schemaFamily, tf_Token_t const* instanceName, unsigned int* schemaVersion, bool* _result);

/// This is an overload of \ref CanApplyAPI that takes a TfType 
/// \p schemaType . 
int usd_Prim_CanApplyAPI(usd_Prim_t const* _this, tf_Type_t const* schemaType, std_String_t* whyNot, bool* _result);

/// This is an overload of \ref ApplyAPI that takes a TfType \p schemaType . 
int usd_Prim_ApplyAPI(usd_Prim_t const* _this, tf_Type_t const* schemaType, bool* _result);

/// This is an overload of \ref RemoveAPI that takes a TfType \p schemaType . 
int usd_Prim_RemoveAPI(usd_Prim_t const* _this, tf_Type_t const* schemaType, bool* _result);

/// Return this prim's direct child named \p name if it has one, otherwise
/// return an invalid UsdPrim.  Equivalent to:
/// \code
/// prim.GetStage()->GetPrimAtPath(prim.GetPath().AppendChild(name))
/// \endcode
int usd_Prim_GetChild(usd_Prim_t const* _this, tf_Token_t const* name, usd_Prim_t* _result);

int usd_Prim_GetChildren(usd_Prim_t const* _this, usd_PrimSiblingRange_t* _result);

int usd_Prim_GetAllChildren(usd_Prim_t const* _this, usd_PrimSiblingRange_t* _result);

int usd_Prim_GetFilteredChildren(usd_Prim_t const* _this, usd_PrimFlagsPredicate_t const* pred, usd_PrimSiblingRange_t* _result);

/// Return the names of the child prims in the order they appear when
/// iterating over GetChildren.  
int usd_Prim_GetChildrenNames(usd_Prim_t const* _this, tf_TokenVector_t* _result);

/// Return the names of the child prims in the order they appear when
/// iterating over GetFilteredChildren(\p predicate).  
int usd_Prim_GetFilteredChildrenNames(usd_Prim_t const* _this, usd_PrimFlagsPredicate_t const* predicate, tf_TokenVector_t* _result);

int usd_Prim_GetDescendants(usd_Prim_t const* _this, usd_PrimSubtreeRange_t* _result);

int usd_Prim_GetAllDescendants(usd_Prim_t const* _this, usd_PrimSubtreeRange_t* _result);

int usd_Prim_GetFilteredDescendants(usd_Prim_t const* _this, usd_PrimFlagsPredicate_t const* pred, usd_PrimSubtreeRange_t* _result);

/// Return the strongest opinion for the metadata used to reorder children 
/// of this prim. Due to how reordering of prim children is composed,
/// this value cannot be relied on to get the actual order of the prim's 
/// children. Use GetChidrenNames, GetAllChildrenNames, 
/// GetFilteredChildrenNames to get the true child order if needed.
int usd_Prim_GetChildrenReorder(usd_Prim_t const* _this, tf_TokenVector_t* _result);

/// Return this prim's parent prim.  Return an invalid UsdPrim if this is a
/// root prim.
int usd_Prim_GetParent(usd_Prim_t const* _this, usd_Prim_t* _result);

/// Return this prim's next active, loaded, defined, non-abstract sibling 
/// if it has one, otherwise return an invalid UsdPrim.  Equivalent to:
/// \code
/// GetFilteredNextSibling(UsdPrimDefaultPredicate)
/// \endcode
/// 
/// See \ref Usd_PrimFlags "Prim predicate flags" 
/// and #UsdPrimDefaultPredicate for more information.
int usd_Prim_GetNextSibling(usd_Prim_t const* _this, usd_Prim_t* _result);

/// Return this prim's next sibling that matches \p predicate if it has one,
/// otherwise return the invalid UsdPrim.
/// 
/// See \ref Usd_PrimFlags "Prim predicate flags" 
/// and #UsdPrimDefaultPredicate for more information.
int usd_Prim_GetFilteredNextSibling(usd_Prim_t const* _this, usd_PrimFlagsPredicate_t const* predicate, usd_Prim_t* _result);

/// Returns true if the prim is the pseudo root.  
/// 
/// Equivalent to 
/// \code
/// prim.GetPath() == SdfPath::AbsoluteRootPath()
/// \endcode
int usd_Prim_IsPseudoRoot(usd_Prim_t const* _this, bool* _result);

/// Returns the prim at \p path on the same stage as this prim.
/// If path is is relative, it will be anchored to the path of this prim.
/// \sa UsdStage::GetPrimAtPath(const SdfPath&) const
int usd_Prim_GetPrimAtPath(usd_Prim_t const* _this, sdf_Path_t const* path, usd_Prim_t* _result);

/// Returns the object at \p path on the same stage as this prim.
/// If path is is relative, it will be anchored to the path of this prim.
/// \sa UsdStage::GetObjectAtPath(const SdfPath&) const
int usd_Prim_GetObjectAtPath(usd_Prim_t const* _this, sdf_Path_t const* path, usd_Object_t* _result);

/// Returns the property at \p path on the same stage as this prim.
/// If path is relative, it will be anchored to the path of this prim.
/// 
/// \note There is no guarantee that this method returns a property on
/// this prim. This is only guaranteed if path is a purely relative
/// property path.
/// \sa GetProperty(const TfToken&) const
/// \sa UsdStage::GetPropertyAtPath(const SdfPath&) const
int usd_Prim_GetPropertyAtPath(usd_Prim_t const* _this, sdf_Path_t const* path, usd_Property_t* _result);

/// Returns the attribute at \p path on the same stage as this prim.
/// If path is relative, it will be anchored to the path of this prim.
/// 
/// \note There is no guarantee that this method returns an attribute on
/// this prim. This is only guaranteed if path is a purely relative
/// property path.
/// \sa GetAttribute(const TfToken&) const
/// \sa UsdStage::GetAttributeAtPath(const SdfPath&) const
int usd_Prim_GetAttributeAtPath(usd_Prim_t const* _this, sdf_Path_t const* path, usd_Attribute_t* _result);

/// Returns the relationship at \p path on the same stage as this prim.
/// If path is relative, it will be anchored to the path of this prim.
/// 
/// \note There is no guarantee that this method returns a relationship on
/// this prim. This is only guaranteed if path is a purely relative
/// property path.
/// \sa GetRelationship(const TfToken&) const
/// \sa UsdStage::GetRelationshipAtPath(const SdfPath&) const
int usd_Prim_GetRelationshipAtPath(usd_Prim_t const* _this, sdf_Path_t const* path, usd_Relationship_t* _result);

/// Return a UsdVariantSets object representing all the VariantSets
/// present on this prim.
/// 
/// The returned object also provides the API for adding new VariantSets
/// to the prim.
int usd_Prim_GetVariantSets(usd_Prim_t const* _this, usd_VariantSets_t* _result);

/// Retrieve a specifically named VariantSet for editing or constructing
/// a UsdEditTarget.
/// 
/// This is a shortcut for 
/// \code
/// prim.GetVariantSets().GetVariantSet(variantSetName)
/// \endcode
int usd_Prim_GetVariantSet(usd_Prim_t const* _this, std_String_t const* variantSetName, usd_VariantSet_t* _result);

/// Return true if this prim has any authored VariantSets.
/// 
/// \note this connotes only the *existence* of one of more VariantSets,
/// *not* that such VariantSets necessarily contain any variants or
/// variant opinions.
int usd_Prim_HasVariantSets(usd_Prim_t const* _this, bool* _result);

/// Author scene description for the attribute named \a attrName at the
/// current EditTarget if none already exists.  Return a valid attribute if
/// scene description was successfully authored or if it already existed,
/// return invalid attribute otherwise.  Note that the supplied \a typeName
/// and \a custom arguments are only used in one specific case.  See below
/// for details.
/// 
/// Suggested use:
/// \code
/// if (UsdAttribute myAttr = prim.CreateAttribute(...)) {
///    // success. 
/// }
/// \endcode
/// 
/// To call this, GetPrim() must return a valid prim.
/// 
/// - If a spec for this attribute already exists at the current edit
/// target, do nothing.
/// 
/// - If a spec for \a attrName of a different spec type (e.g. a
/// relationship) exists at the current EditTarget, issue an error.
/// 
/// - If \a name refers to a builtin attribute according to the prim's
/// definition, author an attribute spec with required metadata from the
/// definition.
/// 
/// - If \a name refers to a builtin relationship, issue an error.
/// 
/// - If there exists an absolute strongest authored attribute spec for
/// \a attrName, author an attribute spec at the current EditTarget by
/// copying required metadata from that strongest spec.
/// 
/// - If there exists an absolute strongest authored relationship spec for
/// \a attrName, issue an error.
/// 
/// - Otherwise author an attribute spec at the current EditTarget using
/// the provided \a typeName and \a custom for the required metadata fields.
/// Note that these supplied arguments are only ever used in this particular
/// circumstance, in all other cases they are ignored.
int usd_Prim_CreateAttribute(usd_Prim_t const* _this, tf_Token_t const* name, sdf_ValueTypeName_t const* typeName, bool custom, int variability, usd_Attribute_t* _result);

/// Like GetProperties(), but exclude all relationships from the result.
int usd_Prim_GetAttributes(usd_Prim_t const* _this, usd_AttributeVector_t* _result);

/// Like GetAttributes(), but exclude attributes without authored scene
/// description from the result.  See UsdProperty::IsAuthored().
int usd_Prim_GetAuthoredAttributes(usd_Prim_t const* _this, usd_AttributeVector_t* _result);

/// Return a UsdAttribute with the name \a attrName. The attribute 
/// returned may or may not \b actually exist so it must be checked for
/// validity. Suggested use:
/// 
/// \code
/// if (UsdAttribute myAttr = prim.GetAttribute("myAttr")) {
///    // myAttr is safe to use. 
///    // Edits to the owning stage requires subsequent validation.
/// } else {
///    // myAttr was not defined/authored
/// }
/// \endcode
int usd_Prim_GetAttribute(usd_Prim_t const* _this, tf_Token_t const* attrName, usd_Attribute_t* _result);

/// Return true if this prim has an attribute named \p attrName, false
/// otherwise.
int usd_Prim_HasAttribute(usd_Prim_t const* _this, tf_Token_t const* attrName, bool* _result);

/// Author scene description for the relationship named \a relName at the
/// current EditTarget if none already exists.  Return a valid relationship
/// if scene description was successfully authored or if it already existed,
/// return an invalid relationship otherwise.
/// 
/// Suggested use:
/// \code
/// if (UsdRelationship myRel = prim.CreateRelationship(...)) {
///    // success. 
/// }
/// \endcode
/// 
/// To call this, GetPrim() must return a valid prim.
/// 
/// - If a spec for this relationship already exists at the current edit
/// target, do nothing.
/// 
/// - If a spec for \a relName of a different spec type (e.g. an
/// attribute) exists at the current EditTarget, issue an error.
/// 
/// - If \a name refers to a builtin relationship according to the prim's
/// definition, author a relationship spec with required metadata from the
/// definition.
/// 
/// - If \a name refers to a builtin attribute, issue an error.
/// 
/// - If there exists an absolute strongest authored relationship spec for
/// \a relName, author a relationship spec at the current EditTarget by
/// copying required metadata from that strongest spec.
/// 
/// - If there exists an absolute strongest authored attribute spec for \a
/// relName, issue an error.
/// 
/// - Otherwise author a uniform relationship spec at the current
/// EditTarget, honoring \p custom .
int usd_Prim_CreateRelationship(usd_Prim_t const* _this, tf_Token_t const* relName, bool custom, usd_Relationship_t* _result);

/// Like GetProperties(), but exclude all attributes from the result.
int usd_Prim_GetRelationships(usd_Prim_t const* _this, usd_RelationshipVector_t* _result);

/// Like GetRelationships(), but exclude relationships without authored
/// scene description from the result.  See UsdProperty::IsAuthored().
int usd_Prim_GetAuthoredRelationships(usd_Prim_t const* _this, usd_RelationshipVector_t* _result);

/// Return a UsdRelationship with the name \a relName. The relationship
/// returned may or may not \b actually exist so it must be checked for
/// validity. Suggested use:
/// 
/// \code
/// if (UsdRelationship myRel = prim.GetRelationship("myRel")) {
///    // myRel is safe to use.
///    // Edits to the owning stage requires subsequent validation.
/// } else {
///    // myRel was not defined/authored
/// }
/// \endcode
int usd_Prim_GetRelationship(usd_Prim_t const* _this, tf_Token_t const* relName, usd_Relationship_t* _result);

/// Return true if this prim has a relationship named \p relName, false
/// otherwise.
int usd_Prim_HasRelationship(usd_Prim_t const* _this, tf_Token_t const* relName, bool* _result);

/// Return a UsdPayloads object that allows one to add, remove, or
/// mutate payloads <em>at the currently set UsdEditTarget</em>.
/// 
/// While the UsdPayloads object has no methods for \em listing the 
/// currently authored payloads on a prim, one can use a 
/// UsdPrimCompositionQuery to query the payload arcs that are composed 
/// by this prim.
int usd_Prim_GetPayloads(usd_Prim_t const* _this, usd_Payloads_t* _result);

/// Return true if this prim has any authored payloads.
int usd_Prim_HasAuthoredPayloads(usd_Prim_t const* _this, bool* _result);

/// Load this prim, all its ancestors, and by default all its descendants.
/// If \p loadPolicy is UsdLoadWithoutDescendants, then load only this prim
/// and its ancestors.
/// 
/// See UsdStage::Load for additional details.
int usd_Prim_Load(usd_Prim_t const* _this, int policy);

/// Unloads this prim and all its descendants.
/// 
/// See UsdStage::Unload for additional details.
int usd_Prim_Unload(usd_Prim_t const* _this);

/// Return a UsdReferences object that allows one to add, remove, or
/// mutate references <em>at the currently set UsdEditTarget</em>.
/// 
/// While the UsdReferences object has no methods for \em listing the 
/// currently authored references on a prim, one can use a 
/// UsdPrimCompositionQuery to query the reference arcs that are composed 
/// by this prim.
/// 
/// \sa UsdPrimCompositionQuery::GetDirectReferences
int usd_Prim_GetReferences(usd_Prim_t const* _this, usd_References_t* _result);

/// Return true if this prim has any authored references.
int usd_Prim_HasAuthoredReferences(usd_Prim_t const* _this, bool* _result);

/// Return a UsdInherits object that allows one to add, remove, or
/// mutate inherits <em>at the currently set UsdEditTarget</em>.
/// 
/// While the UsdInherits object has no methods for \em listing the 
/// currently authored inherits on a prim, one can use a 
/// UsdPrimCompositionQuery to query the inherits arcs that are composed 
/// by this prim.
/// 
/// \sa UsdPrimCompositionQuery::GetDirectInherits
int usd_Prim_GetInherits(usd_Prim_t const* _this, usd_Inherits_t* _result);

/// Return true if this prim has any authored inherits.
int usd_Prim_HasAuthoredInherits(usd_Prim_t const* _this, bool* _result);

/// Return a UsdSpecializes object that allows one to add, remove, or
/// mutate specializes <em>at the currently set UsdEditTarget</em>.
/// 
/// While the UsdSpecializes object has no methods for \em listing the 
/// currently authored specializes on a prim, one can use a 
/// UsdPrimCompositionQuery to query the specializes arcs that are composed 
/// by this prim.
int usd_Prim_GetSpecializes(usd_Prim_t const* _this, usd_Specializes_t* _result);

/// Returns true if this prim has any authored specializes.
int usd_Prim_HasAuthoredSpecializes(usd_Prim_t const* _this, bool* _result);

/// Return the cached prim index containing all sites that can contribute 
/// opinions to this prim.
/// 
/// The prim index can be used to examine the composition arcs and scene
/// description sites that can contribute to this prim's property and
/// metadata values.
/// 
/// The prim index returned by this function is optimized and may not
/// include sites that do not contribute opinions to this prim. Use 
/// UsdPrim::ComputeExpandedPrimIndex to compute a prim index that includes 
/// all possible sites that could contribute opinions.
/// 
/// This prim index will be empty for prototype prims. This ensures that
/// these prims do not provide any attribute or metadata values. For all
/// other prims in prototypes, this is the prim index that was chosen to
/// be shared with all other instances. In either case, the prim index's
/// path will not be the same as the prim's path.
/// 
/// Prim indexes may be invalidated by changes to the UsdStage and cannot
/// detect if they are expired. Clients should avoid keeping copies of the 
/// prim index across such changes, which include scene description
/// changes or changes to load state.
int usd_Prim_GetPrimIndex(usd_Prim_t const* _this, pcp_PrimIndex_t const** _result);

/// Compute the prim index containing all sites that could contribute
/// opinions to this prim.
/// 
/// This function is similar to UsdPrim::GetPrimIndex. However, the
/// returned prim index includes all sites that could possibly contribute 
/// opinions to this prim, not just the sites that currently do so. This is 
/// useful in certain situations; for example, this could be used to 
/// generate a list of sites where clients could make edits to affect this 
/// prim, or for debugging purposes.
/// 
/// For all prims in prototypes, including the prototype prim itself, this
/// is the expanded version of the prim index that was chosen to be shared
/// with all other instances. Thus, the prim index's path will not be the
/// same as the prim's path. Note that this behavior deviates slightly from
/// UsdPrim::GetPrimIndex which always returns an empty prim index for the
/// prototype prim itself.
/// 
/// This function may be relatively slow, since it will recompute the prim
/// index on every call. Clients should prefer UsdPrim::GetPrimIndex unless 
/// the additional site information is truly needed.
int usd_Prim_ComputeExpandedPrimIndex(usd_Prim_t const* _this, pcp_PrimIndex_t* _result);

/// Creates and returns a resolve target that, when passed to a 
/// UsdAttributeQuery for one of this prim's attributes, causes value 
/// resolution to only consider weaker specs up to and including the spec 
/// that would be authored for this prim when using the given \p editTarget.
/// 
/// If the edit target would not affect any specs that could contribute to
/// this prim, a null resolve target is returned.
int usd_Prim_MakeResolveTargetUpToEditTarget(usd_Prim_t const* _this, usd_EditTarget_t const* editTarget, usd_ResolveTarget_t* _result);

/// Creates and returns a resolve target that, when passed to a 
/// UsdAttributeQuery for one of this prim's attributes, causes value 
/// resolution to only consider specs that are stronger than the spec 
/// that would be authored for this prim when using the given \p editTarget.
/// 
/// If the edit target would not affect any specs that could contribute to
/// this prim, a null resolve target is returned.
int usd_Prim_MakeResolveTargetStrongerThanEditTarget(usd_Prim_t const* _this, usd_EditTarget_t const* editTarget, usd_ResolveTarget_t* _result);

int usd_Prim_new(usd_Prim_t** _result);

int usd_Prim_dtor(usd_Prim_t* _this);

/// Change the filter for this query.
int usd_PrimCompositionQuery_SetFilter(usd_PrimCompositionQuery_t* _this, usd_PrimCompositionQueryFilter_t const* filter);

/// Return a copy of the current filter parameters.
int usd_PrimCompositionQuery_GetFilter(usd_PrimCompositionQuery_t const* _this, usd_PrimCompositionQueryFilter_t* _result);

/// Return a list of composition arcs for this query's prim using the 
/// current query filter. The composition arcs are always returned in order
/// from strongest to weakest regardless of the filter.
int usd_PrimCompositionQuery_GetCompositionArcs(usd_PrimCompositionQuery_t* _this, usd_PrimCompositionQueryArcVector_t* _result);

/// Returns a prim composition query for the given \p prim with a preset 
/// filter that only returns inherit arcs that are not ancestral.
int usd_PrimCompositionQuery_GetDirectInherits(usd_Prim_t const* prim, usd_PrimCompositionQuery_t* _result);

/// Returns a prim composition query for the given \p prim with a preset 
/// filter that only returns reference arcs that are not ancestral.
int usd_PrimCompositionQuery_GetDirectReferences(usd_Prim_t const* prim, usd_PrimCompositionQuery_t* _result);

/// Returns a prim composition query for the given \p prim with a preset 
/// filter that only returns direct arcs that were introduced by opinions 
/// defined in a layer in the root layer stack.
int usd_PrimCompositionQuery_GetDirectRootLayerArcs(usd_Prim_t const* prim, usd_PrimCompositionQuery_t* _result);

int usd_PrimCompositionQuery_ctor(usd_Prim_t const* prim, usd_PrimCompositionQueryFilter_t const* filter, usd_PrimCompositionQuery_t** _result);

int usd_PrimCompositionQuery_dtor(usd_PrimCompositionQuery_t* _this);

/// Returns the targeted node of this composition arc.
int usd_PrimCompositionQueryArc_GetTargetNode(usd_PrimCompositionQueryArc_t const* _this, pcp_NodeRef_t* _result);

/// Returns the node that introduces this arc into composition graph. This
/// is the node where the authored composition opinion exists and is not
/// necessarily the target node's parent. If this arc is the 
/// \ref UsdQueryRootArc "root arc" then this function returns the same
/// node as GetTargetNode which is the root node of the composition graph.
int usd_PrimCompositionQueryArc_GetIntroducingNode(usd_PrimCompositionQueryArc_t const* _this, pcp_NodeRef_t* _result);

/// Returns the root layer of the layer stack that holds the prim spec 
/// targeted by this composition arc.
int usd_PrimCompositionQueryArc_GetTargetLayer(usd_PrimCompositionQueryArc_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the path of the prim spec that is targeted by this composition
/// arc in the target layer stack.
int usd_PrimCompositionQueryArc_GetTargetPrimPath(usd_PrimCompositionQueryArc_t const* _this, sdf_Path_t* _result);

/// Creates and returns a resolve target that, when passed to a 
/// UsdAttributeQuery for one of this prim's attributes, causes value 
/// resolution to only consider node sites weaker than this arc, up to and
/// and including this arc's site itself.
/// 
/// If \p subLayer is provided, it must be a layer in this arc's layer stack
/// and it will further limit value resolution to only the weaker layers up
/// to and including \p subLayer within this layer stack. (This is only with 
/// respect to this arc; all layers will still be considered in the arcs 
/// weaker than this arc).
int usd_PrimCompositionQueryArc_MakeResolveTargetUpTo(usd_PrimCompositionQueryArc_t const* _this, sdf_LayerHandle_t const* subLayer, usd_ResolveTarget_t* _result);

/// Creates and returns a resolve target that, when passed to a 
/// UsdAttributeQuery for one of this prim's attributes, causes value 
/// resolution to only consider node sites stronger than this arc, not 
/// including this arc itself (unless \p subLayer is provided).
/// 
/// If \p subLayer is provided, it must be a layer in this arc's layer stack
/// and it will cause value resolution to additionally consider layers in 
/// this arc but only if they are stronger than subLayer within this arc's 
/// layer stack.
int usd_PrimCompositionQueryArc_MakeResolveTargetStrongerThan(usd_PrimCompositionQueryArc_t const* _this, sdf_LayerHandle_t const* subLayer, usd_ResolveTarget_t* _result);

/// Returns the specific layer in the layer stack that adds this arc to the
/// composition graph. This layer combined with the path returned from 
/// GetIntroducingPrimPath can be used to find the prim spec which owns
/// the field that ultimately causes this arc to exist. If this arc is 
/// the \ref UsdQueryRootArc "root arc" of the composition graph, it is not
/// an authored composition arc and this returns a null layer handle.
int usd_PrimCompositionQueryArc_GetIntroducingLayer(usd_PrimCompositionQueryArc_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the path of the prim that introduces this arc to the composition 
/// graph within the layer in which the composition opinion is authored. 
/// This path combined with the layer returned from  GetIntroducingLayer
/// can be used to find the prim spec which owns the field that ultimately 
/// causes this arc to exist. If this arc is the 
/// \ref UsdQueryRootArc "root arc" of the composition graph, it is not an 
/// authored composition arc and this returns an empty path.
int usd_PrimCompositionQueryArc_GetIntroducingPrimPath(usd_PrimCompositionQueryArc_t const* _this, sdf_Path_t* _result);

/// Gets the list editor and authored SdfReference value that introduces
/// this arc to the composition graph for reference arcs. If this arc's
/// type is reference, \p editor will be set to the reference list editor
/// of the introducing prim spec and \p ref will be set to the authored 
/// value of the SdfReference in the reference list.
/// 
/// This returns true if the \ref GetArcType "arc type" is 
/// \ref PcpArcType "reference" and there are no errors; it returns false 
/// for all other arc types.
int usd_PrimCompositionQueryArc_GetIntroducingListEditor_reference(usd_PrimCompositionQueryArc_t const* _this, sdf_ReferenceEditorProxy_t* editor, sdf_Reference_t* ref, bool* _result);

/// Gets the list editor and authored SdfPayload value that introduces
/// this arc to the composition graph for payload arcs. If this arc's
/// type is payload, \p editor will be set to the payload list editor
/// of the introducing prim spec and \p payload will be set to the authored 
/// value of the SdfPayload in the payload list.
/// 
/// This returns true if the \ref GetArcType "arc type" is 
/// \ref PcpArcType "payload" and there are no errors; it returns false 
/// for all other arc types.
int usd_PrimCompositionQueryArc_GetIntroducingListEditor_payload(usd_PrimCompositionQueryArc_t const* _this, sdf_PayloadEditorProxy_t* editor, sdf_Payload_t* payload, bool* _result);

/// Gets the list editor and authored SdfPath value that introduced
/// this arc to the composition graph for class arcs. If this arc's
/// type is inherit or specialize, \p editor will be set to the 
/// corresponding path list editor of the introducing prim spec and \p path
/// will be set to the authored value of the SdfPath in the path list.
/// 
/// This returns true if the \ref GetArcType "arc type" is either 
/// \ref PcpArcType "inherit" or \ref PcpArcType "specialize" and 
/// there are no errors; it returns false for all other arc types.
int usd_PrimCompositionQueryArc_GetIntroducingListEditor_path(usd_PrimCompositionQueryArc_t const* _this, sdf_InheritsProxy_t* editor, sdf_Path_t* path, bool* _result);

/// Gets the list editor and authored string value that introduces
/// this arc to the composition graph for variant arcs. If this arc's
/// type is variant, \p editor will be set to the name list editor
/// of the introducing prim spec and \p name will be set to the authored 
/// value of the variant set name in the name list.
/// 
/// This returns true if the \ref GetArcType "arc type" is 
/// \ref PcpArcType "variant" and there are no errors; it returns false 
/// for all other arc types.
int usd_PrimCompositionQueryArc_GetIntroducingListEditor_name(usd_PrimCompositionQueryArc_t const* _this, sdf_NameEditorProxy_t* editor, std_String_t* name, bool* _result);

/// Returns the arc type.
int usd_PrimCompositionQueryArc_GetArcType(usd_PrimCompositionQueryArc_t const* _this, int* _result);

/// Returns whether this arc was implicitly added to this prim meaning it
/// exists because of the introduction of another composition arc. These 
/// will typically exist due to inherits or specializes that are authored 
/// across a reference.
int usd_PrimCompositionQueryArc_IsImplicit(usd_PrimCompositionQueryArc_t const* _this, bool* _result);

/// Returns whether this arc is ancestral, i.e. it exists because it was 
/// composed in by a namespace parent's prim index. 
int usd_PrimCompositionQueryArc_IsAncestral(usd_PrimCompositionQueryArc_t const* _this, bool* _result);

/// Returns whether the target node of this arc contributes any local spec 
/// opinions that are composed for the prim.
int usd_PrimCompositionQueryArc_HasSpecs(usd_PrimCompositionQueryArc_t const* _this, bool* _result);

/// Returns whether the composition opinion that introduces this arc 
/// is authored in the root layer stack. This returns true for any arcs 
/// where the composition opinion can be authored in the root layer stack.
/// This is always true for the root arc.
int usd_PrimCompositionQueryArc_IsIntroducedInRootLayerStack(usd_PrimCompositionQueryArc_t const* _this, bool* _result);

/// Returns whether the composition opinion that introduces this arc is 
/// authored directly on the prim's prim spec within the root layer stack.
/// This is always true for the root arc.
int usd_PrimCompositionQueryArc_IsIntroducedInRootLayerPrimSpec(usd_PrimCompositionQueryArc_t const* _this, bool* _result);

int usd_PrimCompositionQueryArc_dtor(usd_PrimCompositionQueryArc_t* _this);

int usd_PrimCompositionQueryArcVector_dtor(usd_PrimCompositionQueryArcVector_t* _this);

/// Return the list of names of builtin properties for this prim definition.
int usd_PrimDefinition_GetPropertyNames(usd_PrimDefinition_t const* _this, tf_TokenVector_t const** _result);

/// Return the list of names of the API schemas that have been applied to
/// this prim definition in order.
int usd_PrimDefinition_GetAppliedAPISchemas(usd_PrimDefinition_t const* _this, tf_TokenVector_t const** _result);

/// Return the SdfSpecType for \p propName if it is a builtin property of
/// the prim type represented by this prim definition. Otherwise return 
/// SdfSpecTypeUnknown.
int usd_PrimDefinition_GetSpecType(usd_PrimDefinition_t const* _this, tf_Token_t const* propName, int* _result);

/// \deprecated Use GetPropertyDefinition instead.
/// 
/// Return the property spec that defines the fallback for the property
/// named \a propName on prims of this prim definition's type. Return null 
/// if there is no such property spec.
int usd_PrimDefinition_GetSchemaPropertySpec(usd_PrimDefinition_t const* _this, tf_Token_t const* propName, sdf_PropertySpecHandle_t* _result);

/// \deprecated Use GetAttributeDefinition instead.
/// 
/// This is a convenience method. It is shorthand for
/// TfDynamic_cast<SdfAttributeSpecHandle>(
///     GetSchemaPropertySpec(primType, attrName));
int usd_PrimDefinition_GetSchemaAttributeSpec(usd_PrimDefinition_t const* _this, tf_Token_t const* attrName, sdf_AttributeSpecHandle_t* _result);

/// \deprecated Use GetRelationshipDefinition instead.
/// 
/// This is a convenience method. It is shorthand for
/// TfDynamic_cast<SdfRelationshipSpecHandle>(
///     GetSchemaPropertySpec(primType, relName));
int usd_PrimDefinition_GetSchemaRelationshipSpec(usd_PrimDefinition_t const* _this, tf_Token_t const* relName, sdf_RelationshipSpecHandle_t* _result);

/// Returns the list of names of metadata fields that are defined by this 
/// prim definition for the prim itself.
int usd_PrimDefinition_ListMetadataFields(usd_PrimDefinition_t const* _this, tf_TokenVector_t* _result);

/// Returns the documentation metadata defined by the prim definition for 
/// the prim itself.
int usd_PrimDefinition_GetDocumentation(usd_PrimDefinition_t const* _this, std_String_t* _result);

/// Returns the list of names of metadata fields that are defined by this 
/// prim definition for property \p propName if a property named \p propName
/// exists.
int usd_PrimDefinition_ListPropertyMetadataFields(usd_PrimDefinition_t const* _this, tf_Token_t const* propName, tf_TokenVector_t* _result);

/// Returns the documentation metadata defined by the prim definition for 
/// the property named \p propName if it exists.
int usd_PrimDefinition_GetPropertyDocumentation(usd_PrimDefinition_t const* _this, tf_Token_t const* propName, std_String_t* _result);

/// Copies the contents of this prim definition to a prim spec on the 
/// given \p layer at the given \p path. This includes the entire property
/// spec for each of this definition's built-in properties as well as all of
/// this definition's prim metadata. 
/// 
/// If the prim definition represents a concrete prim type, the type name 
/// of the prim spec is set to the the type name of this prim definition. 
/// Otherwise the type name is set to empty. The 'apiSchemas' metadata
/// on the prim spec will always be explicitly set to the combined list 
/// of all API schemas applied to this prim definition, i.e. the list 
/// returned by UsdPrimDefinition::GetAppliedAPISchemas. Note that if this 
/// prim definition is an API schema prim definition 
/// (see UsdSchemaRegistry::FindAppliedAPIPrimDefinition) then 'apiSchemas'
/// will be empty as this prim definition does not "have" an applied API 
/// because instead it "is" an applied API.
/// 
/// If there is no prim spec at the given \p path, a new prim spec is 
/// created at that path with the specifier \p newSpecSpecifier. Any 
/// necessary ancestor specs will be created as well but they will always 
/// be created as overs. If a spec does exist at \p path, then all of its 
/// properties and 
/// \ref UsdSchemaRegistry::IsDisallowedField "schema allowed metadata" are 
/// cleared before it is populated from the prim definition.
int usd_PrimDefinition_FlattenTo(usd_PrimDefinition_t const* _this, sdf_LayerHandle_t const* layer, sdf_Path_t const* path, int newSpecSpecifier, bool* _result);

/// \overload
/// Copies the contents of this prim definition to a prim spec at the 
/// current edit target for a prim with the given \p name under the prim 
/// \p parent.
int usd_PrimDefinition_FlattenTo_prim_under_parent(usd_PrimDefinition_t const* _this, usd_Prim_t const* parent, tf_Token_t const* name, int newSpecSpecifier, usd_Prim_t* _result);

/// \overload
/// Copies the contents of this prim definition to a prim spec at the 
/// current edit target for the given \p prim.
int usd_PrimDefinition_FlattenTo_prim(usd_PrimDefinition_t const* _this, usd_Prim_t const* prim, int newSpecSpecifier, usd_Prim_t* _result);

int usd_PrimDefinition_dtor(usd_PrimDefinition_t* _this);

int usd_PrimFlagsPredicate_dtor(usd_PrimFlagsPredicate_t* _this);

/// Return an iterator to the start of this range.
int usd_PrimRange_begin(usd_PrimRange_t const* _this, usd_PrimRangeIterator_t* _result);

/// Return the past-the-end iterator for this range.
int usd_PrimRange_end(usd_PrimRange_t const* _this, usd_PrimRangeIterator_t* _result);

int usd_PrimRange_from_prim(usd_Prim_t* start, usd_PrimRange_t** _result);

int usd_PrimRange_dtor(usd_PrimRange_t* _this);

int usd_PrimRangeIterator_op_inc(usd_PrimRangeIterator_t* _this, usd_PrimRangeIterator_t** _result);

int usd_PrimRangeIterator_op_assign(usd_PrimRangeIterator_t* _this, usd_PrimRangeIterator_t const* param00, usd_PrimRangeIterator_t** _result);

/// Return true if this iterator is equivalent to \p other.
int usd_PrimRangeIterator_op_eq(usd_PrimRangeIterator_t const* _this, usd_PrimRangeIterator_t const* other, bool* _result);

int usd_PrimRangeIterator_deref(usd_PrimRangeIterator_t const* _this, usd_Prim_t* _result);

int usd_PrimRangeIterator_new(usd_PrimRangeIterator_t** _result);

int usd_PrimRangeIterator_dtor(usd_PrimRangeIterator_t* _this);

int usd_PrimSiblingRange_begin(usd_PrimSiblingRange_t const* _this, usd_PrimSiblingIterator_t* _result);

int usd_PrimSiblingRange_end(usd_PrimSiblingRange_t const* _this, usd_PrimSiblingIterator_t* _result);

int usd_PrimSiblingRange_dtor(usd_PrimSiblingRange_t* _this);

int usd_PrimSiblingIterator_deref(usd_PrimSiblingIterator_t const* _this, usd_Prim_t* _result);

int usd_PrimSiblingIterator_op_inc(usd_PrimSiblingIterator_t* _this, usd_PrimSiblingIterator_t** _result);

int usd_PrimSiblingIterator_dtor(usd_PrimSiblingIterator_t* _this);

int usd_PrimSubtreeRange_dtor(usd_PrimSubtreeRange_t* _this);

/// Returns the concrete prim type name.
int usd_PrimTypeInfo_GetTypeName(usd_PrimTypeInfo_t const* _this, tf_Token_t const** _result);

/// Returns the list of applied API schemas, directly authored on the prim,
/// that impart additional properties on its prim definition. This does NOT
/// include the applied API schemas that may be defined in the conrete prim
/// type's prim definition..
int usd_PrimTypeInfo_GetAppliedAPISchemas(usd_PrimTypeInfo_t const* _this, tf_TokenVector_t const** _result);

/// Returns the TfType of the actual concrete schema that prims of this 
/// type will use to create their prim definition. Typically, this will
/// be the type registered in the schema registry for the concrete prim type
/// returned by GetTypeName. But if the stage provided this type info with
/// a fallback type because the prim type name is not a recognized schema, 
/// this will return the provided fallback schema type instead.
/// 
/// \sa \ref Usd_OM_FallbackPrimTypes
int usd_PrimTypeInfo_GetSchemaType(usd_PrimTypeInfo_t const* _this, tf_Type_t const** _result);

/// Returns the type name associated with the schema type returned from 
/// GetSchemaType. This will always be equivalent to calling 
/// UsdSchemaRegistry::GetConcreteSchemaTypeName on the type returned by 
/// GetSchemaType and will typically be the same as GetTypeName as long as
/// the prim type name is a recognized prim type.
/// 
/// \sa \ref Usd_OM_FallbackPrimTypes
int usd_PrimTypeInfo_GetSchemaTypeName(usd_PrimTypeInfo_t const* _this, tf_Token_t const** _result);

/// Returns the prim definition associated with this prim type's schema 
/// type and applied API schemas.
int usd_PrimTypeInfo_GetPrimDefinition(usd_PrimTypeInfo_t const* _this, usd_PrimDefinition_t const** _result);

/// Returns the empty prim type info.
int usd_PrimTypeInfo_GetEmptyPrimType(usd_PrimTypeInfo_t const** _result);

int usd_PrimTypeInfo_dtor(usd_PrimTypeInfo_t* _this);

int usd_PrimVector_data(usd_PrimVector_t* _this, usd_Prim_t** _result);

int usd_PrimVector_data_const(usd_PrimVector_t const* _this, usd_Prim_t const** _result);

int usd_PrimVector_empty(usd_PrimVector_t const* _this, bool* _result);

int usd_PrimVector_size(usd_PrimVector_t const* _this, size_t* _result);

int usd_PrimVector_max_size(usd_PrimVector_t const* _this, size_t* _result);

int usd_PrimVector_reserve(usd_PrimVector_t* _this, size_t const _Newcapacity);

int usd_PrimVector_capacity(usd_PrimVector_t const* _this, size_t* _result);

int usd_PrimVector_clear(usd_PrimVector_t* _this);

int usd_PrimVector_push_back(usd_PrimVector_t* _this, usd_Prim_t const* _Val);

int usd_PrimVector_pop_back(usd_PrimVector_t* _this);

int usd_PrimVector_resize(usd_PrimVector_t* _this, size_t const _Newsize);

int usd_PrimVector_resize_with(usd_PrimVector_t* _this, size_t const _Newsize, usd_Prim_t const* _Val);

int usd_PrimVector_op_index(usd_PrimVector_t const* _this, size_t const _Pos, usd_Prim_t const** _result);

int usd_PrimVector_default(usd_PrimVector_t** _result);

int usd_PrimVector_dtor(usd_PrimVector_t* _this);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usd_ClipsAPI_IsConcrete(usd_ClipsAPI_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usd_ClipsAPI_IsTyped(usd_ClipsAPI_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usd_ClipsAPI_IsAPISchema(usd_ClipsAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usd_ClipsAPI_IsAppliedAPISchema(usd_ClipsAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usd_ClipsAPI_IsMultipleApplyAPISchema(usd_ClipsAPI_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usd_ClipsAPI_GetSchemaKind(usd_ClipsAPI_t const* _this, int* _result);

/// Return this schema object's held prim.
int usd_ClipsAPI_GetPrim(usd_ClipsAPI_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usd_ClipsAPI_GetPath(usd_ClipsAPI_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usd_ClipsAPI_GetSchemaClassPrimDefinition(usd_ClipsAPI_t const* _this, usd_PrimDefinition_t const** _result);

/// Return a UsdClipsAPI holding the prim adhering to this
/// schema at \p path on \p stage.  If no prim exists at \p path on
/// \p stage, or if the prim at that path does not adhere to this schema,
/// return an invalid schema object.  This is shorthand for the following:
/// 
/// \code
/// UsdClipsAPI(stage->GetPrimAtPath(path));
/// \endcode
int usd_ClipsAPI_Get(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usd_ClipsAPI_t* _result);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes.  Does not include attributes that
/// may be authored by custom/extended methods of the schemas involved.
int usd_ClipsAPI_GetSchemaAttributeNames(bool includeInherited, tf_TokenVector_t const** _result);

/// Dictionary that contains the definition of the clip sets on this prim.
/// 
/// Each entry in this dictionary defines a clip set: the entry's key
/// is the name of the clip set and the entry's value is a dictionary
/// containing the metadata that specifies the clips in the set.
/// 
/// See \ref UsdClipsAPIInfoKeys for the keys used for each clip set's
/// dictionary, or use the other API to set or get values for a given
/// clip set.
int usd_ClipsAPI_GetClips(usd_ClipsAPI_t const* _this, vt_Dictionary_t* clips, bool* _result);

/// Set the clips dictionary for this prim.
/// \sa GetClips
int usd_ClipsAPI_SetClips(usd_ClipsAPI_t* _this, vt_Dictionary_t const* clips, bool* _result);

/// ListOp that may be used to affect how opinions from clip 
/// sets are applied during value resolution.
/// 
/// By default, clip sets in a layer stack are examined in 
/// lexicographical order by name for attribute values during value 
/// resolution. The clip sets listOp can be used to reorder the clip 
/// sets in a layer stack or remove them entirely from consideration
/// during value resolution without modifying the clips dictionary.
/// 
/// This is *not* the list of clip sets that are authored on this prim.
/// To retrieve that information, use GetClips to examine the clips 
/// dictionary directly.
/// 
/// This function returns the clip sets listOp from the current edit
/// target.
int usd_ClipsAPI_GetClipSets(usd_ClipsAPI_t const* _this, sdf_StringListOp_t* clipSets, bool* _result);

/// Set the clip sets list op for this prim.
/// \sa GetClipSets
int usd_ClipsAPI_SetClipSets(usd_ClipsAPI_t* _this, sdf_StringListOp_t const* clipSets, bool* _result);

/// Computes and resolves the list of clip asset paths used by the
/// clip set named \p clipSet. This is the same list of paths that
/// would be used during value resolution.
/// 
/// If the clip set is defined using template clip metadata, this
/// function will compute the asset paths based on the template
/// parameters. Otherwise this function will use the authored
/// clipAssetPaths.
int usd_ClipsAPI_ComputeClipAssetPaths_on_clip_set(usd_ClipsAPI_t const* _this, std_String_t const* clipSet, sdf_AssetPathArray_t* _result);

/// \overload
/// This function operates on the default clip set.
int usd_ClipsAPI_ComputeClipAssetPaths(usd_ClipsAPI_t const* _this, sdf_AssetPathArray_t* _result);

/// List of asset paths to the clips in the clip set named \p clipSet.
/// This list is unordered, but elements in this list are referred to 
/// by index in other clip-related fields.
int usd_ClipsAPI_GetClipAssetPaths_from_clip_set(usd_ClipsAPI_t const* _this, sdf_AssetPathArray_t* assetPaths, std_String_t const* clipSet, bool* _result);

/// \overload
/// This function operates on the default clip set. 
/// \sa \ref UsdClipsAPISetNames
int usd_ClipsAPI_GetClipAssetPaths(usd_ClipsAPI_t const* _this, sdf_AssetPathArray_t* assetPaths, bool* _result);

/// Set the clip asset paths for the clip set named \p clipSet
/// \sa GetClipAssetPaths()
int usd_ClipsAPI_SetClipAssetPaths_on_clip_set(usd_ClipsAPI_t* _this, sdf_AssetPathArray_t const* assetPaths, std_String_t const* clipSet, bool* _result);

/// \overload
/// This function operates on the default clip set. 
/// \sa \ref UsdClipsAPISetNames
int usd_ClipsAPI_SetClipAssetPaths(usd_ClipsAPI_t* _this, sdf_AssetPathArray_t const* assetPaths, bool* _result);

/// Path to the prim in the clips in the clip set named \p clipSet
/// from which time samples will be read.
/// 
/// This prim's path will be substituted with this value to determine
/// the final path in the clip from which to read data. For instance,
/// if this prims' path is '/Prim_1', the clip prim path is '/Prim', 
/// and we want to get values for the attribute '/Prim_1.size'. The
/// clip prim path will be substituted in, yielding '/Prim.size', and
/// each clip will be examined for values at that path.
int usd_ClipsAPI_GetClipPrimPath_from_clip_set(usd_ClipsAPI_t const* _this, std_String_t* primPath, std_String_t const* clipSet, bool* _result);

/// \overload
/// This function operates on the default clip set. 
/// \sa \ref UsdClipsAPISetNames
int usd_ClipsAPI_GetClipPrimPath(usd_ClipsAPI_t const* _this, std_String_t* primPath, bool* _result);

/// Set the clip prim path for the clip set named \p clipSet.
/// \sa GetClipPrimPath()
int usd_ClipsAPI_SetClipPrimPath_from_clip_set(usd_ClipsAPI_t* _this, std_String_t const* primPath, std_String_t const* clipSet, bool* _result);

/// \overload
/// This function operates on the default clip set. 
/// \sa \ref UsdClipsAPISetNames
int usd_ClipsAPI_SetClipPrimPath(usd_ClipsAPI_t* _this, std_String_t const* primPath, bool* _result);

int usd_ClipsAPI_on_schema_obj(usd_Prim_t const* param00, usd_ClipsAPI_t** _result);

int usd_ClipsAPI_on_prim(usd_Prim_t const* param00, usd_ClipsAPI_t** _result);

int usd_ClipsAPI_dtor(usd_ClipsAPI_t* _this);

/// Returns the name of this multiple-apply schema instance
int usd_CollectionAPI_GetName(usd_CollectionAPI_t const* _this, tf_Token_t* _result);

/// Specifies how the paths that are included in
/// the collection must be expanded to determine its members.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform token expansionRule = "expandPrims"` |
/// | C++ Type | TfToken |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Token |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
/// | \ref UsdTokens "Allowed Values" | explicitOnly, expandPrims, expandPrimsAndProperties |
int usd_CollectionAPI_GetExpansionRuleAttr(usd_CollectionAPI_t const* _this, usd_Attribute_t* _result);

/// See GetExpansionRuleAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usd_CollectionAPI_CreateExpansionRuleAttr(usd_CollectionAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Boolean attribute indicating whether the pseudo-root
/// path &lt;/&gt; should be counted as one of the included target
/// paths.  The fallback is false.  This separate attribute is
/// required because relationships cannot directly target the root.
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform bool includeRoot` |
/// | C++ Type | bool |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Bool |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usd_CollectionAPI_GetIncludeRootAttr(usd_CollectionAPI_t const* _this, usd_Attribute_t* _result);

/// See GetIncludeRootAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usd_CollectionAPI_CreateIncludeRootAttr(usd_CollectionAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// This property represents the collection for the purpose of 
/// allowing another collection to include it. When this property is 
/// targeted by another collection's <i>includes</i> relationship, the rules
/// of this collection will be inserted into the rules of the collection
/// that includes it.
/// 
/// 
/// | ||
/// | -- | -- |
/// | Declaration | `uniform opaque __INSTANCE_NAME__` |
/// | C++ Type | SdfOpaqueValue |
/// | \ref Usd_Datatypes "Usd Type" | SdfValueTypeNames->Opaque |
/// | \ref SdfVariability "Variability" | SdfVariabilityUniform |
int usd_CollectionAPI_GetCollectionAttr(usd_CollectionAPI_t const* _this, usd_Attribute_t* _result);

/// See GetCollectionAttr(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
/// If specified, author \p defaultValue as the attribute's default,
/// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
/// the default for \p writeSparsely is \c false.
int usd_CollectionAPI_CreateCollectionAttr(usd_CollectionAPI_t const* _this, vt_Value_t const* defaultValue, bool writeSparsely, usd_Attribute_t* _result);

/// Specifies a list of targets that are included in the collection.
/// This can target prims or properties directly. A collection can insert
/// the rules of another collection by making its <i>includes</i>
/// relationship target the <b>collection:{collectionName}</b> property on
/// the owning prim of the collection to be included
int usd_CollectionAPI_GetIncludesRel(usd_CollectionAPI_t const* _this, usd_Relationship_t* _result);

/// See GetIncludesRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usd_CollectionAPI_CreateIncludesRel(usd_CollectionAPI_t const* _this, usd_Relationship_t* _result);

/// Specifies a list of targets that are excluded below
/// the included paths in this collection. This can target prims or
/// properties directly, but cannot target another collection. This is to
/// keep the membership determining logic simple, efficient and easier to
/// reason about. Finally, it is invalid for a collection to exclude
/// paths that are not included in it. The presence of such "orphaned"
/// excluded paths will not affect the set of paths included in the
/// collection, but may affect the performance of querying membership of 
/// a path in the collection (see
/// UsdCollectionAPI::MembershipQuery::IsPathIncluded) 
/// or of enumerating the objects belonging to the collection (see 
/// UsdCollectionAPI::GetIncludedObjects).
int usd_CollectionAPI_GetExcludesRel(usd_CollectionAPI_t const* _this, usd_Relationship_t* _result);

/// See GetExcludesRel(), and also 
/// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
int usd_CollectionAPI_CreateExcludesRel(usd_CollectionAPI_t const* _this, usd_Relationship_t* _result);

/// Returns the canonical path that represents this collection. 
/// This points to the property named "collection:{collectionName}" on the 
/// prim defining the collection. This is the path to be used to "include" 
/// this collection in another collection.
/// 
/// \sa GetCollectionAttr()
int usd_CollectionAPI_GetCollectionPath(usd_CollectionAPI_t const* _this, sdf_Path_t* _result);

/// Computes and returns a UsdCollectionMembershipQuery object which can
/// be used to query inclusion or exclusion of paths in the collection.
int usd_CollectionAPI_ComputeMembershipQuery(usd_CollectionAPI_t const* _this, usd_CollectionMembershipQuery_t* _result);

/// Populates the UsdCollectionMembershipQuery object with data from this
/// collection, so it can be used to query inclusion or exclusion of paths.
int usd_CollectionAPI_ComputeMembershipQuery_in(usd_CollectionAPI_t const* _this, usd_CollectionMembershipQuery_t* query);

/// Returns true if the collection has nothing included in it.
/// This requires both that the includes relationship have no
/// target paths, and that the includeRoot attribute be false.
/// Note that there may be cases where the collection has no objects 
/// included in it even when HasNoIncludedPaths() returns false.
/// For example, if the included objects are unloaded or if the
/// included objects are also excluded.
int usd_CollectionAPI_HasNoIncludedPaths(usd_CollectionAPI_t const* _this, bool* _result);

/// Validates the collection by checking the following rules:
/// * a collection's expansionRule should be one of "explicitOnly", 
///   "expandPrims" or "expandPrimsAndProperties".
/// * a collection should not have have a circular dependency on 
///   another collection.
/// * a collection should not have both includes and excludes
///   among its top-level rules
int usd_CollectionAPI_Validate(usd_CollectionAPI_t const* _this, std_String_t* reason, bool* _result);

/// Resets the collection by clearing both the includes and excludes 
/// targets of the collection in the current UsdEditTarget.
/// 
/// \note This does not modify the "includeRoot" attribute which is used 
/// to include or exclude everything (i.e. the pseudoRoot) in the USD stage.
int usd_CollectionAPI_ResetCollection(usd_CollectionAPI_t const* _this, bool* _result);

/// Blocks the targets of the includes and excludes relationships of the 
/// collection, making it 
/// <* <i>empty</i> if "includeRoot" is false (or unset) or
/// * <i>include everything</i> if "includeRoot" is true.
/// (assuming there are no opinions in stronger edit targets).
int usd_CollectionAPI_BlockCollection(usd_CollectionAPI_t const* _this, bool* _result);

/// Includes or adds the given path, \p pathToInclude in the collection. 
/// 
/// This does nothing if the path is already included in the collection. 
/// 
/// This does not modify the expansion-rule of the collection. Hence, if the 
/// expansionRule is <i>expandPrims</i> or <i>expandPrimsAndProperties</i>, 
/// then the descendants of \p pathToInclude will be also included in the 
/// collection unless explicitly excluded.
/// 
/// \sa UsdCollectionAPI::ExcludePath()
int usd_CollectionAPI_IncludePath(usd_CollectionAPI_t const* _this, sdf_Path_t const* pathToInclude, bool* _result);

/// Excludes or removes the given path, \p pathToExclude from the collection.
/// 
/// If the collection is empty, the collection becomes one that
/// includes all paths except the givne path.  Otherwise, this does
/// nothing if the path is not included in the collection. 
/// 
/// This does not modify the expansion-rule of the collection. Hence, if the 
/// expansionRule is <i>expandPrims</i> or <i>expandPrimsAndProperties</i>, 
/// then the descendants of \p pathToExclude will also be excluded from the 
/// collection, unless explicitly included.
/// 
/// \sa UsdCollectionAPI::IncludePath()
int usd_CollectionAPI_ExcludePath(usd_CollectionAPI_t const* _this, sdf_Path_t const* pathToExclude, bool* _result);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usd_CollectionAPI_IsConcrete(usd_CollectionAPI_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usd_CollectionAPI_IsTyped(usd_CollectionAPI_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usd_CollectionAPI_IsAPISchema(usd_CollectionAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usd_CollectionAPI_IsAppliedAPISchema(usd_CollectionAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usd_CollectionAPI_IsMultipleApplyAPISchema(usd_CollectionAPI_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usd_CollectionAPI_GetSchemaKind(usd_CollectionAPI_t const* _this, int* _result);

/// Return this schema object's held prim.
int usd_CollectionAPI_GetPrim(usd_CollectionAPI_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usd_CollectionAPI_GetPath(usd_CollectionAPI_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usd_CollectionAPI_GetSchemaClassPrimDefinition(usd_CollectionAPI_t const* _this, usd_PrimDefinition_t const** _result);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes.  Does not include attributes that
/// may be authored by custom/extended methods of the schemas involved.
int usd_CollectionAPI_GetSchemaAttributeNames(bool includeInherited, tf_TokenVector_t const** _result);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes for a given instance name.  Does not
/// include attributes that may be authored by custom/extended methods of
/// the schemas involved. The names returned will have the proper namespace
/// prefix.
int usd_CollectionAPI_GetSchemaAttributeNames_for_instance(bool includeInherited, tf_Token_t const* instanceName, tf_TokenVector_t* _result);

/// Return a UsdCollectionAPI holding the prim adhering to this
/// schema at \p path on \p stage.  If no prim exists at \p path on
/// \p stage, or if the prim at that path does not adhere to this schema,
/// return an invalid schema object.  \p path must be of the format
/// <path>.collection:name .
/// 
/// This is shorthand for the following:
/// 
/// \code
/// TfToken name = SdfPath::StripNamespace(path.GetToken());
/// UsdCollectionAPI(
///     stage->GetPrimAtPath(path.GetPrimPath()), name);
/// \endcode
int usd_CollectionAPI_Get(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usd_CollectionAPI_t* _result);

/// Return a UsdCollectionAPI with name \p name holding the
/// prim \p prim. Shorthand for UsdCollectionAPI(prim, name);
int usd_CollectionAPI_Get_from_prim(usd_Prim_t const* prim, tf_Token_t const* name, usd_CollectionAPI_t* _result);

/// Return a vector of all named instances of UsdCollectionAPI on the 
/// given \p prim.
int usd_CollectionAPI_GetAll(usd_Prim_t const* prim, usd_CollectionAPIVector_t* _result);

/// Checks if the given name \p baseName is the base name of a property
/// of CollectionAPI.
int usd_CollectionAPI_IsSchemaPropertyBaseName(tf_Token_t const* baseName, bool* _result);

/// Checks if the given path \p path is of an API schema of type
/// CollectionAPI. If so, it stores the instance name of
/// the schema in \p name and returns true. Otherwise, it returns false.
int usd_CollectionAPI_IsCollectionAPIPath(sdf_Path_t const* path, tf_Token_t* name, bool* _result);

/// Returns true if this <b>multiple-apply</b> API schema can be applied,
/// with the given instance name, \p name, to the given \p prim. If this 
/// schema can not be a applied the prim, this returns false and, if 
/// provided, populates \p whyNot with the reason it can not be applied.
/// 
/// Note that if CanApply returns false, that does not necessarily imply
/// that calling Apply will fail. Callers are expected to call CanApply
/// before calling Apply if they want to ensure that it is valid to 
/// apply a schema.
/// 
/// \sa UsdPrim::GetAppliedSchemas()
/// \sa UsdPrim::HasAPI()
/// \sa UsdPrim::CanApplyAPI()
/// \sa UsdPrim::ApplyAPI()
/// \sa UsdPrim::RemoveAPI()
int usd_CollectionAPI_CanApply(usd_Prim_t const* prim, tf_Token_t const* name, std_String_t* whyNot, bool* _result);

/// Applies this <b>multiple-apply</b> API schema to the given \p prim 
/// along with the given instance name, \p name. 
/// 
/// This information is stored by adding "CollectionAPI:<i>name</i>" 
/// to the token-valued, listOp metadata \em apiSchemas on the prim.
/// For example, if \p name is 'instance1', the token 
/// 'CollectionAPI:instance1' is added to 'apiSchemas'.
/// 
/// \return A valid UsdCollectionAPI object is returned upon success. 
/// An invalid (or empty) UsdCollectionAPI object is returned upon 
/// failure. See \ref UsdPrim::ApplyAPI() for 
/// conditions resulting in failure. 
/// 
/// \sa UsdPrim::GetAppliedSchemas()
/// \sa UsdPrim::HasAPI()
/// \sa UsdPrim::CanApplyAPI()
/// \sa UsdPrim::ApplyAPI()
/// \sa UsdPrim::RemoveAPI()
int usd_CollectionAPI_Apply(usd_Prim_t const* prim, tf_Token_t const* name, usd_CollectionAPI_t* _result);

/// Returns the collection represented by the given collection path, 
/// \p collectionPath on the given USD stage.
int usd_CollectionAPI_GetCollection(usd_StageWeakPtr_t const* stage, sdf_Path_t const* collectionPath, usd_CollectionAPI_t* _result);

/// Returns the schema object representing a collection named \p name on 
/// the given \p prim.
int usd_CollectionAPI_GetCollection_from_prim(usd_Prim_t const* prim, tf_Token_t const* name, usd_CollectionAPI_t* _result);

/// Returns all the named collections on the given USD prim.
/// \deprecated Use GetAll(prim) instead.
int usd_CollectionAPI_GetAllCollections(usd_Prim_t const* prim, usd_CollectionAPIVector_t* _result);

/// Returns the canonical path to the collection named, \p name on the given
/// prim, \p prim.
/// 
/// \sa GetCollectionPath()
int usd_CollectionAPI_GetNamedCollectionPath(usd_Prim_t const* prim, tf_Token_t const* collectionName, sdf_Path_t* _result);

/// Returns all the usd objects that satisfy the predicate, \p pred in the
/// collection represented by the UsdCollectionMembershipQuery object, \p
/// query.
/// 
/// The results depends on the load state of the UsdStage, \p stage.
int usd_CollectionAPI_ComputeIncludedObjects(usd_CollectionMembershipQuery_t const* query, usd_StageWeakPtr_t const* stage, usd_PrimFlagsPredicate_t const* pred, usd_ObjectSet_t* _result);

/// Returns all the paths that satisfy the predicate, \p pred in the
/// collection represented by the UsdCollectionMembershipQuery object, \p
/// query.
/// 
/// The result depends on the load state of the UsdStage, \p stage.
int usd_CollectionAPI_ComputeIncludedPaths(usd_CollectionMembershipQuery_t const* query, usd_StageWeakPtr_t const* stage, usd_PrimFlagsPredicate_t const* pred, sdf_PathSet_t* _result);

/// Test whether a given \p name contains the "collection:" prefix
int usd_CollectionAPI_CanContainPropertyName(tf_Token_t const* name, bool* _result);

int usd_CollectionAPI_on_schema_obj(usd_Prim_t const* param00, tf_Token_t const* param01, usd_CollectionAPI_t** _result);

int usd_CollectionAPI_on_prim(usd_Prim_t const* param00, tf_Token_t const* param01, usd_CollectionAPI_t** _result);

int usd_CollectionAPI_dtor(usd_CollectionAPI_t* _this);

int usd_CollectionAPIVector_data(usd_CollectionAPIVector_t* _this, usd_CollectionAPI_t** _result);

int usd_CollectionAPIVector_data_const(usd_CollectionAPIVector_t const* _this, usd_CollectionAPI_t const** _result);

int usd_CollectionAPIVector_empty(usd_CollectionAPIVector_t const* _this, bool* _result);

int usd_CollectionAPIVector_size(usd_CollectionAPIVector_t const* _this, size_t* _result);

int usd_CollectionAPIVector_max_size(usd_CollectionAPIVector_t const* _this, size_t* _result);

int usd_CollectionAPIVector_reserve(usd_CollectionAPIVector_t* _this, size_t const _Newcapacity);

int usd_CollectionAPIVector_capacity(usd_CollectionAPIVector_t const* _this, size_t* _result);

int usd_CollectionAPIVector_clear(usd_CollectionAPIVector_t* _this);

int usd_CollectionAPIVector_push_back(usd_CollectionAPIVector_t* _this, usd_CollectionAPI_t const* _Val);

int usd_CollectionAPIVector_pop_back(usd_CollectionAPIVector_t* _this);

int usd_CollectionAPIVector_resize(usd_CollectionAPIVector_t* _this, size_t const _Newsize);

int usd_CollectionAPIVector_resize_with(usd_CollectionAPIVector_t* _this, size_t const _Newsize, usd_CollectionAPI_t const* _Val);

int usd_CollectionAPIVector_op_index(usd_CollectionAPIVector_t const* _this, size_t const _Pos, usd_CollectionAPI_t const** _result);

int usd_CollectionAPIVector_default(usd_CollectionAPIVector_t** _result);

int usd_CollectionAPIVector_dtor(usd_CollectionAPIVector_t* _this);

/// \overload
/// Returns whether the given path is included in the collection from
/// which this UsdCollectionMembershipQuery object was computed. This is the
/// API that clients should use for determining if a given object is a
/// member of the collection. To enumerate all the members of a collection,
/// use \ref UsdComputeIncludedObjectsFromCollection or
/// \ref UsdComputeIncludedPathsFromCollection.
/// 
/// If \p expansionRule is not nullptr, it is set to the expansion-
/// rule value that caused the path to be included in or excluded from
/// the collection. If \p path is not included in the collection,
/// \p expansionRule is set to UsdTokens->exclude.
/// 
/// It is useful to specify this parameter and use this overload of
/// IsPathIncluded(), when you're interested in traversing a subtree
/// and want to know whether the root of the subtree is included in a
/// collection. For evaluating membership of descendants of the root,
/// please use the other overload of IsPathIncluded(), that takes both
/// a path and the parent expansionRule.
/// 
/// The python version of this method only returns the boolean result.
/// It does not return \p expansionRule.
int usd_CollectionMembershipQuery_IsPathIncluded(usd_CollectionMembershipQuery_t const* _this, sdf_Path_t const* path, tf_Token_t* expansionRule, bool* _result);

/// \overload
/// Returns whether the given path, \p path is included in the
/// collection from which this UsdCollectionMembershipQuery object was
/// computed, given the parent-path's inherited expansion rule,
/// \p parentExpansionRule.
/// 
/// If \p expansionRule is not nullptr, it is set to the expansion-
/// rule value that caused the path to be included in or excluded from
/// the collection. If \p path is not included in the collection,
/// \p expansionRule is set to UsdTokens->exclude.
/// 
/// The python version of this method only returns the boolean result.
/// It does not return \p expansionRule.
int usd_CollectionMembershipQuery_IsPathIncluded_with_parent_expansion_rule(usd_CollectionMembershipQuery_t const* _this, sdf_Path_t const* path, tf_Token_t const* parentExpansionRule, tf_Token_t* expansionRule, bool* _result);

/// Returns true if the collection excludes one or more paths below an
/// included path.
int usd_CollectionMembershipQuery_HasExcludes(usd_CollectionMembershipQuery_t const* _this, bool* _result);

/// Equality operator
int usd_CollectionMembershipQuery_op_eq(usd_CollectionMembershipQuery_t const* _this, usd_CollectionMembershipQuery_t const* rhs, bool* _result);

/// Returns a raw map of the paths included or excluded in the
/// collection along with the expansion rules for the included
/// paths.
int usd_CollectionMembershipQuery_GetAsPathExpansionRuleMap(usd_CollectionMembershipQuery_t const* _this, usd_CollectionMembershipQueryPathExpansionRuleMap_t const** _result);

/// Returns a set of paths for all collections that were included in the
/// collection from which this UsdCollectionMembershipQuery object was
/// computed. This set is recursive, so collections that were included
/// by other collections will be part of this set. The collection from
/// which this UsdCollectionMembershipQuery object was computed is *not*
/// part of this set.
int usd_CollectionMembershipQuery_GetIncludedCollections(usd_CollectionMembershipQuery_t const* _this, sdf_PathSet_t const** _result);

int usd_CollectionMembershipQuery_default(usd_CollectionMembershipQuery_t** _result);

int usd_CollectionMembershipQuery_dtor(usd_CollectionMembershipQuery_t* _this);

int usd_CollectionMembershipQueryPathExpansionRuleMap_at(usd_CollectionMembershipQueryPathExpansionRuleMap_t* _this, sdf_Path_t const* _Keyval, tf_Token_t** _result);

int usd_CollectionMembershipQueryPathExpansionRuleMap_default(usd_CollectionMembershipQueryPathExpansionRuleMap_t** _result);

int usd_CollectionMembershipQueryPathExpansionRuleMap_dtor(usd_CollectionMembershipQueryPathExpansionRuleMap_t* _this);

/// Returns whether or not this class corresponds to a concrete instantiable
/// prim type in scene description.  If this is true,
/// GetStaticPrimDefinition() will return a valid prim definition with
/// a non-empty typeName.
int usd_ModelAPI_IsConcrete(usd_ModelAPI_t const* _this, bool* _result);

/// Returns whether or not this class inherits from UsdTyped. Types which
/// inherit from UsdTyped can impart a typename on a UsdPrim.
int usd_ModelAPI_IsTyped(usd_ModelAPI_t const* _this, bool* _result);

/// Returns whether this is an API schema or not.
int usd_ModelAPI_IsAPISchema(usd_ModelAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true this class will have an Apply() method
int usd_ModelAPI_IsAppliedAPISchema(usd_ModelAPI_t const* _this, bool* _result);

/// Returns whether this is an applied API schema or not. If this returns
/// true the constructor, Get and Apply methods of this class will take
/// in the name of the API schema instance.
int usd_ModelAPI_IsMultipleApplyAPISchema(usd_ModelAPI_t const* _this, bool* _result);

/// Returns the kind of schema this class is.
int usd_ModelAPI_GetSchemaKind(usd_ModelAPI_t const* _this, int* _result);

/// Return this schema object's held prim.
int usd_ModelAPI_GetPrim(usd_ModelAPI_t const* _this, usd_Prim_t* _result);

/// Shorthand for GetPrim()->GetPath().
int usd_ModelAPI_GetPath(usd_ModelAPI_t const* _this, sdf_Path_t* _result);

/// Return the prim definition associated with this schema instance if one
/// exists, otherwise return null.  This does not use the held prim's type.
/// To get the held prim instance's definition, use
/// UsdPrim::GetPrimDefinition().  \sa UsdPrim::GetPrimDefinition()
int usd_ModelAPI_GetSchemaClassPrimDefinition(usd_ModelAPI_t const* _this, usd_PrimDefinition_t const** _result);

/// Returns the model's asset identifier as authored in the composed 
/// assetInfo dictionary.
/// 
/// The asset identifier can be used to resolve the model's root layer via 
/// the asset resolver plugin.
int usd_ModelAPI_GetAssetIdentifier(usd_ModelAPI_t const* _this, sdf_AssetPath_t* identifier, bool* _result);

/// Sets the model's asset identifier to the given asset path, \p identifier.
/// 
/// \sa GetAssetIdentifier()
int usd_ModelAPI_SetAssetIdentifier(usd_ModelAPI_t const* _this, sdf_AssetPath_t const* identifier);

/// Returns the model's asset name from the composed assetInfo dictionary.
/// 
/// The asset name is the name of the asset, as would be used in a database 
/// query.
int usd_ModelAPI_GetAssetName(usd_ModelAPI_t const* _this, std_String_t* assetName, bool* _result);

/// Sets the model's asset name to \p assetName.
/// 
/// \sa GetAssetName()
int usd_ModelAPI_SetAssetName(usd_ModelAPI_t const* _this, std_String_t const* assetName);

/// Returns the model's resolved asset version.  
/// 
/// If you publish assets with an embedded version, then you may receive 
/// that version string.  You may, however, cause your authoring tools to 
/// record the resolved version <em>at the time at which a reference to the 
/// asset was added to an aggregate</em>, at the referencing site.  In 
/// such a pipeline, this API will always return that stronger opinion, 
/// even if the asset is republished with a newer version, and even though 
/// that newer version may be the one that is resolved when the UsdStage is 
/// opened.
int usd_ModelAPI_GetAssetVersion(usd_ModelAPI_t const* _this, std_String_t* version, bool* _result);

/// Sets the model's asset version string. 
/// 
/// \sa GetAssetVersion()
int usd_ModelAPI_SetAssetVersion(usd_ModelAPI_t const* _this, std_String_t const* version);

/// Returns the list of asset dependencies referenced inside the 
/// payload of the model.
/// 
/// This typically contains identifiers of external assets that are 
/// referenced inside the model's payload. When the model is created, this 
/// list is compiled and set at the root of the model. This enables 
/// efficient dependency analysis without the need to include the model's 
/// payload.
int usd_ModelAPI_GetPayloadAssetDependencies(usd_ModelAPI_t const* _this, sdf_AssetPathArray_t* assetDeps, bool* _result);

/// Sets the list of external asset dependencies referenced inside the 
/// payload of a model.
/// 
/// \sa GetPayloadAssetDependencies()
int usd_ModelAPI_SetPayloadAssetDependencies(usd_ModelAPI_t const* _this, sdf_AssetPathArray_t const* assetDeps);

/// Returns the model's composed assetInfo dictionary.
/// 
/// The asset info dictionary is used to annotate models with various 
/// data related to asset management. For example, asset name,
/// identifier, version etc.
/// 
/// The elements of this dictionary are composed element-wise, and are 
/// nestable.
int usd_ModelAPI_GetAssetInfo(usd_ModelAPI_t const* _this, vt_Dictionary_t* info, bool* _result);

/// Sets the model's assetInfo dictionary to \p info in the current edit 
/// target.
int usd_ModelAPI_SetAssetInfo(usd_ModelAPI_t const* _this, vt_Dictionary_t const* info);

/// Return a UsdModelAPI holding the prim adhering to this
/// schema at \p path on \p stage.  If no prim exists at \p path on
/// \p stage, or if the prim at that path does not adhere to this schema,
/// return an invalid schema object.  This is shorthand for the following:
/// 
/// \code
/// UsdModelAPI(stage->GetPrimAtPath(path));
/// \endcode
int usd_ModelAPI_Get(usd_StageWeakPtr_t const* stage, sdf_Path_t const* path, usd_ModelAPI_t* _result);

/// Return a vector of names of all pre-declared attributes for this schema
/// class and all its ancestor classes.  Does not include attributes that
/// may be authored by custom/extended methods of the schemas involved.
int usd_ModelAPI_GetSchemaAttributeNames(bool includeInherited, tf_TokenVector_t const** _result);

/// Retrieve the authored \p kind for this prim.
/// 
/// To test whether the returned \p kind matches a particular known
/// "clientKind":
/// \code
/// TfToken kind;
/// 
/// bool isClientKind = UsdModelAPI(prim).GetKind(&kind) and
///                     KindRegistry::IsA(kind, clientKind);
/// \endcode
/// 
/// \return true if there was an authored kind that was successfully read,
/// otherwise false.
/// 
/// \sa \ref mainpage_kind "The Kind module" for further details on
/// how to use Kind for classification, and how to extend the taxonomy.
int usd_ModelAPI_GetKind(usd_ModelAPI_t const* _this, tf_Token_t* kind, bool* _result);

/// Author a \p kind for this prim, at the current UsdEditTarget.
/// \return true if \p kind was successully authored, otherwise false.
int usd_ModelAPI_SetKind(usd_ModelAPI_t const* _this, tf_Token_t const* kind, bool* _result);

/// Return true if the prim's kind metadata is or inherits from
/// \p baseKind as defined by the Kind Registry.
/// 
/// If \p validation is KindValidationModelHierarchy (the default), then
/// this also ensures that if baseKind is a model, the prim conforms to
/// the rules of model hierarchy, as defined by IsModel. If set to
/// KindValidationNone, no additional validation is done.
/// 
/// IsModel and IsGroup are preferrable to IsKind("model") as they are
/// optimized for fast traversal.
/// 
/// \note If a prim's model hierarchy is not valid, it is possible that
/// that prim.IsModel() and 
/// prim.IsKind("model", Usd.ModelAPI.KindValidationNone) return different
/// answers. (As a corallary, this is also true for for prim.IsGroup())
int usd_ModelAPI_IsKind(usd_ModelAPI_t const* _this, tf_Token_t const* baseKind, int validation, bool* _result);

/// Return true if this prim represents a model, based on its kind
/// metadata.
int usd_ModelAPI_IsModel(usd_ModelAPI_t const* _this, bool* _result);

/// Return true if this prim represents a model group, based on its kind
/// metadata.
int usd_ModelAPI_IsGroup(usd_ModelAPI_t const* _this, bool* _result);

int usd_ModelAPI_on_schema_obj(usd_Prim_t const* param00, usd_ModelAPI_t** _result);

int usd_ModelAPI_on_prim(usd_Prim_t const* param00, usd_ModelAPI_t** _result);

int usd_ModelAPI_dtor(usd_ModelAPI_t* _this);

/// An attribute's variability expresses whether it is intended to have
/// time-samples (\c SdfVariabilityVarying), or only a single default 
/// value (\c SdfVariabilityUniform).
/// 
/// Variability is required meta-data of all attributes, and its fallback
/// value is SdfVariabilityVarying.
int usd_Attribute_GetVariability(usd_Attribute_t const* _this, int* _result);

/// Set the value for variability at the current EditTarget, return true
/// on success, false if the value can not be written.
/// 
/// \b Note that this value should not be changed as it is typically either
/// automatically authored or provided by a property definition. This method
/// is provided primarily for fixing invalid scene description.
int usd_Attribute_SetVariability(usd_Attribute_t const* _this, int variability, bool* _result);

/// Return the "scene description" value type name for this attribute.
int usd_Attribute_GetTypeName(usd_Attribute_t const* _this, sdf_ValueTypeName_t* _result);

/// Set the value for typeName at the current EditTarget, return true on
/// success, false if the value can not be written.
/// 
/// \b Note that this value should not be changed as it is typically either
/// automatically authored or provided by a property definition. This method
/// is provided primarily for fixing invalid scene description.
int usd_Attribute_SetTypeName(usd_Attribute_t const* _this, sdf_ValueTypeName_t const* typeName, bool* _result);

/// Return the roleName for this attribute's typeName.
int usd_Attribute_GetRoleName(usd_Attribute_t const* _this, tf_Token_t* _result);

/// Adds \p source to the list of connections, in the position
/// specified by \p position.
/// 
/// Issue an error if \p source identifies a prototype prim or an object
/// descendant to a prototype prim.  It is not valid to author connections
/// to these objects. 
/// 
/// What data this actually authors depends on what data is currently
/// authored in the authoring layer, with respect to list-editing
/// semantics, which we will document soon 
int usd_Attribute_AddConnection(usd_Attribute_t const* _this, sdf_Path_t const* source, int position, bool* _result);

/// Removes \p target from the list of targets.
/// 
/// Issue an error if \p source identifies a prototype prim or an object
/// descendant to a prototype prim.  It is not valid to author connections
/// to these objects.
int usd_Attribute_RemoveConnection(usd_Attribute_t const* _this, sdf_Path_t const* source, bool* _result);

/// Make the authoring layer's opinion of the connection list explicit,
/// and set exactly to \p sources.
/// 
/// Issue an error if \p source identifies a prototype prim or an object
/// descendant to a prototype prim.  It is not valid to author connections
/// to these objects.
/// 
/// If any path in \p sources is invalid, issue an error and return false.
int usd_Attribute_SetConnections(usd_Attribute_t const* _this, sdf_PathVector_t const* sources, bool* _result);

/// Remove all opinions about the connections list from the current edit
/// target.
int usd_Attribute_ClearConnections(usd_Attribute_t const* _this, bool* _result);

/// Compose this attribute's connections and fill \p sources with the
/// result.  All preexisting elements in \p sources are lost.
/// 
/// Returns true if any connection path opinions have been authored and no
/// composition errors were encountered, returns false otherwise. 
/// Note that authored opinions may include opinions that clear the 
/// connections and a return value of true does not necessarily indicate 
/// that \p sources will contain any connection paths.
/// 
/// See \ref Usd_ScenegraphInstancing_TargetsAndConnections for details on 
/// behavior when targets point to objects beneath instance prims.
/// 
/// The result is not cached, and thus recomputed on each query.
int usd_Attribute_GetConnections(usd_Attribute_t const* _this, sdf_PathVector_t* sources, bool* _result);

/// Return true if this attribute has any authored opinions regarding
/// connections.  Note that this includes opinions that remove connections,
/// so a true return does not necessarily indicate that this attribute has
/// connections.
int usd_Attribute_HasAuthoredConnections(usd_Attribute_t const* _this, bool* _result);

/// Gets the color space in which the attribute is authored.
/// \sa SetColorSpace()
/// \ref Usd_ColorConfigurationAPI "UsdStage Color Configuration API"
int usd_Attribute_GetColorSpace(usd_Attribute_t const* _this, tf_Token_t* _result);

/// Sets the color space of the attribute to \p colorSpace.
/// \sa GetColorSpace()
/// \ref Usd_ColorConfigurationAPI "UsdStage Color Configuration API"
int usd_Attribute_SetColorSpace(usd_Attribute_t const* _this, tf_Token_t const* colorSpace);

/// Returns whether color-space is authored on the attribute.
/// \sa GetColorSpace()
int usd_Attribute_HasColorSpace(usd_Attribute_t const* _this, bool* _result);

/// Clears authored color-space value on the attribute.
/// \sa SetColorSpace()
int usd_Attribute_ClearColorSpace(usd_Attribute_t const* _this, bool* _result);

/// Populates a vector with authored sample times.
/// Returns false only on error.
/// 
/// This method uses the standard resolution semantics, so if a stronger
/// default value is authored over weaker time samples, the default value
/// will hide the underlying timesamples.
/// 
/// \note This function will query all value clips that may contribute 
/// time samples for this attribute, opening them if needed. This may be
/// expensive, especially if many clips are involved.     
/// 
/// \param times - on return, will contain the \em sorted, ascending
/// timeSample ordinates.  Any data in \p times will be lost, as this
/// method clears \p times. 
/// 
/// \sa UsdAttribute::GetTimeSamplesInInterval
int usd_Attribute_GetTimeSamples(usd_Attribute_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Populates a vector with authored sample times in \p interval. 
/// Returns false only on an error.
/// 
/// \note This function will only query the value clips that may 
/// contribute time samples for this attribute in the given interval, 
/// opening them if necessary.
/// 
/// \param interval - the \ref GfInterval on which to gather time samples.     
/// 
/// \param times - on return, will contain the \em sorted, ascending
/// timeSample ordinates.  Any data in \p times will be lost, as this
/// method clears \p times. 
/// 
/// \sa UsdAttribute::GetTimeSamples
int usd_Attribute_GetTimeSamplesInInterval(usd_Attribute_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Returns the number of time samples that have been authored.
/// 
/// This method uses the standard resolution semantics, so if a stronger
/// default value is authored over weaker time samples, the default value
/// will hide the underlying timesamples.
/// 
/// \note This function will query all value clips that may contribute 
/// time samples for this attribute, opening them if needed. This may be
/// expensive, especially if many clips are involved.
int usd_Attribute_GetNumTimeSamples(usd_Attribute_t const* _this, size_t* _result);

/// Populate \a lower and \a upper with the next greater and lesser
/// value relative to the \a desiredTime. Return false if no value exists
/// or an error occurs, true if either a default value or timeSamples exist.
/// 
/// Use standard resolution semantics: if a stronger default value is
/// authored over weaker time samples, the default value hides the
/// underlying timeSamples.
/// 
/// 1) If a sample exists at the \a desiredTime, set both upper and lower
/// to \a desiredTime.
/// 
/// 2) If samples exist surrounding, but not equal to the \a desiredTime,
/// set lower and upper to the bracketing samples nearest to the
/// \a desiredTime. 
/// 
/// 3) If the \a desiredTime is outside of the range of authored samples, 
/// clamp upper and lower to the nearest time sample.
/// 
/// 4) If no samples exist, do not modify upper and lower and set
/// \a hasTimeSamples to false.
/// 
/// In cases (1), (2) and (3), set \a hasTimeSamples to true.
/// 
/// All four cases above are considered to be successful, thus the return
/// value will be true and no error message will be emitted.
int usd_Attribute_GetBracketingTimeSamples(usd_Attribute_t const* _this, double desiredTime, double* lower, double* upper, bool* hasTimeSamples, bool* _result);

/// Return true if this attribute has an authored default value, authored
/// time samples or a fallback value provided by a registered schema. If
/// the attribute has been \ref Usd_AttributeBlocking "blocked", then
/// return `true` if and only if it has a fallback value.
int usd_Attribute_HasValue(usd_Attribute_t const* _this, bool* _result);

/// \deprecated This method is deprecated because it returns `true` even when
/// an attribute is blocked.  Please use HasAuthoredValue() instead.  If 
/// you truly need to know whether the attribute has **any** authored
/// value opinions, *including blocks*, you can make the following query:
/// `attr.GetResolveInfo().HasAuthoredValueOpinion()`
/// 
/// Return true if this attribute has either an authored default value or
/// authored time samples.
int usd_Attribute_HasAuthoredValueOpinion(usd_Attribute_t const* _this, bool* _result);

/// Return true if this attribute has either an authored default value or
/// authored time samples.  If the attribute has been 
/// \ref Usd_AttributeBlocking "blocked", then return `false`
int usd_Attribute_HasAuthoredValue(usd_Attribute_t const* _this, bool* _result);

/// Return true if this attribute has a fallback value provided by 
/// a registered schema.
int usd_Attribute_HasFallbackValue(usd_Attribute_t const* _this, bool* _result);

/// Return true if it is possible, but not certain, that this attribute's
/// value changes over time, false otherwise. 
/// 
/// If this function returns false, it is certain that this attribute's
/// value remains constant over time.
/// 
/// This function is equivalent to checking if GetNumTimeSamples() > 1,
/// but may be more efficient since it does not actually need to get a
/// full count of all time samples.
int usd_Attribute_ValueMightBeTimeVarying(usd_Attribute_t const* _this, bool* _result);

/// \overload 
/// Type-erased access, often not as efficient as typed access.
int usd_Attribute_Get(usd_Attribute_t const* _this, vt_Value_t* value, usd_TimeCode_t time, bool* _result);

/// Perform value resolution to determine the source of the resolved
/// value of this attribute at the requested UsdTimeCode \p time.
int usd_Attribute_GetResolveInfo_at_time(usd_Attribute_t const* _this, usd_TimeCode_t time, usd_ResolveInfo_t* _result);

/// Perform value resolution to determine the source of the resolved
/// value of this attribute at any non-default time. 
/// 
/// Often (i.e. unless the attribute is affected by 
/// \ref Usd_Page_ValueClips "Value Clips") the source of the resolved value
/// does not vary over time. See UsdAttributeQuery as an example that takes
/// advantage of this quality of value resolution.
int usd_Attribute_GetResolveInfo(usd_Attribute_t const* _this, usd_ResolveInfo_t* _result);

/// \overload 
int usd_Attribute_Set(usd_Attribute_t const* _this, vt_Value_t const* value, usd_TimeCode_t time, bool* _result);

/// Clears the authored default value and all time samples for this
/// attribute at the current EditTarget and returns true on success.
/// 
/// Calling clear when either no value is authored or no spec is present,
/// is a silent no-op returning true.    
/// 
/// This method does not affect any other data authored on this attribute.
int usd_Attribute_Clear(usd_Attribute_t const* _this, bool* _result);

/// Clear the authored value for this attribute at the given 
/// \a time, at the current EditTarget and return true on success. 
/// UsdTimeCode::Default() can be used to clear the default value.
/// 
/// Calling clear when either no value is authored or no spec is present,
/// is a silent no-op returning true. 
int usd_Attribute_ClearAtTime(usd_Attribute_t const* _this, usd_TimeCode_t time, bool* _result);

/// Shorthand for ClearAtTime(UsdTimeCode::Default()).
int usd_Attribute_ClearDefault(usd_Attribute_t const* _this, bool* _result);

/// Remove all time samples on an attribute and author a *block*
/// \c default value. This causes the attribute to resolve as 
/// if there were no authored value opinions in weaker layers.
/// 
/// See \ref Usd_AttributeBlocking for more information, including
/// information on time-varying blocking.
int usd_Attribute_Block(usd_Attribute_t const* _this);

/// Populates the given vector, \p times with the union of all the 
/// authored sample times on all of the given attributes, \p attrs.
/// 
/// \note This function will query all value clips that may contribute 
/// time samples for the attributes in \p attrs, opening them if needed. 
/// This may be expensive, especially if many clips are involved.
/// 
/// The accumulated sample times will be in sorted (increasing) order and 
/// will not contain any duplicates.
/// 
/// This clears any existing values in the \p times vector before 
/// accumulating sample times of the given attributes.
/// 
/// \return false if any of the attributes in \p attr are invalid or  if 
/// there's an error when fetching time-samples for any of the attributes.
/// 
/// \sa UsdAttribute::GetTimeSamples
/// \sa UsdAttribute::GetUnionedTimeSamplesInInterval
int usd_Attribute_GetUnionedTimeSamples(usd_AttributeVector_t const* attrs, std_DoubleVector_t* times, bool* _result);

/// Populates the given vector, \p times with the union of all the 
/// authored sample times in the GfInterval, \p interval on all of the 
/// given attributes, \p attrs.
/// 
/// \note This function will only query the value clips that may 
/// contribute time samples for the attributes in \p attrs, in the 
/// given \p interval, opening them if necessary.
/// 
/// The accumulated sample times will be in sorted (increasing) order and 
/// will not contain any duplicates.
/// 
/// This clears any existing values in the \p times vector before 
/// accumulating sample times of the given attributes.
/// 
/// \return false if any of the attributes in \p attr are invalid or if 
/// there's an error fetching time-samples for any of the attributes.
/// 
/// \sa UsdAttribute::GetTimeSamplesInInterval
/// \sa UsdAttribute::GetUnionedTimeSamples
int usd_Attribute_GetUnionedTimeSamplesInInterval(usd_AttributeVector_t const* attrs, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Returns a strength-ordered list of property specs that provide
/// opinions for this property.
/// 
/// If \p time is UsdTimeCode::Default(), *or* this property 
/// is a UsdRelationship (which are never affected by clips), we will 
/// not consider value clips for opinions. For any other \p time, for 
/// a UsdAttribute, clips whose samples may contribute an opinion will 
/// be included. These specs are ordered from strongest to weakest opinion, 
/// although if \p time requires interpolation between two adjacent clips, 
/// both clips will appear, sequentially.
/// 
/// \note The results returned by this method are meant for debugging
/// and diagnostic purposes.  It is **not** advisable to retain a 
/// PropertyStack for the purposes of expedited value resolution for 
/// properties, since the makeup of an attribute's PropertyStack may
/// itself be time-varying.  To expedite repeated value resolution of
/// attributes, you should instead retain a \c UsdAttributeQuery .
/// 
/// \sa UsdClipsAPI
int usd_Attribute_GetPropertyStack(usd_Attribute_t const* _this, usd_TimeCode_t time, sdf_PropertySpecHandleVector_t* _result);

/// Returns a strength-ordered list of property specs that provide
/// opinions for this property paired with the cumulative layer offset from
/// the stage's root layer to the layer containing the property spec.
/// 
/// This behaves exactly the same as UsdProperty::GetPropertyStack with the 
/// addition of providing the cumulative layer offset of each spec's layer.
/// 
/// \note The results returned by this method are meant for debugging
/// and diagnostic purposes.  It is **not** advisable to retain a 
/// PropertyStack for the purposes of expedited value resolution for 
/// properties, since the makeup of an attribute's PropertyStack may
/// itself be time-varying.  To expedite repeated value resolution of
/// attributes, you should instead retain a \c UsdAttributeQuery .
int usd_Attribute_GetPropertyStackWithLayerOffsets(usd_Attribute_t const* _this, usd_TimeCode_t time, sdf_PropertySpecHandleOffsetPairVector_t* _result);

/// Return this property's name with all namespace prefixes removed,
/// i.e. the last component of the return value of GetName()
/// 
/// This is generally the property's "client name"; property namespaces are
/// often used to group related properties together.  The namespace prefixes
/// the property name but many consumers will care only about un-namespaced
/// name, i.e. its BaseName.  For more information, see \ref Usd_Ordering
int usd_Attribute_GetBaseName(usd_Attribute_t const* _this, tf_Token_t* _result);

/// Return this property's complete namespace prefix.  Return the empty
/// token if this property has no namespaces.
/// 
/// This is the complement of GetBaseName(), although it does \em not
/// contain a trailing namespace delimiter
int usd_Attribute_GetNamespace(usd_Attribute_t const* _this, tf_Token_t* _result);

/// Return this property's name elements including namespaces and its base
/// name as the final element.
int usd_Attribute_SplitName(usd_Attribute_t const* _this, std_StringVector_t* _result);

/// Return this property's display group (metadata).  This returns the
/// empty token if no display group has been set.
/// \sa SetDisplayGroup()
int usd_Attribute_GetDisplayGroup(usd_Attribute_t const* _this, std_String_t* _result);

/// Sets this property's display group (metadata).  Returns true on success.
/// 
/// DisplayGroup provides UI hinting for grouping related properties
/// together for display.  We define a convention for specifying nesting
/// of groups by recognizing the property namespace separator in 
/// displayGroup as denoting group-nesting.
/// \sa SetNestedDisplayGroups()
int usd_Attribute_SetDisplayGroup(usd_Attribute_t const* _this, std_String_t const* displayGroup, bool* _result);

/// Clears this property's display group (metadata) in
/// the current EditTarget (only).  Returns true on success.
int usd_Attribute_ClearDisplayGroup(usd_Attribute_t const* _this, bool* _result);

/// Returns true if displayGroup was explicitly authored and GetMetadata()
/// will return a meaningful value for displayGroup. 
int usd_Attribute_HasAuthoredDisplayGroup(usd_Attribute_t const* _this, bool* _result);

/// Return this property's displayGroup as a sequence of groups to be
/// nested, or an empty vector if displayGroup is empty or not authored.
int usd_Attribute_GetNestedDisplayGroups(usd_Attribute_t const* _this, std_StringVector_t* _result);

/// Sets this property's display group (metadata) to the nested sequence.  
/// Returns true on success.
/// 
/// A displayGroup set with this method can still be retrieved with
/// GetDisplayGroup(), with the namespace separator embedded in the result.
/// If \p nestedGroups is empty, we author an empty string for displayGroup.
/// \sa SetDisplayGroup()
int usd_Attribute_SetNestedDisplayGroups(usd_Attribute_t const* _this, std_StringVector_t const* nestedGroups, bool* _result);

/// Return true if this is a custom property (i.e., not part of a
/// prim schema).
/// 
/// The 'custom' modifier in USD serves the same function as Alembic's
/// 'userProperties', which is to say as a categorization for ad hoc
/// client data not formalized into any schema, and therefore not 
/// carrying an expectation of specific processing by consuming applications.
int usd_Attribute_IsCustom(usd_Attribute_t const* _this, bool* _result);

/// Set the value for custom at the current EditTarget, return true on
/// success, false if the value can not be written.
/// 
/// \b Note that this value should not be changed as it is typically either
/// automatically authored or provided by a property definition. This method
/// is provided primarily for fixing invalid scene description.
int usd_Attribute_SetCustom(usd_Attribute_t const* _this, bool isCustom, bool* _result);

/// Return true if this is a builtin property or if the strongest
/// authored SdfPropertySpec for this property's path matches this
/// property's dynamic type.  That is, SdfRelationshipSpec in case this is a
/// UsdRelationship, and SdfAttributeSpec in case this is a UsdAttribute.
/// Return \c false if this property's prim has expired.
/// 
/// For attributes, a \c true return does not imply that this attribute
/// possesses a value, only that has been declared, is of a certain type and
/// variability, and that it is safe to use to query and author values and
/// metadata.
int usd_Attribute_IsDefined(usd_Attribute_t const* _this, bool* _result);

/// Return true if there are any authored opinions for this property
/// in any layer that contributes to this stage, false otherwise.
int usd_Attribute_IsAuthored(usd_Attribute_t const* _this, bool* _result);

/// Return true if there is an SdfPropertySpec authored for this
/// property at the given \a editTarget, otherwise return false.  Note
/// that this method does not do partial composition.  It does not consider
/// whether authored scene description exists at \a editTarget or weaker,
/// only <b>exactly at</b> the given \a editTarget.
int usd_Attribute_IsAuthoredAt(usd_Attribute_t const* _this, usd_EditTarget_t const* editTarget, bool* _result);

/// Flattens this property to a property spec with the same name 
/// beneath the given \p parent prim in the edit target of its owning stage.
/// 
/// The \p parent prim may belong to a different stage than this property's 
/// owning stage.
/// 
/// Flattening authors all authored resolved values and metadata for 
/// this property into the destination property spec. If this property
/// is a builtin property, fallback values and metadata will also be
/// authored if the destination property has a different fallback 
/// value or no fallback value, or if the destination property has an
/// authored value that overrides its fallback.
/// 
/// Attribute connections and relationship targets that target an
/// object beneath this property's owning prim will be remapped to
/// target objects beneath the destination \p parent prim.
/// 
/// If the destination spec already exists, it will be overwritten.
/// 
/// \sa UsdStage::Flatten
int usd_Attribute_FlattenTo_prim(usd_Attribute_t const* _this, usd_Prim_t const* parent, usd_Property_t* _result);

/// \overload
/// Flattens this property to a property spec with the given
/// \p propName beneath the given \p parent prim in the edit target of its 
/// owning stage.
/// 
/// The \p parent prim may belong to a different stage than this property's 
/// owning stage.
int usd_Attribute_FlattenTo_named_property(usd_Attribute_t const* _this, usd_Prim_t const* parent, tf_Token_t const* propName, usd_Property_t* _result);

/// \overload
/// Flattens this property to a property spec for the given
/// \p property in the edit target of its owning prim's stage.
/// 
/// The \p property owning prim may belong to a different stage than this 
/// property's owning stage.
int usd_Attribute_FlattenTo_property(usd_Attribute_t const* _this, usd_Property_t const* property, usd_Property_t* _result);

/// \overload
/// 
/// Type-erased access
int usd_Attribute_GetMetadata_value(usd_Attribute_t const* _this, tf_Token_t const* key, vt_Value_t* value, bool* _result);

/// \overload
int usd_Attribute_SetMetadata_value(usd_Attribute_t const* _this, tf_Token_t const* key, vt_Value_t const* value, bool* _result);

/// Clears the authored \a key's value at the current EditTarget,
/// returning false on error.
/// 
/// If no value is present, this method is a no-op and returns true. It is
/// considered an error to call ClearMetadata when no spec is present for 
/// this UsdObject, i.e. if the object has no presence in the
/// current UsdEditTarget.
/// 
/// \sa \ref Usd_OM_Metadata
int usd_Attribute_ClearMetadata(usd_Attribute_t const* _this, tf_Token_t const* key, bool* _result);

/// Returns true if the \a key has a meaningful value, that is, if
/// GetMetadata() will provide a value, either because it was authored
/// or because a prim's metadata fallback will be provided.
int usd_Attribute_HasMetadata(usd_Attribute_t const* _this, tf_Token_t const* key, bool* _result);

/// Returns true if the \a key has an authored value, false if no
/// value was authored or the only value available is a prim's metadata 
/// fallback.
int usd_Attribute_HasAuthoredMetadata(usd_Attribute_t const* _this, tf_Token_t const* key, bool* _result);

/// \overload
int usd_Attribute_GetMetadataByDictKey_value(usd_Attribute_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t* value, bool* _result);

/// \overload
int usd_Attribute_SetMetadataByDictKey_value(usd_Attribute_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t const* value, bool* _result);

/// Clear any authored value identified by \p key and \p keyPath
/// at the current EditTarget.  The \p keyPath is a ':'-separated path
/// identifying a path in subdictionaries stored in the metadata field at
/// \p key.  Return true if the value is cleared successfully, false
/// otherwise.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Attribute_ClearMetadataByDictKey(usd_Attribute_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Return true if there exists any authored or fallback opinion for
/// \p key and \p keyPath.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries stored in the metadata field at
/// \p key.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Attribute_HasMetadataDictKey(usd_Attribute_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Return true if there exists any authored opinion (excluding
/// fallbacks) for \p key and \p keyPath.  The \p keyPath is a ':'-separated
/// path identifying a value in subdictionaries stored in the metadata field
/// at \p key.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Attribute_HasAuthoredMetadataDictKey(usd_Attribute_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Resolve and return all metadata (including both authored and
/// fallback values) on this object, sorted lexicographically.
/// 
/// \note This method does not return field keys for composition arcs,
/// such as references, inherits, payloads, sublayers, variants, or
/// primChildren, nor does it return the default value or timeSamples.
int usd_Attribute_GetAllMetadata(usd_Attribute_t const* _this, usd_MetadataValueMap_t* _result);

/// Resolve and return all user-authored metadata on this object,
/// sorted lexicographically.
/// 
/// \note This method does not return field keys for composition arcs,
/// such as references, inherits, payloads, sublayers, variants, or
/// primChildren, nor does it return the default value or timeSamples.
int usd_Attribute_GetAllAuthoredMetadata(usd_Attribute_t const* _this, usd_MetadataValueMap_t* _result);

/// Gets the value of the 'hidden' metadata field, false if not 
/// authored.
/// 
/// When an object is marked as hidden, it is an indicator to clients who 
/// generically display objects (such as GUI widgets) that this object 
/// should not be included, unless explicitly asked for.  Although this
/// is just a hint and thus up to each application to interpret, we
/// use it primarily as a way of simplifying hierarchy displays, by
/// hiding \em only the representation of the object itself, \em not its
/// subtree, instead "pulling up" everything below it one level in the
/// hierarchical nesting.
/// 
/// Note again that this is a hint for UI only - it should not be 
/// interpreted by any renderer as making a prim invisible to drawing.
int usd_Attribute_IsHidden(usd_Attribute_t const* _this, bool* _result);

/// Sets the value of the 'hidden' metadata field. See IsHidden()
/// for details.
int usd_Attribute_SetHidden(usd_Attribute_t const* _this, bool hidden, bool* _result);

/// Clears the opinion for "Hidden" at the current EditTarget.
int usd_Attribute_ClearHidden(usd_Attribute_t const* _this, bool* _result);

/// Returns true if hidden was explicitly authored and GetMetadata()
/// will return a meaningful value for Hidden. 
/// 
/// Note that IsHidden returns a fallback value (false) when hidden is not
/// authored.
int usd_Attribute_HasAuthoredHidden(usd_Attribute_t const* _this, bool* _result);

/// Return this object's composed customData dictionary.
/// 
/// CustomData is "custom metadata", a place for applications and users
/// to put uniform data that is entirely dynamic and subject to no schema
/// known to Usd.  Unlike metadata like 'hidden', 'displayName' etc,
/// which must be declared in code or a data file that is considered part
/// of one's Usd distribution (e.g. a plugInfo.json file) to be used,
/// customData keys and the datatypes of their corresponding values are
/// ad hoc.  No validation will ever be performed that values for the
/// same key in different layers are of the same type - strongest simply
/// wins.
/// 
/// Dictionaries like customData are composed element-wise, and are 
/// nestable.
/// 
/// There is no means to query a customData field's valuetype other
/// than fetching the value and interrogating it.
/// \sa GetCustomDataByKey()
int usd_Attribute_GetCustomData(usd_Attribute_t const* _this, vt_Dictionary_t* _result);

/// Return the element identified by \p keyPath in this object's
/// composed customData dictionary.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.  This is in general more
/// efficient than composing the entire customData dictionary and then
/// pulling out one sub-element.
int usd_Attribute_GetCustomDataByKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath, vt_Value_t* _result);

/// Author this object's customData dictionary to \p customData at
/// the current EditTarget.
int usd_Attribute_SetCustomData(usd_Attribute_t const* _this, vt_Dictionary_t const* customData);

/// Author the element identified by \p keyPath in this object's
/// customData dictionary at the current EditTarget.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Attribute_SetCustomDataByKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath, vt_Value_t const* value);

/// Clear the authored opinion for this object's customData
/// dictionary at the current EditTarget.  Do nothing if there is no such
/// authored opinion.
int usd_Attribute_ClearCustomData(usd_Attribute_t const* _this);

/// Clear the authored opinion identified by \p keyPath in this
/// object's customData dictionary at the current EditTarget.  The \p
/// keyPath is a ':'-separated path identifying a value in subdictionaries.
/// Do nothing if there is no such authored opinion.
int usd_Attribute_ClearCustomDataByKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath);

/// Return true if there are any authored or fallback opinions for
/// this object's customData dictionary, false otherwise.
int usd_Attribute_HasCustomData(usd_Attribute_t const* _this, bool* _result);

/// Return true if there are any authored or fallback opinions for
/// the element identified by \p keyPath in this object's customData
/// dictionary, false otherwise.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.
int usd_Attribute_HasCustomDataKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for this object's customData dictionary, false otherwise.
int usd_Attribute_HasAuthoredCustomData(usd_Attribute_t const* _this, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for the element identified by \p keyPath in this object's
/// customData dictionary, false otherwise.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Attribute_HasAuthoredCustomDataKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return this object's composed assetInfo dictionary.
/// 
/// The asset info dictionary is used to annotate objects representing the 
/// root-prims of assets (generally organized as models) with various 
/// data related to asset management. For example, asset name, root layer
/// identifier, asset version etc.
/// 
/// The elements of this dictionary are composed element-wise, and are 
/// nestable.
/// 
/// There is no means to query an assetInfo field's valuetype other
/// than fetching the value and interrogating it.
/// \sa GetAssetInfoByKey()
int usd_Attribute_GetAssetInfo(usd_Attribute_t const* _this, vt_Dictionary_t* _result);

/// Return the element identified by \p keyPath in this object's
/// composed assetInfo dictionary.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.  This is in general more
/// efficient than composing the entire assetInfo dictionary than 
/// pulling out one sub-element.
int usd_Attribute_GetAssetInfoByKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath, vt_Value_t* _result);

/// Author this object's assetInfo dictionary to \p assetInfo at
/// the current EditTarget.
int usd_Attribute_SetAssetInfo(usd_Attribute_t const* _this, vt_Dictionary_t const* customData);

/// Author the element identified by \p keyPath in this object's
/// assetInfo dictionary at the current EditTarget.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Attribute_SetAssetInfoByKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath, vt_Value_t const* value);

/// Clear the authored opinion for this object's assetInfo
/// dictionary at the current EditTarget.  Do nothing if there is no such
/// authored opinion.
int usd_Attribute_ClearAssetInfo(usd_Attribute_t const* _this);

/// Clear the authored opinion identified by \p keyPath in this
/// object's assetInfo dictionary at the current EditTarget.  The \p
/// keyPath is a ':'-separated path identifying a value in subdictionaries.
/// Do nothing if there is no such authored opinion.
int usd_Attribute_ClearAssetInfoByKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath);

/// Return true if there are any authored or fallback opinions for
/// this object's assetInfo dictionary, false otherwise.
int usd_Attribute_HasAssetInfo(usd_Attribute_t const* _this, bool* _result);

/// Return true if there are any authored or fallback opinions for
/// the element identified by \p keyPath in this object's assetInfo
/// dictionary, false otherwise.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.
int usd_Attribute_HasAssetInfoKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for this object's assetInfo dictionary, false otherwise.
int usd_Attribute_HasAuthoredAssetInfo(usd_Attribute_t const* _this, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for the element identified by \p keyPath in this object's
/// assetInfo dictionary, false otherwise.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Attribute_HasAuthoredAssetInfoKey(usd_Attribute_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return this object's documentation (metadata).  This returns the
/// empty string if no documentation has been set.
/// \sa SetDocumentation()
int usd_Attribute_GetDocumentation(usd_Attribute_t const* _this, std_String_t* _result);

/// Sets this object's documentation (metadata).  Returns true on success.
int usd_Attribute_SetDocumentation(usd_Attribute_t const* _this, std_String_t const* doc, bool* _result);

/// Clears this object's documentation (metadata) in the current EditTarget
/// (only).  Returns true on success.
int usd_Attribute_ClearDocumentation(usd_Attribute_t const* _this, bool* _result);

/// Returns true if documentation was explicitly authored and GetMetadata()
/// will return a meaningful value for documentation. 
int usd_Attribute_HasAuthoredDocumentation(usd_Attribute_t const* _this, bool* _result);

/// Return this object's display name (metadata).  This returns the
/// empty string if no display name has been set.
/// \sa SetDisplayName()
int usd_Attribute_GetDisplayName(usd_Attribute_t const* _this, std_String_t* _result);

/// Sets this object's display name (metadata).  Returns true on success.
/// 
/// DisplayName is meant to be a descriptive label, not necessarily an
/// alternate identifier; therefore there is no restriction on which
/// characters can appear in it.
int usd_Attribute_SetDisplayName(usd_Attribute_t const* _this, std_String_t const* name, bool* _result);

/// Clears this object's display name (metadata) in the current EditTarget
/// (only).  Returns true on success.
int usd_Attribute_ClearDisplayName(usd_Attribute_t const* _this, bool* _result);

/// Returns true if displayName was explicitly authored and GetMetadata()
/// will return a meaningful value for displayName. 
int usd_Attribute_HasAuthoredDisplayName(usd_Attribute_t const* _this, bool* _result);

/// Return true if this is a valid object, false otherwise.
int usd_Attribute_IsValid(usd_Attribute_t const* _this, bool* _result);

/// Return the stage that owns the object, and to whose state and lifetime
/// this object's validity is tied.
int usd_Attribute_GetStage(usd_Attribute_t const* _this, usd_StageWeakPtr_t* _result);

/// Return the complete scene path to this object on its UsdStage,
/// which may (UsdPrim) or may not (all other subclasses) return a 
/// cached result
int usd_Attribute_GetPath(usd_Attribute_t const* _this, sdf_Path_t* _result);

/// Return this object's path if this object is a prim, otherwise this
/// object's nearest owning prim's path.  Equivalent to GetPrim().GetPath().
int usd_Attribute_GetPrimPath(usd_Attribute_t const* _this, sdf_Path_t const** _result);

/// /////////////////////////////////////////////////////////////////////
int usd_Attribute_GetPrim(usd_Attribute_t const* _this, usd_Prim_t* _result);

/// Return the full name of this object, i.e. the last component of its
/// SdfPath in namespace.
/// 
/// This is equivalent to, but generally cheaper than,
/// GetPath().GetNameToken()
int usd_Attribute_GetName(usd_Attribute_t const* _this, tf_Token_t const** _result);

/// @}
int usd_Attribute_GetNamespaceDelimiter(char* _result);

/// Return a string that provides a brief summary description of the
/// object.  This method, along with IsValid()/bool_operator,
/// is always safe to call on a possibly-expired object, and the 
/// description will specify whether the object is valid or expired,
/// along with a few other bits of data.
int usd_Attribute_GetDescription(usd_Attribute_t const* _this, std_String_t* _result);

int usd_Attribute_default(usd_Attribute_t** _result);

int usd_Attribute_dtor(usd_Attribute_t* _this);

/// Return the attribute associated with this query.
int usd_AttributeQuery_GetAttribute(usd_AttributeQuery_t const* _this, usd_Attribute_t const** _result);

/// Return true if this query is valid (i.e. it is associated with a
/// valid attribute), false otherwise.
int usd_AttributeQuery_IsValid(usd_AttributeQuery_t const* _this, bool* _result);

/// \overload
/// Type-erased access, often not as efficient as typed access.
int usd_AttributeQuery_Get_value(usd_AttributeQuery_t const* _this, vt_Value_t* value, usd_TimeCode_t time, bool* _result);

/// Behaves identically to UsdAttribute::GetTimeSamples()
/// 
/// \sa UsdAttributeQuery::GetTimeSamplesInInterval
int usd_AttributeQuery_GetTimeSamples(usd_AttributeQuery_t const* _this, std_DoubleVector_t* times, bool* _result);

/// Populates a vector with authored sample times in \p interval.
/// Returns false only on an error.
/// 
/// Behaves identically to UsdAttribute::GetTimeSamplesInInterval()
int usd_AttributeQuery_GetTimeSamplesInInterval(usd_AttributeQuery_t const* _this, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

/// Returns the number of time samples that have been authored.
/// 
/// \sa UsdAttribute::GetNumTimeSamples
int usd_AttributeQuery_GetNumTimeSamples(usd_AttributeQuery_t const* _this, size_t* _result);

/// Populate \a lower and \a upper with the next greater and lesser
/// value relative to the \a desiredTime.
/// 
/// \sa UsdAttribute::GetBracketingTimeSamples
int usd_AttributeQuery_GetBracketingTimeSamples(usd_AttributeQuery_t const* _this, double desiredTime, double* lower, double* upper, bool* hasTimeSamples, bool* _result);

/// Return true if the attribute associated with this query has an 
/// authored default value, authored time samples or a fallback value 
/// provided by a registered schema.
/// 
/// \sa UsdAttribute::HasValue
int usd_AttributeQuery_HasValue(usd_AttributeQuery_t const* _this, bool* _result);

/// \deprecated This method is deprecated because it returns `true` even when
/// an attribute is blocked.  Please use HasAuthoredValue() instead. If 
/// you truly need to know whether the attribute has **any** authored
/// value opinions, *including blocks*, you can make the following query:
/// `query.GetAttribute().GetResolveInfo().HasAuthoredValueOpinion()`
/// 
/// 
/// Return true if this attribute has either an authored default value or
/// authored time samples.
int usd_AttributeQuery_HasAuthoredValueOpinion(usd_AttributeQuery_t const* _this, bool* _result);

/// Return true if this attribute has either an authored default value or
/// authored time samples.  If the attribute has been 
/// \ref Usd_AttributeBlocking "blocked", then return `false`
/// \sa UsdAttribute::HasAuthoredValue()
int usd_AttributeQuery_HasAuthoredValue(usd_AttributeQuery_t const* _this, bool* _result);

/// Return true if the attribute associated with this query has a 
/// fallback value provided by a registered schema.
/// 
/// \sa UsdAttribute::HasFallbackValue
int usd_AttributeQuery_HasFallbackValue(usd_AttributeQuery_t const* _this, bool* _result);

/// Return true if it is possible, but not certain, that this attribute's
/// value changes over time, false otherwise. 
/// 
/// \sa UsdAttribute::ValueMightBeTimeVarying
int usd_AttributeQuery_ValueMightBeTimeVarying(usd_AttributeQuery_t const* _this, bool* _result);

/// Populates the given vector, \p times with the union of all the 
/// authored sample times on all of the given attribute-query objects, 
/// \p attrQueries.
/// 
/// Behaves identically to UsdAttribute::GetUnionedTimeSamples()
/// 
/// \return false if one or more attribute-queries in \p attrQueries are 
/// invalid or if there's an error fetching time-samples for any of 
/// the attribute-query objects.
/// 
/// \sa UsdAttribute::GetUnionedTimeSamples
/// \sa UsdAttributeQuery::GetUnionedTimeSamplesInInterval
int usd_AttributeQuery_GetUnionedTimeSamples(usd_AttributeQueryVector_t const* attrQueries, std_DoubleVector_t* times, bool* _result);

/// Populates the given vector, \p times with the union of all the 
/// authored sample times in the GfInterval, \p interval on all of the 
/// given attribute-query objects, \p attrQueries.
/// 
/// Behaves identically to UsdAttribute::GetUnionedTimeSamplesInInterval()
/// 
/// \return false if one or more attribute-queries in \p attrQueries are 
/// invalid or if there's an error fetching time-samples for any of 
/// the attribute-query objects.
/// 
/// \sa UsdAttribute::GetUnionedTimeSamplesInInterval
int usd_AttributeQuery_GetUnionedTimeSamplesInInterval(usd_AttributeQueryVector_t const* attrQueries, gf_Interval_t const* interval, std_DoubleVector_t* times, bool* _result);

int usd_AttributeQuery_from_attribute_and_resolve_target(usd_AttributeQuery_t** _result);

int usd_AttributeQuery_from_prim_and_attribute_name(usd_AttributeQuery_t** _result);

int usd_AttributeQuery_default(usd_AttributeQuery_t** _result);

int usd_AttributeQuery_dtor(usd_AttributeQuery_t* _this);

int usd_AttributeQueryVector_data(usd_AttributeQueryVector_t* _this, usd_AttributeQuery_t** _result);

int usd_AttributeQueryVector_data_const(usd_AttributeQueryVector_t const* _this, usd_AttributeQuery_t const** _result);

int usd_AttributeQueryVector_empty(usd_AttributeQueryVector_t const* _this, bool* _result);

int usd_AttributeQueryVector_size(usd_AttributeQueryVector_t const* _this, size_t* _result);

int usd_AttributeQueryVector_max_size(usd_AttributeQueryVector_t const* _this, size_t* _result);

int usd_AttributeQueryVector_reserve(usd_AttributeQueryVector_t* _this, size_t const _Newcapacity);

int usd_AttributeQueryVector_capacity(usd_AttributeQueryVector_t const* _this, size_t* _result);

int usd_AttributeQueryVector_clear(usd_AttributeQueryVector_t* _this);

int usd_AttributeQueryVector_push_back(usd_AttributeQueryVector_t* _this, usd_AttributeQuery_t const* _Val);

int usd_AttributeQueryVector_pop_back(usd_AttributeQueryVector_t* _this);

int usd_AttributeQueryVector_resize(usd_AttributeQueryVector_t* _this, size_t const _Newsize);

int usd_AttributeQueryVector_resize_with(usd_AttributeQueryVector_t* _this, size_t const _Newsize, usd_AttributeQuery_t const* _Val);

int usd_AttributeQueryVector_op_index(usd_AttributeQueryVector_t const* _this, size_t const _Pos, usd_AttributeQuery_t const** _result);

int usd_AttributeQueryVector_default(usd_AttributeQueryVector_t** _result);

int usd_AttributeQueryVector_dtor(usd_AttributeQueryVector_t* _this);

int usd_AttributeVector_data(usd_AttributeVector_t* _this, usd_Attribute_t** _result);

int usd_AttributeVector_data_const(usd_AttributeVector_t const* _this, usd_Attribute_t const** _result);

int usd_AttributeVector_empty(usd_AttributeVector_t const* _this, bool* _result);

int usd_AttributeVector_size(usd_AttributeVector_t const* _this, size_t* _result);

int usd_AttributeVector_max_size(usd_AttributeVector_t const* _this, size_t* _result);

int usd_AttributeVector_reserve(usd_AttributeVector_t* _this, size_t const _Newcapacity);

int usd_AttributeVector_capacity(usd_AttributeVector_t const* _this, size_t* _result);

int usd_AttributeVector_clear(usd_AttributeVector_t* _this);

int usd_AttributeVector_push_back(usd_AttributeVector_t* _this, usd_Attribute_t const* _Val);

int usd_AttributeVector_pop_back(usd_AttributeVector_t* _this);

int usd_AttributeVector_resize(usd_AttributeVector_t* _this, size_t const _Newsize);

int usd_AttributeVector_resize_with(usd_AttributeVector_t* _this, size_t const _Newsize, usd_Attribute_t const* _Val);

int usd_AttributeVector_op_index(usd_AttributeVector_t const* _this, size_t const _Pos, usd_Attribute_t const** _result);

int usd_AttributeVector_default(usd_AttributeVector_t** _result);

int usd_AttributeVector_dtor(usd_AttributeVector_t* _this);

/// Equality comparison.
int usd_EditTarget_op_eq(usd_EditTarget_t const* _this, usd_EditTarget_t const* other, bool* _result);

/// Return true if this EditTarget is null.  Null EditTargets map
/// paths unchanged, and have no layer or LayerStack identifier.
int usd_EditTarget_IsNull(usd_EditTarget_t const* _this, bool* _result);

/// Return true if this EditTarget is valid, false otherwise.  Edit
/// targets are considered valid when they have a layer.
int usd_EditTarget_IsValid(usd_EditTarget_t const* _this, bool* _result);

/// Return the layer this EditTarget contains.
int usd_EditTarget_GetLayer(usd_EditTarget_t const* _this, sdf_LayerHandle_t const** _result);

/// Map the provided \a scenePath into a SdfSpec path for the
/// EditTarget's layer, according to the EditTarget's mapping.  Null edit
/// targets and EditTargets for which \a IsLocalLayer are true return
/// scenePath unchanged.
int usd_EditTarget_MapToSpecPath(usd_EditTarget_t const* _this, sdf_Path_t const* scenePath, sdf_Path_t* _result);

/// Convenience function for getting the PrimSpec in the edit
/// target's layer for \a scenePath.  This is equivalent to
/// target.GetLayer()->GetPrimAtPath(target.MapToSpecPath(scenePath)) if
/// target has a valid layer.  If this target IsNull or there is no valid
/// mapping from \a scenePath to a SdfPrimSpec path in the layer, return
/// null.
int usd_EditTarget_GetPrimSpecForScenePath(usd_EditTarget_t const* _this, sdf_Path_t const* scenePath, sdf_PrimSpecHandle_t* _result);

int usd_EditTarget_GetPropertySpecForScenePath(usd_EditTarget_t const* _this, sdf_Path_t const* scenePath, sdf_PropertySpecHandle_t* _result);

int usd_EditTarget_GetSpecForScenePath(usd_EditTarget_t const* _this, sdf_Path_t const* scenePath, sdf_SpecHandle_t* _result);

/// Returns the PcpMapFunction representing the map from source
/// specs (including any variant selections) to the stage.
int usd_EditTarget_GetMapFunction(usd_EditTarget_t const* _this, pcp_MapFunction_t const** _result);

/// Return a new EditTarget composed over \a weaker.  This is
/// typically used to make an EditTarget "explicit".  For example, an edit
/// target with a layer but with no mapping and no LayerStack identifier
/// indicates a layer in the local LayerStack of a composed scene.
/// However, an EditTarget with the same layer but an explicit identity
/// mapping and the LayerStack identifier of the composed scene may be
/// desired.  This can be obtained by composing a partial (e.g. layer only)
/// EditTarget over an explicit EditTarget with layer, mapping and layer
/// stack identifier.
int usd_EditTarget_ComposeOver(usd_EditTarget_t const* _this, usd_EditTarget_t const* weaker, usd_EditTarget_t* _result);

/// Convenience constructor for editing a direct variant in a local
/// LayerStack.  The \p varSelPath must be a prim variant selection path
/// (see SdfPath::IsPrimVariantSelectionPath()).
int usd_EditTarget_ForLocalDirectVariant(sdf_LayerHandle_t const* layer, sdf_Path_t const* varSelPath, usd_EditTarget_t* _result);

int usd_EditTarget_from_layer_and_node(usd_EditTarget_t** _result);

int usd_EditTarget_from_layer(usd_EditTarget_t** _result);

int usd_EditTarget_default(usd_EditTarget_t** _result);

int usd_EditTarget_dtor(usd_EditTarget_t* _this);

/// Adds a path to the inheritPaths listOp at the current EditTarget,
/// in the position specified by \p position.
int usd_Inherits_AddInherit(usd_Inherits_t* _this, sdf_Path_t const* primPath, int position, bool* _result);

/// Removes the specified path from the inheritPaths listOp at the
/// current EditTarget.
int usd_Inherits_RemoveInherit(usd_Inherits_t* _this, sdf_Path_t const* primPath, bool* _result);

/// Removes the authored inheritPaths listOp edits at the current edit
/// target.
int usd_Inherits_ClearInherits(usd_Inherits_t* _this, bool* _result);

/// Explicitly set the inherited paths, potentially blocking weaker opinions
/// that add or remove items, returning true on success, false if the edit
/// could not be performed.
int usd_Inherits_SetInherits(usd_Inherits_t* _this, sdf_PathVector_t const* items, bool* _result);

/// Return all the paths in this prim's stage's local layer stack that would
/// compose into this prim via direct inherits (excluding prim specs that
/// would be composed into this prim due to inherits authored on ancestral
/// prims) in strong-to-weak order.
/// 
/// Note that there currently may not be any scene description at these
/// paths on the stage.  This returns all the potential places that such
/// opinions could appear.
int usd_Inherits_GetAllDirectInherits(usd_Inherits_t const* _this, sdf_PathVector_t* _result);

/// Return the prim this object is bound to.
int usd_Inherits_GetPrim(usd_Inherits_t const* _this, usd_Prim_t const** _result);

int usd_Inherits_dtor(usd_Inherits_t* _this);

int usd_MetadataValueMap_at_const(usd_MetadataValueMap_t const* _this, tf_Token_t const* _Keyval, vt_Value_t const** _result);

int usd_MetadataValueMap_at(usd_MetadataValueMap_t* _this, tf_Token_t const* _Keyval, vt_Value_t** _result);

int usd_MetadataValueMap_dtor(usd_MetadataValueMap_t* _this);

int usd_Object_Is_Attribute(usd_Object_t const* _this, bool* _result);

int usd_Object_Is_Relationship(usd_Object_t const* _this, bool* _result);

int usd_Object_Is_Property(usd_Object_t const* _this, bool* _result);

int usd_Object_Is_Prim(usd_Object_t const* _this, bool* _result);

int usd_Object_As_Attribute(usd_Object_t const* _this, usd_Attribute_t* _result);

int usd_Object_As_Relationship(usd_Object_t const* _this, usd_Relationship_t* _result);

int usd_Object_As_Property(usd_Object_t const* _this, usd_Property_t* _result);

int usd_Object_As_Prim(usd_Object_t const* _this, usd_Prim_t* _result);

/// \overload
/// 
/// Type-erased access
int usd_Object_GetMetadata_value(usd_Object_t const* _this, tf_Token_t const* key, vt_Value_t* value, bool* _result);

/// \overload
int usd_Object_SetMetadata_value(usd_Object_t const* _this, tf_Token_t const* key, vt_Value_t const* value, bool* _result);

/// Clears the authored \a key's value at the current EditTarget,
/// returning false on error.
/// 
/// If no value is present, this method is a no-op and returns true. It is
/// considered an error to call ClearMetadata when no spec is present for 
/// this UsdObject, i.e. if the object has no presence in the
/// current UsdEditTarget.
/// 
/// \sa \ref Usd_OM_Metadata
int usd_Object_ClearMetadata(usd_Object_t const* _this, tf_Token_t const* key, bool* _result);

/// Returns true if the \a key has a meaningful value, that is, if
/// GetMetadata() will provide a value, either because it was authored
/// or because a prim's metadata fallback will be provided.
int usd_Object_HasMetadata(usd_Object_t const* _this, tf_Token_t const* key, bool* _result);

/// Returns true if the \a key has an authored value, false if no
/// value was authored or the only value available is a prim's metadata 
/// fallback.
int usd_Object_HasAuthoredMetadata(usd_Object_t const* _this, tf_Token_t const* key, bool* _result);

/// \overload
int usd_Object_GetMetadataByDictKey_value(usd_Object_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t* value, bool* _result);

/// \overload
int usd_Object_SetMetadataByDictKey_value(usd_Object_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t const* value, bool* _result);

/// Clear any authored value identified by \p key and \p keyPath
/// at the current EditTarget.  The \p keyPath is a ':'-separated path
/// identifying a path in subdictionaries stored in the metadata field at
/// \p key.  Return true if the value is cleared successfully, false
/// otherwise.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Object_ClearMetadataByDictKey(usd_Object_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Return true if there exists any authored or fallback opinion for
/// \p key and \p keyPath.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries stored in the metadata field at
/// \p key.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Object_HasMetadataDictKey(usd_Object_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Return true if there exists any authored opinion (excluding
/// fallbacks) for \p key and \p keyPath.  The \p keyPath is a ':'-separated
/// path identifying a value in subdictionaries stored in the metadata field
/// at \p key.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Object_HasAuthoredMetadataDictKey(usd_Object_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Resolve and return all metadata (including both authored and
/// fallback values) on this object, sorted lexicographically.
/// 
/// \note This method does not return field keys for composition arcs,
/// such as references, inherits, payloads, sublayers, variants, or
/// primChildren, nor does it return the default value or timeSamples.
int usd_Object_GetAllMetadata(usd_Object_t const* _this, usd_MetadataValueMap_t* _result);

/// Resolve and return all user-authored metadata on this object,
/// sorted lexicographically.
/// 
/// \note This method does not return field keys for composition arcs,
/// such as references, inherits, payloads, sublayers, variants, or
/// primChildren, nor does it return the default value or timeSamples.
int usd_Object_GetAllAuthoredMetadata(usd_Object_t const* _this, usd_MetadataValueMap_t* _result);

/// Gets the value of the 'hidden' metadata field, false if not 
/// authored.
/// 
/// When an object is marked as hidden, it is an indicator to clients who 
/// generically display objects (such as GUI widgets) that this object 
/// should not be included, unless explicitly asked for.  Although this
/// is just a hint and thus up to each application to interpret, we
/// use it primarily as a way of simplifying hierarchy displays, by
/// hiding \em only the representation of the object itself, \em not its
/// subtree, instead "pulling up" everything below it one level in the
/// hierarchical nesting.
/// 
/// Note again that this is a hint for UI only - it should not be 
/// interpreted by any renderer as making a prim invisible to drawing.
int usd_Object_IsHidden(usd_Object_t const* _this, bool* _result);

/// Sets the value of the 'hidden' metadata field. See IsHidden()
/// for details.
int usd_Object_SetHidden(usd_Object_t const* _this, bool hidden, bool* _result);

/// Clears the opinion for "Hidden" at the current EditTarget.
int usd_Object_ClearHidden(usd_Object_t const* _this, bool* _result);

/// Returns true if hidden was explicitly authored and GetMetadata()
/// will return a meaningful value for Hidden. 
/// 
/// Note that IsHidden returns a fallback value (false) when hidden is not
/// authored.
int usd_Object_HasAuthoredHidden(usd_Object_t const* _this, bool* _result);

/// Return this object's composed customData dictionary.
/// 
/// CustomData is "custom metadata", a place for applications and users
/// to put uniform data that is entirely dynamic and subject to no schema
/// known to Usd.  Unlike metadata like 'hidden', 'displayName' etc,
/// which must be declared in code or a data file that is considered part
/// of one's Usd distribution (e.g. a plugInfo.json file) to be used,
/// customData keys and the datatypes of their corresponding values are
/// ad hoc.  No validation will ever be performed that values for the
/// same key in different layers are of the same type - strongest simply
/// wins.
/// 
/// Dictionaries like customData are composed element-wise, and are 
/// nestable.
/// 
/// There is no means to query a customData field's valuetype other
/// than fetching the value and interrogating it.
/// \sa GetCustomDataByKey()
int usd_Object_GetCustomData(usd_Object_t const* _this, vt_Dictionary_t* _result);

/// Return the element identified by \p keyPath in this object's
/// composed customData dictionary.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.  This is in general more
/// efficient than composing the entire customData dictionary and then
/// pulling out one sub-element.
int usd_Object_GetCustomDataByKey(usd_Object_t const* _this, tf_Token_t const* keyPath, vt_Value_t* _result);

/// Author this object's customData dictionary to \p customData at
/// the current EditTarget.
int usd_Object_SetCustomData(usd_Object_t const* _this, vt_Dictionary_t const* customData);

/// Author the element identified by \p keyPath in this object's
/// customData dictionary at the current EditTarget.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Object_SetCustomDataByKey(usd_Object_t const* _this, tf_Token_t const* keyPath, vt_Value_t const* value);

/// Clear the authored opinion for this object's customData
/// dictionary at the current EditTarget.  Do nothing if there is no such
/// authored opinion.
int usd_Object_ClearCustomData(usd_Object_t const* _this);

/// Clear the authored opinion identified by \p keyPath in this
/// object's customData dictionary at the current EditTarget.  The \p
/// keyPath is a ':'-separated path identifying a value in subdictionaries.
/// Do nothing if there is no such authored opinion.
int usd_Object_ClearCustomDataByKey(usd_Object_t const* _this, tf_Token_t const* keyPath);

/// Return true if there are any authored or fallback opinions for
/// this object's customData dictionary, false otherwise.
int usd_Object_HasCustomData(usd_Object_t const* _this, bool* _result);

/// Return true if there are any authored or fallback opinions for
/// the element identified by \p keyPath in this object's customData
/// dictionary, false otherwise.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.
int usd_Object_HasCustomDataKey(usd_Object_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for this object's customData dictionary, false otherwise.
int usd_Object_HasAuthoredCustomData(usd_Object_t const* _this, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for the element identified by \p keyPath in this object's
/// customData dictionary, false otherwise.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Object_HasAuthoredCustomDataKey(usd_Object_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return this object's composed assetInfo dictionary.
/// 
/// The asset info dictionary is used to annotate objects representing the 
/// root-prims of assets (generally organized as models) with various 
/// data related to asset management. For example, asset name, root layer
/// identifier, asset version etc.
/// 
/// The elements of this dictionary are composed element-wise, and are 
/// nestable.
/// 
/// There is no means to query an assetInfo field's valuetype other
/// than fetching the value and interrogating it.
/// \sa GetAssetInfoByKey()
int usd_Object_GetAssetInfo(usd_Object_t const* _this, vt_Dictionary_t* _result);

/// Return the element identified by \p keyPath in this object's
/// composed assetInfo dictionary.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.  This is in general more
/// efficient than composing the entire assetInfo dictionary than 
/// pulling out one sub-element.
int usd_Object_GetAssetInfoByKey(usd_Object_t const* _this, tf_Token_t const* keyPath, vt_Value_t* _result);

/// Author this object's assetInfo dictionary to \p assetInfo at
/// the current EditTarget.
int usd_Object_SetAssetInfo(usd_Object_t const* _this, vt_Dictionary_t const* customData);

/// Author the element identified by \p keyPath in this object's
/// assetInfo dictionary at the current EditTarget.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Object_SetAssetInfoByKey(usd_Object_t const* _this, tf_Token_t const* keyPath, vt_Value_t const* value);

/// Clear the authored opinion for this object's assetInfo
/// dictionary at the current EditTarget.  Do nothing if there is no such
/// authored opinion.
int usd_Object_ClearAssetInfo(usd_Object_t const* _this);

/// Clear the authored opinion identified by \p keyPath in this
/// object's assetInfo dictionary at the current EditTarget.  The \p
/// keyPath is a ':'-separated path identifying a value in subdictionaries.
/// Do nothing if there is no such authored opinion.
int usd_Object_ClearAssetInfoByKey(usd_Object_t const* _this, tf_Token_t const* keyPath);

/// Return true if there are any authored or fallback opinions for
/// this object's assetInfo dictionary, false otherwise.
int usd_Object_HasAssetInfo(usd_Object_t const* _this, bool* _result);

/// Return true if there are any authored or fallback opinions for
/// the element identified by \p keyPath in this object's assetInfo
/// dictionary, false otherwise.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.
int usd_Object_HasAssetInfoKey(usd_Object_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for this object's assetInfo dictionary, false otherwise.
int usd_Object_HasAuthoredAssetInfo(usd_Object_t const* _this, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for the element identified by \p keyPath in this object's
/// assetInfo dictionary, false otherwise.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Object_HasAuthoredAssetInfoKey(usd_Object_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return this object's documentation (metadata).  This returns the
/// empty string if no documentation has been set.
/// \sa SetDocumentation()
int usd_Object_GetDocumentation(usd_Object_t const* _this, std_String_t* _result);

/// Sets this object's documentation (metadata).  Returns true on success.
int usd_Object_SetDocumentation(usd_Object_t const* _this, std_String_t const* doc, bool* _result);

/// Clears this object's documentation (metadata) in the current EditTarget
/// (only).  Returns true on success.
int usd_Object_ClearDocumentation(usd_Object_t const* _this, bool* _result);

/// Returns true if documentation was explicitly authored and GetMetadata()
/// will return a meaningful value for documentation. 
int usd_Object_HasAuthoredDocumentation(usd_Object_t const* _this, bool* _result);

/// Return this object's display name (metadata).  This returns the
/// empty string if no display name has been set.
/// \sa SetDisplayName()
int usd_Object_GetDisplayName(usd_Object_t const* _this, std_String_t* _result);

/// Sets this object's display name (metadata).  Returns true on success.
/// 
/// DisplayName is meant to be a descriptive label, not necessarily an
/// alternate identifier; therefore there is no restriction on which
/// characters can appear in it.
int usd_Object_SetDisplayName(usd_Object_t const* _this, std_String_t const* name, bool* _result);

/// Clears this object's display name (metadata) in the current EditTarget
/// (only).  Returns true on success.
int usd_Object_ClearDisplayName(usd_Object_t const* _this, bool* _result);

/// Returns true if displayName was explicitly authored and GetMetadata()
/// will return a meaningful value for displayName. 
int usd_Object_HasAuthoredDisplayName(usd_Object_t const* _this, bool* _result);

/// Return true if this is a valid object, false otherwise.
int usd_Object_IsValid(usd_Object_t const* _this, bool* _result);

/// Return the stage that owns the object, and to whose state and lifetime
/// this object's validity is tied.
int usd_Object_GetStage(usd_Object_t const* _this, usd_StageWeakPtr_t* _result);

/// Return the complete scene path to this object on its UsdStage,
/// which may (UsdPrim) or may not (all other subclasses) return a 
/// cached result
int usd_Object_GetPath(usd_Object_t const* _this, sdf_Path_t* _result);

/// Return this object's path if this object is a prim, otherwise this
/// object's nearest owning prim's path.  Equivalent to GetPrim().GetPath().
int usd_Object_GetPrimPath(usd_Object_t const* _this, sdf_Path_t const** _result);

/// /////////////////////////////////////////////////////////////////////
int usd_Object_GetPrim(usd_Object_t const* _this, usd_Prim_t* _result);

/// Return the full name of this object, i.e. the last component of its
/// SdfPath in namespace.
/// 
/// This is equivalent to, but generally cheaper than,
/// GetPath().GetNameToken()
int usd_Object_GetName(usd_Object_t const* _this, tf_Token_t const** _result);

/// @}
int usd_Object_GetNamespaceDelimiter(char* _result);

/// Return a string that provides a brief summary description of the
/// object.  This method, along with IsValid()/bool_operator,
/// is always safe to call on a possibly-expired object, and the 
/// description will specify whether the object is valid or expired,
/// along with a few other bits of data.
int usd_Object_GetDescription(usd_Object_t const* _this, std_String_t* _result);

int usd_Object_default(usd_Object_t** _result);

int usd_Object_dtor(usd_Object_t* _this);

int usd_ObjectSet_default(usd_ObjectSet_t** _result);

int usd_ObjectSet_dtor(usd_ObjectSet_t* _this);

/// Adds a payload to the payload listOp at the current EditTarget, in the
/// position specified by \p position. 
/// \sa \ref Usd_Failing_References "Why adding references may fail" for
/// explanation of expectations on \p payload and what return values and 
/// errors to expect, and \ref Usd_OM_ListOps for details on list editing 
/// and composition of listOps. 
int usd_Payloads_AddPayload(usd_Payloads_t* _this, sdf_Payload_t const* payload, int position, bool* _result);

/// \overload 
int usd_Payloads_AddPayload_with_identifier_and_path(usd_Payloads_t* _this, std_String_t const* identifier, sdf_Path_t const* primPath, sdf_LayerOffset_t const* layerOffset, int position, bool* _result);

/// \overload
/// \sa \ref Usd_DefaultPrim_References "Payloads Without Prim Paths"
int usd_Payloads_AddPayload_with_identifier(usd_Payloads_t* _this, std_String_t const* identifier, sdf_LayerOffset_t const* layerOffset, int position, bool* _result);

/// Add an internal payload to the specified prim.
/// \sa \ref Usd_Internal_References "Internal Payloads"
int usd_Payloads_AddInternalPayload(usd_Payloads_t* _this, sdf_Path_t const* primPath, sdf_LayerOffset_t const* layerOffset, int position, bool* _result);

/// Removes the specified payload from the payloads listOp at the
/// current EditTarget.  This does not necessarily eliminate the payload 
/// completely, as it may be added or set in another layer in the same 
/// LayerStack as the current EditTarget. 
/// \sa \ref Usd_OM_ListOps 
int usd_Payloads_RemovePayload(usd_Payloads_t* _this, sdf_Payload_t const* ref, bool* _result);

/// Removes the authored payload listOp edits at the current EditTarget.
/// The same caveats for Remove() apply to Clear().  In fact, Clear() may
/// actually increase the number of composed payloads, if the listOp being 
/// cleared contained the "remove" operator. 
/// \sa \ref Usd_OM_ListOps 
int usd_Payloads_ClearPayloads(usd_Payloads_t* _this, bool* _result);

/// Explicitly set the payloads, potentially blocking weaker opinions that 
/// add or remove items. 
/// \sa \ref Usd_Failing_References "Why adding payloads may fail" for
/// explanation of expectations on \p items and what return values and 
/// errors to expect, and \ref Usd_OM_ListOps for details on list editing 
/// and composition of listOps. 
int usd_Payloads_SetPayloads(usd_Payloads_t* _this, sdf_PayloadVector_t const* items, bool* _result);

/// Return the prim this object is bound to.
int usd_Payloads_GetPrim(usd_Payloads_t const* _this, usd_Prim_t const** _result);

int usd_Payloads_dtor(usd_Payloads_t* _this);

int usd_Property_Is_Attribute(usd_Property_t const* _this, bool* _result);

int usd_Property_Is_Relationship(usd_Property_t const* _this, bool* _result);

int usd_Property_Is_Property(usd_Property_t const* _this, bool* _result);

int usd_Property_Is_Prim(usd_Property_t const* _this, bool* _result);

int usd_Property_As_Attribute(usd_Property_t const* _this, usd_Attribute_t* _result);

int usd_Property_As_Relationship(usd_Property_t const* _this, usd_Relationship_t* _result);

int usd_Property_As_Property(usd_Property_t const* _this, usd_Property_t* _result);

int usd_Property_As_Prim(usd_Property_t const* _this, usd_Prim_t* _result);

/// Returns a strength-ordered list of property specs that provide
/// opinions for this property.
/// 
/// If \p time is UsdTimeCode::Default(), *or* this property 
/// is a UsdRelationship (which are never affected by clips), we will 
/// not consider value clips for opinions. For any other \p time, for 
/// a UsdAttribute, clips whose samples may contribute an opinion will 
/// be included. These specs are ordered from strongest to weakest opinion, 
/// although if \p time requires interpolation between two adjacent clips, 
/// both clips will appear, sequentially.
/// 
/// \note The results returned by this method are meant for debugging
/// and diagnostic purposes.  It is **not** advisable to retain a 
/// PropertyStack for the purposes of expedited value resolution for 
/// properties, since the makeup of an attribute's PropertyStack may
/// itself be time-varying.  To expedite repeated value resolution of
/// attributes, you should instead retain a \c UsdAttributeQuery .
/// 
/// \sa UsdClipsAPI
int usd_Property_GetPropertyStack(usd_Property_t const* _this, usd_TimeCode_t time, sdf_PropertySpecHandleVector_t* _result);

/// Returns a strength-ordered list of property specs that provide
/// opinions for this property paired with the cumulative layer offset from
/// the stage's root layer to the layer containing the property spec.
/// 
/// This behaves exactly the same as UsdProperty::GetPropertyStack with the 
/// addition of providing the cumulative layer offset of each spec's layer.
/// 
/// \note The results returned by this method are meant for debugging
/// and diagnostic purposes.  It is **not** advisable to retain a 
/// PropertyStack for the purposes of expedited value resolution for 
/// properties, since the makeup of an attribute's PropertyStack may
/// itself be time-varying.  To expedite repeated value resolution of
/// attributes, you should instead retain a \c UsdAttributeQuery .
int usd_Property_GetPropertyStackWithLayerOffsets(usd_Property_t const* _this, usd_TimeCode_t time, sdf_PropertySpecHandleOffsetPairVector_t* _result);

/// Return this property's name with all namespace prefixes removed,
/// i.e. the last component of the return value of GetName()
/// 
/// This is generally the property's "client name"; property namespaces are
/// often used to group related properties together.  The namespace prefixes
/// the property name but many consumers will care only about un-namespaced
/// name, i.e. its BaseName.  For more information, see \ref Usd_Ordering
int usd_Property_GetBaseName(usd_Property_t const* _this, tf_Token_t* _result);

/// Return this property's complete namespace prefix.  Return the empty
/// token if this property has no namespaces.
/// 
/// This is the complement of GetBaseName(), although it does \em not
/// contain a trailing namespace delimiter
int usd_Property_GetNamespace(usd_Property_t const* _this, tf_Token_t* _result);

/// Return this property's name elements including namespaces and its base
/// name as the final element.
int usd_Property_SplitName(usd_Property_t const* _this, std_StringVector_t* _result);

/// Return this property's display group (metadata).  This returns the
/// empty token if no display group has been set.
/// \sa SetDisplayGroup()
int usd_Property_GetDisplayGroup(usd_Property_t const* _this, std_String_t* _result);

/// Sets this property's display group (metadata).  Returns true on success.
/// 
/// DisplayGroup provides UI hinting for grouping related properties
/// together for display.  We define a convention for specifying nesting
/// of groups by recognizing the property namespace separator in 
/// displayGroup as denoting group-nesting.
/// \sa SetNestedDisplayGroups()
int usd_Property_SetDisplayGroup(usd_Property_t const* _this, std_String_t const* displayGroup, bool* _result);

/// Clears this property's display group (metadata) in
/// the current EditTarget (only).  Returns true on success.
int usd_Property_ClearDisplayGroup(usd_Property_t const* _this, bool* _result);

/// Returns true if displayGroup was explicitly authored and GetMetadata()
/// will return a meaningful value for displayGroup. 
int usd_Property_HasAuthoredDisplayGroup(usd_Property_t const* _this, bool* _result);

/// Return this property's displayGroup as a sequence of groups to be
/// nested, or an empty vector if displayGroup is empty or not authored.
int usd_Property_GetNestedDisplayGroups(usd_Property_t const* _this, std_StringVector_t* _result);

/// Sets this property's display group (metadata) to the nested sequence.  
/// Returns true on success.
/// 
/// A displayGroup set with this method can still be retrieved with
/// GetDisplayGroup(), with the namespace separator embedded in the result.
/// If \p nestedGroups is empty, we author an empty string for displayGroup.
/// \sa SetDisplayGroup()
int usd_Property_SetNestedDisplayGroups(usd_Property_t const* _this, std_StringVector_t const* nestedGroups, bool* _result);

/// Return true if this is a custom property (i.e., not part of a
/// prim schema).
/// 
/// The 'custom' modifier in USD serves the same function as Alembic's
/// 'userProperties', which is to say as a categorization for ad hoc
/// client data not formalized into any schema, and therefore not 
/// carrying an expectation of specific processing by consuming applications.
int usd_Property_IsCustom(usd_Property_t const* _this, bool* _result);

/// Set the value for custom at the current EditTarget, return true on
/// success, false if the value can not be written.
/// 
/// \b Note that this value should not be changed as it is typically either
/// automatically authored or provided by a property definition. This method
/// is provided primarily for fixing invalid scene description.
int usd_Property_SetCustom(usd_Property_t const* _this, bool isCustom, bool* _result);

/// Return true if this is a builtin property or if the strongest
/// authored SdfPropertySpec for this property's path matches this
/// property's dynamic type.  That is, SdfRelationshipSpec in case this is a
/// UsdRelationship, and SdfAttributeSpec in case this is a UsdAttribute.
/// Return \c false if this property's prim has expired.
/// 
/// For attributes, a \c true return does not imply that this attribute
/// possesses a value, only that has been declared, is of a certain type and
/// variability, and that it is safe to use to query and author values and
/// metadata.
int usd_Property_IsDefined(usd_Property_t const* _this, bool* _result);

/// Return true if there are any authored opinions for this property
/// in any layer that contributes to this stage, false otherwise.
int usd_Property_IsAuthored(usd_Property_t const* _this, bool* _result);

/// Return true if there is an SdfPropertySpec authored for this
/// property at the given \a editTarget, otherwise return false.  Note
/// that this method does not do partial composition.  It does not consider
/// whether authored scene description exists at \a editTarget or weaker,
/// only <b>exactly at</b> the given \a editTarget.
int usd_Property_IsAuthoredAt(usd_Property_t const* _this, usd_EditTarget_t const* editTarget, bool* _result);

/// Flattens this property to a property spec with the same name 
/// beneath the given \p parent prim in the edit target of its owning stage.
/// 
/// The \p parent prim may belong to a different stage than this property's 
/// owning stage.
/// 
/// Flattening authors all authored resolved values and metadata for 
/// this property into the destination property spec. If this property
/// is a builtin property, fallback values and metadata will also be
/// authored if the destination property has a different fallback 
/// value or no fallback value, or if the destination property has an
/// authored value that overrides its fallback.
/// 
/// Attribute connections and relationship targets that target an
/// object beneath this property's owning prim will be remapped to
/// target objects beneath the destination \p parent prim.
/// 
/// If the destination spec already exists, it will be overwritten.
/// 
/// \sa UsdStage::Flatten
int usd_Property_FlattenTo_prim(usd_Property_t const* _this, usd_Prim_t const* parent, usd_Property_t* _result);

/// \overload
/// Flattens this property to a property spec with the given
/// \p propName beneath the given \p parent prim in the edit target of its 
/// owning stage.
/// 
/// The \p parent prim may belong to a different stage than this property's 
/// owning stage.
int usd_Property_FlattenTo_named_property(usd_Property_t const* _this, usd_Prim_t const* parent, tf_Token_t const* propName, usd_Property_t* _result);

/// \overload
/// Flattens this property to a property spec for the given
/// \p property in the edit target of its owning prim's stage.
/// 
/// The \p property owning prim may belong to a different stage than this 
/// property's owning stage.
int usd_Property_FlattenTo_property(usd_Property_t const* _this, usd_Property_t const* property, usd_Property_t* _result);

/// \overload
/// 
/// Type-erased access
int usd_Property_GetMetadata_value(usd_Property_t const* _this, tf_Token_t const* key, vt_Value_t* value, bool* _result);

/// \overload
int usd_Property_SetMetadata_value(usd_Property_t const* _this, tf_Token_t const* key, vt_Value_t const* value, bool* _result);

/// Clears the authored \a key's value at the current EditTarget,
/// returning false on error.
/// 
/// If no value is present, this method is a no-op and returns true. It is
/// considered an error to call ClearMetadata when no spec is present for 
/// this UsdObject, i.e. if the object has no presence in the
/// current UsdEditTarget.
/// 
/// \sa \ref Usd_OM_Metadata
int usd_Property_ClearMetadata(usd_Property_t const* _this, tf_Token_t const* key, bool* _result);

/// Returns true if the \a key has a meaningful value, that is, if
/// GetMetadata() will provide a value, either because it was authored
/// or because a prim's metadata fallback will be provided.
int usd_Property_HasMetadata(usd_Property_t const* _this, tf_Token_t const* key, bool* _result);

/// Returns true if the \a key has an authored value, false if no
/// value was authored or the only value available is a prim's metadata 
/// fallback.
int usd_Property_HasAuthoredMetadata(usd_Property_t const* _this, tf_Token_t const* key, bool* _result);

/// \overload
int usd_Property_GetMetadataByDictKey_value(usd_Property_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t* value, bool* _result);

/// \overload
int usd_Property_SetMetadataByDictKey_value(usd_Property_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t const* value, bool* _result);

/// Clear any authored value identified by \p key and \p keyPath
/// at the current EditTarget.  The \p keyPath is a ':'-separated path
/// identifying a path in subdictionaries stored in the metadata field at
/// \p key.  Return true if the value is cleared successfully, false
/// otherwise.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Property_ClearMetadataByDictKey(usd_Property_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Return true if there exists any authored or fallback opinion for
/// \p key and \p keyPath.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries stored in the metadata field at
/// \p key.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Property_HasMetadataDictKey(usd_Property_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Return true if there exists any authored opinion (excluding
/// fallbacks) for \p key and \p keyPath.  The \p keyPath is a ':'-separated
/// path identifying a value in subdictionaries stored in the metadata field
/// at \p key.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Property_HasAuthoredMetadataDictKey(usd_Property_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Resolve and return all metadata (including both authored and
/// fallback values) on this object, sorted lexicographically.
/// 
/// \note This method does not return field keys for composition arcs,
/// such as references, inherits, payloads, sublayers, variants, or
/// primChildren, nor does it return the default value or timeSamples.
int usd_Property_GetAllMetadata(usd_Property_t const* _this, usd_MetadataValueMap_t* _result);

/// Resolve and return all user-authored metadata on this object,
/// sorted lexicographically.
/// 
/// \note This method does not return field keys for composition arcs,
/// such as references, inherits, payloads, sublayers, variants, or
/// primChildren, nor does it return the default value or timeSamples.
int usd_Property_GetAllAuthoredMetadata(usd_Property_t const* _this, usd_MetadataValueMap_t* _result);

/// Gets the value of the 'hidden' metadata field, false if not 
/// authored.
/// 
/// When an object is marked as hidden, it is an indicator to clients who 
/// generically display objects (such as GUI widgets) that this object 
/// should not be included, unless explicitly asked for.  Although this
/// is just a hint and thus up to each application to interpret, we
/// use it primarily as a way of simplifying hierarchy displays, by
/// hiding \em only the representation of the object itself, \em not its
/// subtree, instead "pulling up" everything below it one level in the
/// hierarchical nesting.
/// 
/// Note again that this is a hint for UI only - it should not be 
/// interpreted by any renderer as making a prim invisible to drawing.
int usd_Property_IsHidden(usd_Property_t const* _this, bool* _result);

/// Sets the value of the 'hidden' metadata field. See IsHidden()
/// for details.
int usd_Property_SetHidden(usd_Property_t const* _this, bool hidden, bool* _result);

/// Clears the opinion for "Hidden" at the current EditTarget.
int usd_Property_ClearHidden(usd_Property_t const* _this, bool* _result);

/// Returns true if hidden was explicitly authored and GetMetadata()
/// will return a meaningful value for Hidden. 
/// 
/// Note that IsHidden returns a fallback value (false) when hidden is not
/// authored.
int usd_Property_HasAuthoredHidden(usd_Property_t const* _this, bool* _result);

/// Return this object's composed customData dictionary.
/// 
/// CustomData is "custom metadata", a place for applications and users
/// to put uniform data that is entirely dynamic and subject to no schema
/// known to Usd.  Unlike metadata like 'hidden', 'displayName' etc,
/// which must be declared in code or a data file that is considered part
/// of one's Usd distribution (e.g. a plugInfo.json file) to be used,
/// customData keys and the datatypes of their corresponding values are
/// ad hoc.  No validation will ever be performed that values for the
/// same key in different layers are of the same type - strongest simply
/// wins.
/// 
/// Dictionaries like customData are composed element-wise, and are 
/// nestable.
/// 
/// There is no means to query a customData field's valuetype other
/// than fetching the value and interrogating it.
/// \sa GetCustomDataByKey()
int usd_Property_GetCustomData(usd_Property_t const* _this, vt_Dictionary_t* _result);

/// Return the element identified by \p keyPath in this object's
/// composed customData dictionary.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.  This is in general more
/// efficient than composing the entire customData dictionary and then
/// pulling out one sub-element.
int usd_Property_GetCustomDataByKey(usd_Property_t const* _this, tf_Token_t const* keyPath, vt_Value_t* _result);

/// Author this object's customData dictionary to \p customData at
/// the current EditTarget.
int usd_Property_SetCustomData(usd_Property_t const* _this, vt_Dictionary_t const* customData);

/// Author the element identified by \p keyPath in this object's
/// customData dictionary at the current EditTarget.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Property_SetCustomDataByKey(usd_Property_t const* _this, tf_Token_t const* keyPath, vt_Value_t const* value);

/// Clear the authored opinion for this object's customData
/// dictionary at the current EditTarget.  Do nothing if there is no such
/// authored opinion.
int usd_Property_ClearCustomData(usd_Property_t const* _this);

/// Clear the authored opinion identified by \p keyPath in this
/// object's customData dictionary at the current EditTarget.  The \p
/// keyPath is a ':'-separated path identifying a value in subdictionaries.
/// Do nothing if there is no such authored opinion.
int usd_Property_ClearCustomDataByKey(usd_Property_t const* _this, tf_Token_t const* keyPath);

/// Return true if there are any authored or fallback opinions for
/// this object's customData dictionary, false otherwise.
int usd_Property_HasCustomData(usd_Property_t const* _this, bool* _result);

/// Return true if there are any authored or fallback opinions for
/// the element identified by \p keyPath in this object's customData
/// dictionary, false otherwise.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.
int usd_Property_HasCustomDataKey(usd_Property_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for this object's customData dictionary, false otherwise.
int usd_Property_HasAuthoredCustomData(usd_Property_t const* _this, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for the element identified by \p keyPath in this object's
/// customData dictionary, false otherwise.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Property_HasAuthoredCustomDataKey(usd_Property_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return this object's composed assetInfo dictionary.
/// 
/// The asset info dictionary is used to annotate objects representing the 
/// root-prims of assets (generally organized as models) with various 
/// data related to asset management. For example, asset name, root layer
/// identifier, asset version etc.
/// 
/// The elements of this dictionary are composed element-wise, and are 
/// nestable.
/// 
/// There is no means to query an assetInfo field's valuetype other
/// than fetching the value and interrogating it.
/// \sa GetAssetInfoByKey()
int usd_Property_GetAssetInfo(usd_Property_t const* _this, vt_Dictionary_t* _result);

/// Return the element identified by \p keyPath in this object's
/// composed assetInfo dictionary.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.  This is in general more
/// efficient than composing the entire assetInfo dictionary than 
/// pulling out one sub-element.
int usd_Property_GetAssetInfoByKey(usd_Property_t const* _this, tf_Token_t const* keyPath, vt_Value_t* _result);

/// Author this object's assetInfo dictionary to \p assetInfo at
/// the current EditTarget.
int usd_Property_SetAssetInfo(usd_Property_t const* _this, vt_Dictionary_t const* customData);

/// Author the element identified by \p keyPath in this object's
/// assetInfo dictionary at the current EditTarget.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Property_SetAssetInfoByKey(usd_Property_t const* _this, tf_Token_t const* keyPath, vt_Value_t const* value);

/// Clear the authored opinion for this object's assetInfo
/// dictionary at the current EditTarget.  Do nothing if there is no such
/// authored opinion.
int usd_Property_ClearAssetInfo(usd_Property_t const* _this);

/// Clear the authored opinion identified by \p keyPath in this
/// object's assetInfo dictionary at the current EditTarget.  The \p
/// keyPath is a ':'-separated path identifying a value in subdictionaries.
/// Do nothing if there is no such authored opinion.
int usd_Property_ClearAssetInfoByKey(usd_Property_t const* _this, tf_Token_t const* keyPath);

/// Return true if there are any authored or fallback opinions for
/// this object's assetInfo dictionary, false otherwise.
int usd_Property_HasAssetInfo(usd_Property_t const* _this, bool* _result);

/// Return true if there are any authored or fallback opinions for
/// the element identified by \p keyPath in this object's assetInfo
/// dictionary, false otherwise.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.
int usd_Property_HasAssetInfoKey(usd_Property_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for this object's assetInfo dictionary, false otherwise.
int usd_Property_HasAuthoredAssetInfo(usd_Property_t const* _this, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for the element identified by \p keyPath in this object's
/// assetInfo dictionary, false otherwise.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Property_HasAuthoredAssetInfoKey(usd_Property_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return this object's documentation (metadata).  This returns the
/// empty string if no documentation has been set.
/// \sa SetDocumentation()
int usd_Property_GetDocumentation(usd_Property_t const* _this, std_String_t* _result);

/// Sets this object's documentation (metadata).  Returns true on success.
int usd_Property_SetDocumentation(usd_Property_t const* _this, std_String_t const* doc, bool* _result);

/// Clears this object's documentation (metadata) in the current EditTarget
/// (only).  Returns true on success.
int usd_Property_ClearDocumentation(usd_Property_t const* _this, bool* _result);

/// Returns true if documentation was explicitly authored and GetMetadata()
/// will return a meaningful value for documentation. 
int usd_Property_HasAuthoredDocumentation(usd_Property_t const* _this, bool* _result);

/// Return this object's display name (metadata).  This returns the
/// empty string if no display name has been set.
/// \sa SetDisplayName()
int usd_Property_GetDisplayName(usd_Property_t const* _this, std_String_t* _result);

/// Sets this object's display name (metadata).  Returns true on success.
/// 
/// DisplayName is meant to be a descriptive label, not necessarily an
/// alternate identifier; therefore there is no restriction on which
/// characters can appear in it.
int usd_Property_SetDisplayName(usd_Property_t const* _this, std_String_t const* name, bool* _result);

/// Clears this object's display name (metadata) in the current EditTarget
/// (only).  Returns true on success.
int usd_Property_ClearDisplayName(usd_Property_t const* _this, bool* _result);

/// Returns true if displayName was explicitly authored and GetMetadata()
/// will return a meaningful value for displayName. 
int usd_Property_HasAuthoredDisplayName(usd_Property_t const* _this, bool* _result);

/// Return true if this is a valid object, false otherwise.
int usd_Property_IsValid(usd_Property_t const* _this, bool* _result);

/// Return the stage that owns the object, and to whose state and lifetime
/// this object's validity is tied.
int usd_Property_GetStage(usd_Property_t const* _this, usd_StageWeakPtr_t* _result);

/// Return the complete scene path to this object on its UsdStage,
/// which may (UsdPrim) or may not (all other subclasses) return a 
/// cached result
int usd_Property_GetPath(usd_Property_t const* _this, sdf_Path_t* _result);

/// Return this object's path if this object is a prim, otherwise this
/// object's nearest owning prim's path.  Equivalent to GetPrim().GetPath().
int usd_Property_GetPrimPath(usd_Property_t const* _this, sdf_Path_t const** _result);

/// /////////////////////////////////////////////////////////////////////
int usd_Property_GetPrim(usd_Property_t const* _this, usd_Prim_t* _result);

/// Return the full name of this object, i.e. the last component of its
/// SdfPath in namespace.
/// 
/// This is equivalent to, but generally cheaper than,
/// GetPath().GetNameToken()
int usd_Property_GetName(usd_Property_t const* _this, tf_Token_t const** _result);

/// @}
int usd_Property_GetNamespaceDelimiter(char* _result);

/// Return a string that provides a brief summary description of the
/// object.  This method, along with IsValid()/bool_operator,
/// is always safe to call on a possibly-expired object, and the 
/// description will specify whether the object is valid or expired,
/// along with a few other bits of data.
int usd_Property_GetDescription(usd_Property_t const* _this, std_String_t* _result);

int usd_Property_default(usd_Property_t** _result);

int usd_Property_dtor(usd_Property_t* _this);

int usd_PropertyVector_data(usd_PropertyVector_t* _this, usd_Property_t** _result);

int usd_PropertyVector_data_const(usd_PropertyVector_t const* _this, usd_Property_t const** _result);

int usd_PropertyVector_empty(usd_PropertyVector_t const* _this, bool* _result);

int usd_PropertyVector_size(usd_PropertyVector_t const* _this, size_t* _result);

int usd_PropertyVector_max_size(usd_PropertyVector_t const* _this, size_t* _result);

int usd_PropertyVector_reserve(usd_PropertyVector_t* _this, size_t const _Newcapacity);

int usd_PropertyVector_capacity(usd_PropertyVector_t const* _this, size_t* _result);

int usd_PropertyVector_clear(usd_PropertyVector_t* _this);

int usd_PropertyVector_push_back(usd_PropertyVector_t* _this, usd_Property_t const* _Val);

int usd_PropertyVector_pop_back(usd_PropertyVector_t* _this);

int usd_PropertyVector_resize(usd_PropertyVector_t* _this, size_t const _Newsize);

int usd_PropertyVector_resize_with(usd_PropertyVector_t* _this, size_t const _Newsize, usd_Property_t const* _Val);

int usd_PropertyVector_op_index(usd_PropertyVector_t const* _this, size_t const _Pos, usd_Property_t const** _result);

int usd_PropertyVector_default(usd_PropertyVector_t** _result);

int usd_PropertyVector_dtor(usd_PropertyVector_t* _this);

/// Adds a reference to the reference listOp at the current EditTarget,
/// in the position specified by \p position.
/// \sa \ref Usd_Failing_References "Why adding references may fail" for
/// explanation of expectations on \p ref and what return values and errors
/// to expect, and \ref Usd_OM_ListOps for details on list editing and
/// composition of listOps.
int usd_References_AddReference(usd_References_t* _this, sdf_Reference_t const* ref, int position, bool* _result);

/// \overload 
int usd_References_AddReference_with_identifier_and_path(usd_References_t* _this, std_String_t const* identifier, sdf_Path_t const* primPath, sdf_LayerOffset_t const* layerOffset, int position, bool* _result);

/// \overload
/// \sa \ref Usd_DefaultPrim_References "References Without Prim Paths"
int usd_References_AddReference_with_identifier(usd_References_t* _this, std_String_t const* identifier, sdf_LayerOffset_t const* layerOffset, int position, bool* _result);

/// Add an internal reference to the specified prim.
/// \sa \ref Usd_Internal_References "Internal References"
int usd_References_AddInternalReference(usd_References_t* _this, sdf_Path_t const* primPath, sdf_LayerOffset_t const* layerOffset, int position, bool* _result);

/// Removes the specified reference from the references listOp at the
/// current EditTarget.  This does not necessarily eliminate the 
/// reference completely, as it may be added or set in another layer in
/// the same LayerStack as the current EditTarget.
/// \sa \ref Usd_OM_ListOps 
int usd_References_RemoveReference(usd_References_t* _this, sdf_Reference_t const* ref, bool* _result);

/// Removes the authored reference listOp edits at the current EditTarget.
/// The same caveats for Remove() apply to Clear().  In fact, Clear() may
/// actually increase the number of composed references, if the listOp
/// being cleared contained the "remove" operator.
/// \sa \ref Usd_OM_ListOps 
int usd_References_ClearReferences(usd_References_t* _this, bool* _result);

/// Explicitly set the references, potentially blocking weaker opinions
/// that add or remove items.
/// \sa \ref Usd_Failing_References "Why adding references may fail" for
/// explanation of expectations on \p ref and what return values and errors
/// to expect, and \ref Usd_OM_ListOps for details on list editing and
/// composition of listOps.
int usd_References_SetReferences(usd_References_t* _this, sdf_ReferenceVector_t const* items, bool* _result);

/// Return the prim this object is bound to.
int usd_References_GetPrim(usd_References_t const* _this, usd_Prim_t const** _result);

int usd_References_dtor(usd_References_t* _this);

/// Adds \p target to the list of targets, in the position specified
/// by \p position.
/// 
/// Passing paths to prototype prims or any other objects in prototypes
/// will cause an error to be issued. It is not valid to author targets to
/// these objects.
/// 
/// What data this actually authors depends on what data is currently
/// authored in the authoring layer, with respect to list-editing
/// semantics, which we will document soon 
int usd_Relationship_AddTarget(usd_Relationship_t const* _this, sdf_Path_t const* target, int position, bool* _result);

/// Removes \p target from the list of targets.
/// 
/// Passing paths to prototype prims or any other objects in prototypes
/// will cause an error to be issued. It is not valid to author targets to
/// these objects.
int usd_Relationship_RemoveTarget(usd_Relationship_t const* _this, sdf_Path_t const* target, bool* _result);

/// Make the authoring layer's opinion of the targets list explicit,
/// and set exactly to \p targets.
/// 
/// Passing paths to prototype prims or any other objects in prototypes
/// will cause an error to be issued. It is not valid to author targets to
/// these objects.
/// 
/// If any target in \p targets is invalid, no targets will be authored
/// and this function will return false.
int usd_Relationship_SetTargets(usd_Relationship_t const* _this, sdf_PathVector_t const* targets, bool* _result);

/// Remove all opinions about the target list from the current edit
/// target.
/// 
/// Only remove the spec if \p removeSpec is true (leave the spec to
/// preserve meta-data we may have intentionally authored on the
/// relationship)
int usd_Relationship_ClearTargets(usd_Relationship_t const* _this, bool removeSpec, bool* _result);

/// Compose this relationship's targets and fill \p targets with the result.
/// All preexisting elements in \p targets are lost.
/// 
/// Returns true if any target path opinions have been authored and no
/// composition errors were encountered, returns false otherwise. 
/// Note that authored opinions may include opinions that clear the targets 
/// and a return value of true does not necessarily indicate that \p targets 
/// will contain any target paths.
/// 
/// See \ref Usd_ScenegraphInstancing_TargetsAndConnections for details on 
/// behavior when targets point to objects beneath instance prims.
/// 
/// The result is not cached, so will be recomputed on every query.
int usd_Relationship_GetTargets(usd_Relationship_t const* _this, sdf_PathVector_t* targets, bool* _result);

/// Compose this relationship's \em ultimate targets, taking into account
/// "relationship forwarding", and fill \p targets with the result.  All
/// preexisting elements in \p targets are lost. This method never inserts
/// relationship paths in \p targets.
/// 
/// Returns true if any of the visited relationships that are not 
/// "purely forwarding" has an authored opinion for its target paths and
/// no composition errors were encountered while computing any targets. 
/// Purely forwarding, in this context, means the relationship has at least 
/// one target but all of its targets are paths to other relationships.
/// Note that authored opinions may include opinions that clear the targets 
/// and a return value of true does not necessarily indicate that \p targets 
/// will not be empty.
/// 
/// Returns false otherwise. When composition errors occur, this function 
/// continues to collect successfully composed targets, but returns false 
/// to indicate to the caller that errors occurred.
/// 
/// When a forwarded target cannot be determined, e.g. due to a composition
/// error, no value is returned for that target; the alternative would be to
/// return the relationship path at which the forwarded targets could not be
/// composed, however this would require all callers of 
/// GetForwardedTargets() to account for unexpected relationship paths
/// being returned with the expected target results. For example, a
/// particular caller may expect only prim paths in the target vector, but 
/// when composition errors occur, relationships would be included,
/// potentially triggering additional down stream errors.
/// 
/// See \ref usd_relationship_forwarding for details on the semantics.
/// 
/// The result is not cached, so will be recomputed on every query.
int usd_Relationship_GetForwardedTargets(usd_Relationship_t const* _this, sdf_PathVector_t* targets, bool* _result);

/// Returns true if any target path opinions have been authored. 
/// Note that this may include opinions that clear targets and may not 
/// indicate that target paths will exist for this relationship.
int usd_Relationship_HasAuthoredTargets(usd_Relationship_t const* _this, bool* _result);

/// Returns a strength-ordered list of property specs that provide
/// opinions for this property.
/// 
/// If \p time is UsdTimeCode::Default(), *or* this property 
/// is a UsdRelationship (which are never affected by clips), we will 
/// not consider value clips for opinions. For any other \p time, for 
/// a UsdAttribute, clips whose samples may contribute an opinion will 
/// be included. These specs are ordered from strongest to weakest opinion, 
/// although if \p time requires interpolation between two adjacent clips, 
/// both clips will appear, sequentially.
/// 
/// \note The results returned by this method are meant for debugging
/// and diagnostic purposes.  It is **not** advisable to retain a 
/// PropertyStack for the purposes of expedited value resolution for 
/// properties, since the makeup of an attribute's PropertyStack may
/// itself be time-varying.  To expedite repeated value resolution of
/// attributes, you should instead retain a \c UsdAttributeQuery .
/// 
/// \sa UsdClipsAPI
int usd_Relationship_GetPropertyStack(usd_Relationship_t const* _this, usd_TimeCode_t time, sdf_PropertySpecHandleVector_t* _result);

/// Returns a strength-ordered list of property specs that provide
/// opinions for this property paired with the cumulative layer offset from
/// the stage's root layer to the layer containing the property spec.
/// 
/// This behaves exactly the same as UsdProperty::GetPropertyStack with the 
/// addition of providing the cumulative layer offset of each spec's layer.
/// 
/// \note The results returned by this method are meant for debugging
/// and diagnostic purposes.  It is **not** advisable to retain a 
/// PropertyStack for the purposes of expedited value resolution for 
/// properties, since the makeup of an attribute's PropertyStack may
/// itself be time-varying.  To expedite repeated value resolution of
/// attributes, you should instead retain a \c UsdAttributeQuery .
int usd_Relationship_GetPropertyStackWithLayerOffsets(usd_Relationship_t const* _this, usd_TimeCode_t time, sdf_PropertySpecHandleOffsetPairVector_t* _result);

/// Return this property's name with all namespace prefixes removed,
/// i.e. the last component of the return value of GetName()
/// 
/// This is generally the property's "client name"; property namespaces are
/// often used to group related properties together.  The namespace prefixes
/// the property name but many consumers will care only about un-namespaced
/// name, i.e. its BaseName.  For more information, see \ref Usd_Ordering
int usd_Relationship_GetBaseName(usd_Relationship_t const* _this, tf_Token_t* _result);

/// Return this property's complete namespace prefix.  Return the empty
/// token if this property has no namespaces.
/// 
/// This is the complement of GetBaseName(), although it does \em not
/// contain a trailing namespace delimiter
int usd_Relationship_GetNamespace(usd_Relationship_t const* _this, tf_Token_t* _result);

/// Return this property's name elements including namespaces and its base
/// name as the final element.
int usd_Relationship_SplitName(usd_Relationship_t const* _this, std_StringVector_t* _result);

/// Return this property's display group (metadata).  This returns the
/// empty token if no display group has been set.
/// \sa SetDisplayGroup()
int usd_Relationship_GetDisplayGroup(usd_Relationship_t const* _this, std_String_t* _result);

/// Sets this property's display group (metadata).  Returns true on success.
/// 
/// DisplayGroup provides UI hinting for grouping related properties
/// together for display.  We define a convention for specifying nesting
/// of groups by recognizing the property namespace separator in 
/// displayGroup as denoting group-nesting.
/// \sa SetNestedDisplayGroups()
int usd_Relationship_SetDisplayGroup(usd_Relationship_t const* _this, std_String_t const* displayGroup, bool* _result);

/// Clears this property's display group (metadata) in
/// the current EditTarget (only).  Returns true on success.
int usd_Relationship_ClearDisplayGroup(usd_Relationship_t const* _this, bool* _result);

/// Returns true if displayGroup was explicitly authored and GetMetadata()
/// will return a meaningful value for displayGroup. 
int usd_Relationship_HasAuthoredDisplayGroup(usd_Relationship_t const* _this, bool* _result);

/// Return this property's displayGroup as a sequence of groups to be
/// nested, or an empty vector if displayGroup is empty or not authored.
int usd_Relationship_GetNestedDisplayGroups(usd_Relationship_t const* _this, std_StringVector_t* _result);

/// Sets this property's display group (metadata) to the nested sequence.  
/// Returns true on success.
/// 
/// A displayGroup set with this method can still be retrieved with
/// GetDisplayGroup(), with the namespace separator embedded in the result.
/// If \p nestedGroups is empty, we author an empty string for displayGroup.
/// \sa SetDisplayGroup()
int usd_Relationship_SetNestedDisplayGroups(usd_Relationship_t const* _this, std_StringVector_t const* nestedGroups, bool* _result);

/// Return true if this is a custom property (i.e., not part of a
/// prim schema).
/// 
/// The 'custom' modifier in USD serves the same function as Alembic's
/// 'userProperties', which is to say as a categorization for ad hoc
/// client data not formalized into any schema, and therefore not 
/// carrying an expectation of specific processing by consuming applications.
int usd_Relationship_IsCustom(usd_Relationship_t const* _this, bool* _result);

/// Set the value for custom at the current EditTarget, return true on
/// success, false if the value can not be written.
/// 
/// \b Note that this value should not be changed as it is typically either
/// automatically authored or provided by a property definition. This method
/// is provided primarily for fixing invalid scene description.
int usd_Relationship_SetCustom(usd_Relationship_t const* _this, bool isCustom, bool* _result);

/// Return true if this is a builtin property or if the strongest
/// authored SdfPropertySpec for this property's path matches this
/// property's dynamic type.  That is, SdfRelationshipSpec in case this is a
/// UsdRelationship, and SdfAttributeSpec in case this is a UsdAttribute.
/// Return \c false if this property's prim has expired.
/// 
/// For attributes, a \c true return does not imply that this attribute
/// possesses a value, only that has been declared, is of a certain type and
/// variability, and that it is safe to use to query and author values and
/// metadata.
int usd_Relationship_IsDefined(usd_Relationship_t const* _this, bool* _result);

/// Return true if there are any authored opinions for this property
/// in any layer that contributes to this stage, false otherwise.
int usd_Relationship_IsAuthored(usd_Relationship_t const* _this, bool* _result);

/// Return true if there is an SdfPropertySpec authored for this
/// property at the given \a editTarget, otherwise return false.  Note
/// that this method does not do partial composition.  It does not consider
/// whether authored scene description exists at \a editTarget or weaker,
/// only <b>exactly at</b> the given \a editTarget.
int usd_Relationship_IsAuthoredAt(usd_Relationship_t const* _this, usd_EditTarget_t const* editTarget, bool* _result);

/// Flattens this property to a property spec with the same name 
/// beneath the given \p parent prim in the edit target of its owning stage.
/// 
/// The \p parent prim may belong to a different stage than this property's 
/// owning stage.
/// 
/// Flattening authors all authored resolved values and metadata for 
/// this property into the destination property spec. If this property
/// is a builtin property, fallback values and metadata will also be
/// authored if the destination property has a different fallback 
/// value or no fallback value, or if the destination property has an
/// authored value that overrides its fallback.
/// 
/// Attribute connections and relationship targets that target an
/// object beneath this property's owning prim will be remapped to
/// target objects beneath the destination \p parent prim.
/// 
/// If the destination spec already exists, it will be overwritten.
/// 
/// \sa UsdStage::Flatten
int usd_Relationship_FlattenTo_prim(usd_Relationship_t const* _this, usd_Prim_t const* parent, usd_Property_t* _result);

/// \overload
/// Flattens this property to a property spec with the given
/// \p propName beneath the given \p parent prim in the edit target of its 
/// owning stage.
/// 
/// The \p parent prim may belong to a different stage than this property's 
/// owning stage.
int usd_Relationship_FlattenTo_named_property(usd_Relationship_t const* _this, usd_Prim_t const* parent, tf_Token_t const* propName, usd_Property_t* _result);

/// \overload
/// Flattens this property to a property spec for the given
/// \p property in the edit target of its owning prim's stage.
/// 
/// The \p property owning prim may belong to a different stage than this 
/// property's owning stage.
int usd_Relationship_FlattenTo_property(usd_Relationship_t const* _this, usd_Property_t const* property, usd_Property_t* _result);

/// \overload
/// 
/// Type-erased access
int usd_Relationship_GetMetadata_value(usd_Relationship_t const* _this, tf_Token_t const* key, vt_Value_t* value, bool* _result);

/// \overload
int usd_Relationship_SetMetadata_value(usd_Relationship_t const* _this, tf_Token_t const* key, vt_Value_t const* value, bool* _result);

/// Clears the authored \a key's value at the current EditTarget,
/// returning false on error.
/// 
/// If no value is present, this method is a no-op and returns true. It is
/// considered an error to call ClearMetadata when no spec is present for 
/// this UsdObject, i.e. if the object has no presence in the
/// current UsdEditTarget.
/// 
/// \sa \ref Usd_OM_Metadata
int usd_Relationship_ClearMetadata(usd_Relationship_t const* _this, tf_Token_t const* key, bool* _result);

/// Returns true if the \a key has a meaningful value, that is, if
/// GetMetadata() will provide a value, either because it was authored
/// or because a prim's metadata fallback will be provided.
int usd_Relationship_HasMetadata(usd_Relationship_t const* _this, tf_Token_t const* key, bool* _result);

/// Returns true if the \a key has an authored value, false if no
/// value was authored or the only value available is a prim's metadata 
/// fallback.
int usd_Relationship_HasAuthoredMetadata(usd_Relationship_t const* _this, tf_Token_t const* key, bool* _result);

/// \overload
int usd_Relationship_GetMetadataByDictKey_value(usd_Relationship_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t* value, bool* _result);

/// \overload
int usd_Relationship_SetMetadataByDictKey_value(usd_Relationship_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t const* value, bool* _result);

/// Clear any authored value identified by \p key and \p keyPath
/// at the current EditTarget.  The \p keyPath is a ':'-separated path
/// identifying a path in subdictionaries stored in the metadata field at
/// \p key.  Return true if the value is cleared successfully, false
/// otherwise.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Relationship_ClearMetadataByDictKey(usd_Relationship_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Return true if there exists any authored or fallback opinion for
/// \p key and \p keyPath.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries stored in the metadata field at
/// \p key.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Relationship_HasMetadataDictKey(usd_Relationship_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Return true if there exists any authored opinion (excluding
/// fallbacks) for \p key and \p keyPath.  The \p keyPath is a ':'-separated
/// path identifying a value in subdictionaries stored in the metadata field
/// at \p key.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Relationship_HasAuthoredMetadataDictKey(usd_Relationship_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Resolve and return all metadata (including both authored and
/// fallback values) on this object, sorted lexicographically.
/// 
/// \note This method does not return field keys for composition arcs,
/// such as references, inherits, payloads, sublayers, variants, or
/// primChildren, nor does it return the default value or timeSamples.
int usd_Relationship_GetAllMetadata(usd_Relationship_t const* _this, usd_MetadataValueMap_t* _result);

/// Resolve and return all user-authored metadata on this object,
/// sorted lexicographically.
/// 
/// \note This method does not return field keys for composition arcs,
/// such as references, inherits, payloads, sublayers, variants, or
/// primChildren, nor does it return the default value or timeSamples.
int usd_Relationship_GetAllAuthoredMetadata(usd_Relationship_t const* _this, usd_MetadataValueMap_t* _result);

/// Gets the value of the 'hidden' metadata field, false if not 
/// authored.
/// 
/// When an object is marked as hidden, it is an indicator to clients who 
/// generically display objects (such as GUI widgets) that this object 
/// should not be included, unless explicitly asked for.  Although this
/// is just a hint and thus up to each application to interpret, we
/// use it primarily as a way of simplifying hierarchy displays, by
/// hiding \em only the representation of the object itself, \em not its
/// subtree, instead "pulling up" everything below it one level in the
/// hierarchical nesting.
/// 
/// Note again that this is a hint for UI only - it should not be 
/// interpreted by any renderer as making a prim invisible to drawing.
int usd_Relationship_IsHidden(usd_Relationship_t const* _this, bool* _result);

/// Sets the value of the 'hidden' metadata field. See IsHidden()
/// for details.
int usd_Relationship_SetHidden(usd_Relationship_t const* _this, bool hidden, bool* _result);

/// Clears the opinion for "Hidden" at the current EditTarget.
int usd_Relationship_ClearHidden(usd_Relationship_t const* _this, bool* _result);

/// Returns true if hidden was explicitly authored and GetMetadata()
/// will return a meaningful value for Hidden. 
/// 
/// Note that IsHidden returns a fallback value (false) when hidden is not
/// authored.
int usd_Relationship_HasAuthoredHidden(usd_Relationship_t const* _this, bool* _result);

/// Return this object's composed customData dictionary.
/// 
/// CustomData is "custom metadata", a place for applications and users
/// to put uniform data that is entirely dynamic and subject to no schema
/// known to Usd.  Unlike metadata like 'hidden', 'displayName' etc,
/// which must be declared in code or a data file that is considered part
/// of one's Usd distribution (e.g. a plugInfo.json file) to be used,
/// customData keys and the datatypes of their corresponding values are
/// ad hoc.  No validation will ever be performed that values for the
/// same key in different layers are of the same type - strongest simply
/// wins.
/// 
/// Dictionaries like customData are composed element-wise, and are 
/// nestable.
/// 
/// There is no means to query a customData field's valuetype other
/// than fetching the value and interrogating it.
/// \sa GetCustomDataByKey()
int usd_Relationship_GetCustomData(usd_Relationship_t const* _this, vt_Dictionary_t* _result);

/// Return the element identified by \p keyPath in this object's
/// composed customData dictionary.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.  This is in general more
/// efficient than composing the entire customData dictionary and then
/// pulling out one sub-element.
int usd_Relationship_GetCustomDataByKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath, vt_Value_t* _result);

/// Author this object's customData dictionary to \p customData at
/// the current EditTarget.
int usd_Relationship_SetCustomData(usd_Relationship_t const* _this, vt_Dictionary_t const* customData);

/// Author the element identified by \p keyPath in this object's
/// customData dictionary at the current EditTarget.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Relationship_SetCustomDataByKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath, vt_Value_t const* value);

/// Clear the authored opinion for this object's customData
/// dictionary at the current EditTarget.  Do nothing if there is no such
/// authored opinion.
int usd_Relationship_ClearCustomData(usd_Relationship_t const* _this);

/// Clear the authored opinion identified by \p keyPath in this
/// object's customData dictionary at the current EditTarget.  The \p
/// keyPath is a ':'-separated path identifying a value in subdictionaries.
/// Do nothing if there is no such authored opinion.
int usd_Relationship_ClearCustomDataByKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath);

/// Return true if there are any authored or fallback opinions for
/// this object's customData dictionary, false otherwise.
int usd_Relationship_HasCustomData(usd_Relationship_t const* _this, bool* _result);

/// Return true if there are any authored or fallback opinions for
/// the element identified by \p keyPath in this object's customData
/// dictionary, false otherwise.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.
int usd_Relationship_HasCustomDataKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for this object's customData dictionary, false otherwise.
int usd_Relationship_HasAuthoredCustomData(usd_Relationship_t const* _this, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for the element identified by \p keyPath in this object's
/// customData dictionary, false otherwise.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Relationship_HasAuthoredCustomDataKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return this object's composed assetInfo dictionary.
/// 
/// The asset info dictionary is used to annotate objects representing the 
/// root-prims of assets (generally organized as models) with various 
/// data related to asset management. For example, asset name, root layer
/// identifier, asset version etc.
/// 
/// The elements of this dictionary are composed element-wise, and are 
/// nestable.
/// 
/// There is no means to query an assetInfo field's valuetype other
/// than fetching the value and interrogating it.
/// \sa GetAssetInfoByKey()
int usd_Relationship_GetAssetInfo(usd_Relationship_t const* _this, vt_Dictionary_t* _result);

/// Return the element identified by \p keyPath in this object's
/// composed assetInfo dictionary.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.  This is in general more
/// efficient than composing the entire assetInfo dictionary than 
/// pulling out one sub-element.
int usd_Relationship_GetAssetInfoByKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath, vt_Value_t* _result);

/// Author this object's assetInfo dictionary to \p assetInfo at
/// the current EditTarget.
int usd_Relationship_SetAssetInfo(usd_Relationship_t const* _this, vt_Dictionary_t const* customData);

/// Author the element identified by \p keyPath in this object's
/// assetInfo dictionary at the current EditTarget.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Relationship_SetAssetInfoByKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath, vt_Value_t const* value);

/// Clear the authored opinion for this object's assetInfo
/// dictionary at the current EditTarget.  Do nothing if there is no such
/// authored opinion.
int usd_Relationship_ClearAssetInfo(usd_Relationship_t const* _this);

/// Clear the authored opinion identified by \p keyPath in this
/// object's assetInfo dictionary at the current EditTarget.  The \p
/// keyPath is a ':'-separated path identifying a value in subdictionaries.
/// Do nothing if there is no such authored opinion.
int usd_Relationship_ClearAssetInfoByKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath);

/// Return true if there are any authored or fallback opinions for
/// this object's assetInfo dictionary, false otherwise.
int usd_Relationship_HasAssetInfo(usd_Relationship_t const* _this, bool* _result);

/// Return true if there are any authored or fallback opinions for
/// the element identified by \p keyPath in this object's assetInfo
/// dictionary, false otherwise.  The \p keyPath is a ':'-separated path
/// identifying a value in subdictionaries.
int usd_Relationship_HasAssetInfoKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for this object's assetInfo dictionary, false otherwise.
int usd_Relationship_HasAuthoredAssetInfo(usd_Relationship_t const* _this, bool* _result);

/// Return true if there are any authored opinions (excluding
/// fallback) for the element identified by \p keyPath in this object's
/// assetInfo dictionary, false otherwise.  The \p keyPath is a
/// ':'-separated path identifying a value in subdictionaries.
int usd_Relationship_HasAuthoredAssetInfoKey(usd_Relationship_t const* _this, tf_Token_t const* keyPath, bool* _result);

/// Return this object's documentation (metadata).  This returns the
/// empty string if no documentation has been set.
/// \sa SetDocumentation()
int usd_Relationship_GetDocumentation(usd_Relationship_t const* _this, std_String_t* _result);

/// Sets this object's documentation (metadata).  Returns true on success.
int usd_Relationship_SetDocumentation(usd_Relationship_t const* _this, std_String_t const* doc, bool* _result);

/// Clears this object's documentation (metadata) in the current EditTarget
/// (only).  Returns true on success.
int usd_Relationship_ClearDocumentation(usd_Relationship_t const* _this, bool* _result);

/// Returns true if documentation was explicitly authored and GetMetadata()
/// will return a meaningful value for documentation. 
int usd_Relationship_HasAuthoredDocumentation(usd_Relationship_t const* _this, bool* _result);

/// Return this object's display name (metadata).  This returns the
/// empty string if no display name has been set.
/// \sa SetDisplayName()
int usd_Relationship_GetDisplayName(usd_Relationship_t const* _this, std_String_t* _result);

/// Sets this object's display name (metadata).  Returns true on success.
/// 
/// DisplayName is meant to be a descriptive label, not necessarily an
/// alternate identifier; therefore there is no restriction on which
/// characters can appear in it.
int usd_Relationship_SetDisplayName(usd_Relationship_t const* _this, std_String_t const* name, bool* _result);

/// Clears this object's display name (metadata) in the current EditTarget
/// (only).  Returns true on success.
int usd_Relationship_ClearDisplayName(usd_Relationship_t const* _this, bool* _result);

/// Returns true if displayName was explicitly authored and GetMetadata()
/// will return a meaningful value for displayName. 
int usd_Relationship_HasAuthoredDisplayName(usd_Relationship_t const* _this, bool* _result);

/// Return true if this is a valid object, false otherwise.
int usd_Relationship_IsValid(usd_Relationship_t const* _this, bool* _result);

/// Return the stage that owns the object, and to whose state and lifetime
/// this object's validity is tied.
int usd_Relationship_GetStage(usd_Relationship_t const* _this, usd_StageWeakPtr_t* _result);

/// Return the complete scene path to this object on its UsdStage,
/// which may (UsdPrim) or may not (all other subclasses) return a 
/// cached result
int usd_Relationship_GetPath(usd_Relationship_t const* _this, sdf_Path_t* _result);

/// Return this object's path if this object is a prim, otherwise this
/// object's nearest owning prim's path.  Equivalent to GetPrim().GetPath().
int usd_Relationship_GetPrimPath(usd_Relationship_t const* _this, sdf_Path_t const** _result);

/// /////////////////////////////////////////////////////////////////////
int usd_Relationship_GetPrim(usd_Relationship_t const* _this, usd_Prim_t* _result);

/// Return the full name of this object, i.e. the last component of its
/// SdfPath in namespace.
/// 
/// This is equivalent to, but generally cheaper than,
/// GetPath().GetNameToken()
int usd_Relationship_GetName(usd_Relationship_t const* _this, tf_Token_t const** _result);

/// @}
int usd_Relationship_GetNamespaceDelimiter(char* _result);

/// Return a string that provides a brief summary description of the
/// object.  This method, along with IsValid()/bool_operator,
/// is always safe to call on a possibly-expired object, and the 
/// description will specify whether the object is valid or expired,
/// along with a few other bits of data.
int usd_Relationship_GetDescription(usd_Relationship_t const* _this, std_String_t* _result);

int usd_Relationship_default(usd_Relationship_t** _result);

int usd_Relationship_dtor(usd_Relationship_t* _this);

int usd_RelationshipVector_data(usd_RelationshipVector_t* _this, usd_Relationship_t** _result);

int usd_RelationshipVector_data_const(usd_RelationshipVector_t const* _this, usd_Relationship_t const** _result);

int usd_RelationshipVector_empty(usd_RelationshipVector_t const* _this, bool* _result);

int usd_RelationshipVector_size(usd_RelationshipVector_t const* _this, size_t* _result);

int usd_RelationshipVector_max_size(usd_RelationshipVector_t const* _this, size_t* _result);

int usd_RelationshipVector_reserve(usd_RelationshipVector_t* _this, size_t const _Newcapacity);

int usd_RelationshipVector_capacity(usd_RelationshipVector_t const* _this, size_t* _result);

int usd_RelationshipVector_clear(usd_RelationshipVector_t* _this);

int usd_RelationshipVector_push_back(usd_RelationshipVector_t* _this, usd_Relationship_t const* _Val);

int usd_RelationshipVector_pop_back(usd_RelationshipVector_t* _this);

int usd_RelationshipVector_resize(usd_RelationshipVector_t* _this, size_t const _Newsize);

int usd_RelationshipVector_resize_with(usd_RelationshipVector_t* _this, size_t const _Newsize, usd_Relationship_t const* _Val);

int usd_RelationshipVector_op_index(usd_RelationshipVector_t const* _this, size_t const _Pos, usd_Relationship_t const** _result);

int usd_RelationshipVector_default(usd_RelationshipVector_t** _result);

int usd_RelationshipVector_dtor(usd_RelationshipVector_t* _this);

/// Return the source of the associated attribute's value.
int usd_ResolveInfo_GetSource(usd_ResolveInfo_t const* _this, int* _result);

/// Return true if this UsdResolveInfo represents an attribute that has an
/// authored value opinion.  This will return `true` if there is *any*
/// authored value opinion, including a \ref Usd_AttributeBlocking "block"
/// 
/// This is equivalent to `HasAuthoredValue() || ValueIsBlocked()`
int usd_ResolveInfo_HasAuthoredValueOpinion(usd_ResolveInfo_t const* _this, bool* _result);

/// Return true if this UsdResolveInfo represents an attribute that has an
/// authored value that is not \ref Usd_AttributeBlocking "blocked"
int usd_ResolveInfo_HasAuthoredValue(usd_ResolveInfo_t const* _this, bool* _result);

/// Return the node within the containing PcpPrimIndex that provided
/// the resolved value opinion.
int usd_ResolveInfo_GetNode(usd_ResolveInfo_t const* _this, pcp_NodeRef_t* _result);

/// Return true if this UsdResolveInfo represents an attribute whose
/// value is blocked.
/// 
/// \see UsdAttribute::Block()
int usd_ResolveInfo_ValueIsBlocked(usd_ResolveInfo_t const* _this, bool* _result);

int usd_ResolveInfo_dtor(usd_ResolveInfo_t* _this);

/// Get the prim index of the resolve target.
int usd_ResolveTarget_GetPrimIndex(usd_ResolveTarget_t const* _this, pcp_PrimIndex_t const** _result);

/// Returns the node that value resolution with this resolve target will
/// start at.
int usd_ResolveTarget_GetStartNode(usd_ResolveTarget_t const* _this, pcp_NodeRef_t* _result);

/// Returns the layer in the layer stack of the start node that value 
/// resolution with this resolve target will start at.
int usd_ResolveTarget_GetStartLayer(usd_ResolveTarget_t const* _this, sdf_LayerHandle_t* _result);

/// Returns the node that value resolution with this resolve target will 
/// stop at when the "stop at" layer is reached.
int usd_ResolveTarget_GetStopNode(usd_ResolveTarget_t const* _this, pcp_NodeRef_t* _result);

/// Returns the layer in the layer stack of the stop node that value 
/// resolution with this resolve target will stop at.
int usd_ResolveTarget_GetStopLayer(usd_ResolveTarget_t const* _this, sdf_LayerHandle_t* _result);

/// Returns true if this is a null resolve target.
int usd_ResolveTarget_IsNull(usd_ResolveTarget_t const* _this, bool* _result);

int usd_ResolveTarget_dtor(usd_ResolveTarget_t* _this);

/// Adds a path to the specializes listOp at the current EditTarget,
/// in the position specified by \p position.
int usd_Specializes_AddSpecialize(usd_Specializes_t* _this, sdf_Path_t const* primPath, int position, bool* _result);

/// Removes the specified path from the specializes listOp at the
/// current EditTarget.
int usd_Specializes_RemoveSpecialize(usd_Specializes_t* _this, sdf_Path_t const* primPath, bool* _result);

/// Removes the authored specializes listOp edits at the current edit
/// target.
int usd_Specializes_ClearSpecializes(usd_Specializes_t* _this, bool* _result);

/// Explicitly set specializes paths, potentially blocking weaker opinions
/// that add or remove items, returning true on success, false if the edit
/// could not be performed.
int usd_Specializes_SetSpecializes(usd_Specializes_t* _this, sdf_PathVector_t const* items, bool* _result);

/// Return the prim this object is bound to.
int usd_Specializes_GetPrim(usd_Specializes_t const* _this, usd_Prim_t const** _result);

int usd_Specializes_dtor(usd_Specializes_t* _this);

int usd_VariantSet_dtor(usd_VariantSet_t* _this);

int usd_VariantSets_dtor(usd_VariantSets_t* _this);

/// Calls SdfLayer::Save on all dirty layers contributing to this stage
/// except session layers and sublayers of session layers.
/// 
/// This function will emit a warning and skip each dirty anonymous
/// layer it encounters, since anonymous layers cannot be saved with
/// SdfLayer::Save. These layers must be manually exported by calling
/// SdfLayer::Export.
int usd_Stage_Save(usd_Stage_t* _this);

/// Calls SdfLayer::Save on all dirty session layers and sublayers of 
/// session layers contributing to this stage.
/// 
/// This function will emit a warning and skip each dirty anonymous
/// layer it encounters, since anonymous layers cannot be saved with
/// SdfLayer::Save. These layers must be manually exported by calling
/// SdfLayer::Export.
int usd_Stage_SaveSessionLayers(usd_Stage_t* _this);

/// Modify this stage's load rules to load the prim at \p path, its
/// ancestors, and all of its descendants if \p policy is
/// UsdLoadWithDescendants.  If \p policy is UsdLoadWithoutDescendants, then
/// payloads on descendant prims are not loaded.
/// 
/// See \ref Usd_workingSetManagement "Working Set Management" for more
/// information.
int usd_Stage_Load(usd_Stage_t* _this, sdf_Path_t const* path, int policy, usd_Prim_t* _result);

/// Modify this stage's load rules to unload the prim and its descendants
/// specified by \p path.
/// 
/// See \ref Usd_workingSetManagement "Working Set Management" for more
/// information.
int usd_Stage_Unload(usd_Stage_t* _this, sdf_Path_t const* path);

/// Unload and load the given path sets.  The effect is as if the unload set
/// were processed first followed by the load set.
/// 
/// This is equivalent to calling UsdStage::Unload for each item in the
/// unloadSet followed by UsdStage::Load for each item in the loadSet,
/// however this method is more efficient as all operations are committed in
/// a single batch.  The \p policy argument is described in the
/// documentation for Load().
/// 
/// See \ref Usd_workingSetManagement "Working Set Management" for more
/// information.
int usd_Stage_LoadAndUnload(usd_Stage_t* _this, sdf_PathSet_t const* loadSet, sdf_PathSet_t const* unloadSet, int policy);

/// Returns a set of all loaded paths.
/// 
/// The paths returned are both those that have been explicitly loaded and
/// those that were loaded as a result of dependencies, ancestors or
/// descendants of explicitly loaded paths.
/// 
/// This method does not return paths to inactive prims.
/// 
/// See \ref Usd_workingSetManagement "Working Set Management" for more
/// information.
int usd_Stage_GetLoadSet(usd_Stage_t* _this, sdf_PathSet_t* _result);

/// Returns an SdfPathSet of all paths that can be loaded.
/// 
/// Note that this method does not return paths to inactive prims as they
/// cannot be loaded.
/// 
/// The set returned includes loaded and unloaded paths. To determine the
/// set of unloaded paths, one can diff this set with the current load set,
/// for example:
/// \code
/// SdfPathSet loaded = stage->GetLoadSet(),
///            all = stage->FindLoadable(),
///            result;
/// std::set_difference(loaded.begin(), loaded.end(),
///                     all.begin(), all.end(),
///                     std::inserter(result, result.end()));
/// \endcode
/// 
/// See \ref Usd_workingSetManagement "Working Set Management" for more
/// information.
int usd_Stage_FindLoadable(usd_Stage_t* _this, sdf_Path_t const* rootPath, sdf_PathSet_t* _result);

/// Return the stage's current UsdStageLoadRules governing payload
/// inclusion.
/// 
/// See \ref Usd_workingSetManagement "Working Set Management" for more
/// information.
int usd_Stage_GetLoadRules(usd_Stage_t const* _this, usd_StageLoadRules_t const** _result);

/// Set the UsdStageLoadRules to govern payload inclusion on this stage.
/// This rebuilds the stage's entire prim hierarchy to follow \p rules.
/// 
/// Note that subsequent calls to Load(), Unload(), LoadAndUnload() will
/// modify this stages load rules as described in the documentation for
/// those member functions.
/// 
/// See \ref Usd_workingSetManagement "Working Set Management" for more
/// information.
int usd_Stage_SetLoadRules(usd_Stage_t* _this, usd_StageLoadRules_t const* rules);

/// Return this stage's population mask.
int usd_Stage_GetPopulationMask(usd_Stage_t const* _this, usd_StagePopulationMask_t* _result);

/// Set this stage's population mask and recompose the stage.
int usd_Stage_SetPopulationMask(usd_Stage_t* _this, usd_StagePopulationMask_t const* mask);

/// Return this stage's root session layer.
int usd_Stage_GetSessionLayer(usd_Stage_t const* _this, sdf_LayerHandle_t* _result);

/// Return this stage's root layer.
int usd_Stage_GetRootLayer(usd_Stage_t const* _this, sdf_LayerHandle_t* _result);

/// Return the path resolver context for all path resolution during
/// composition of this stage. Useful for external clients that want to
/// resolve paths with the same context as this stage, or create new
/// stages with the same context.
int usd_Stage_GetPathResolverContext(usd_Stage_t const* _this, ar_ResolverContext_t* _result);

/// Resolve the given identifier using this stage's 
/// ArResolverContext and the layer of its GetEditTarget()
/// as an anchor for relative references (e.g. \@./siblingFile.usd\@).   
/// 
/// \return a non-empty string containing either the same
/// identifier that was passed in (if the identifier refers to an
/// already-opened layer or an "anonymous", in-memory layer), or a resolved
/// layer filepath.  If the identifier was not resolvable, return the
/// empty string.
int usd_Stage_ResolveIdentifierToEditTarget(usd_Stage_t const* _this, std_String_t const* identifier, std_String_t* _result);

/// Return this stage's local layers in strong-to-weak order.  If
/// \a includeSessionLayers is true, return the linearized strong-to-weak
/// sublayers rooted at the stage's session layer followed by the linearized
/// strong-to-weak sublayers rooted at this stage's root layer.  If
/// \a includeSessionLayers is false, omit the sublayers rooted at this
/// stage's session layer.
int usd_Stage_GetLayerStack(usd_Stage_t const* _this, bool includeSessionLayers, sdf_LayerHandleVector_t* _result);

/// Return a vector of all of the layers \em currently consumed by this
/// stage, as determined by the composition arcs that were traversed to
/// compose and populate the stage.
/// 
/// The list of consumed layers will change with the stage's load-set and
/// variant selections, so the return value should be considered only
/// a snapshot.  The return value will include the stage's session layer,
/// if it has one. If \a includeClipLayers is true, we will also include
/// all of the layers that this stage has had to open so far to perform
/// value resolution of attributes affected by 
/// \ref Usd_Page_ValueClips "Value Clips"
int usd_Stage_GetUsedLayers(usd_Stage_t const* _this, bool includeClipLayers, sdf_LayerHandleVector_t* _result);

/// Return true if \a layer is one of the layers in this stage's local,
/// root layerStack.
int usd_Stage_HasLocalLayer(usd_Stage_t const* _this, sdf_LayerHandle_t const* layer, bool* _result);

/// Return the stage's EditTarget.
int usd_Stage_GetEditTarget(usd_Stage_t const* _this, usd_EditTarget_t const** _result);

/// Return a UsdEditTarget for editing the given local \a layer.
/// If the given layer appears more than once in the layer stack,
/// the time offset to the first occurrence will be used.
int usd_Stage_GetEditTargetForLocalLayer(usd_Stage_t* _this, sdf_LayerHandle_t const* layer, usd_EditTarget_t* _result);

/// Return a UsdEditTarget for editing the layer at index \a i in the
/// layer stack.  This edit target will incorporate any layer time
/// offset that applies to the sublayer.
int usd_Stage_GetEditTargetForLocalLayer_with_index(usd_Stage_t* _this, size_t i, usd_EditTarget_t* _result);

/// Set the stage's EditTarget.  If \a editTarget.IsLocalLayer(), check to
/// see if it's a layer in this stage's local LayerStack.  If not, issue an
/// error and do nothing.  If \a editTarget is invalid, issue an error
/// and do nothing.  If \a editTarget differs from the stage's current
/// EditTarget, set the EditTarget and send
/// UsdNotice::StageChangedEditTarget.  Otherwise do nothing.
int usd_Stage_SetEditTarget(usd_Stage_t* _this, usd_EditTarget_t const* editTarget);

/// Mute the layer identified by \p layerIdentifier.  Muted layers are
/// ignored by the stage; they do not participate in value resolution
/// or composition and do not appear in any LayerStack.  If the root 
/// layer of a reference or payload LayerStack is muted, the behavior 
/// is as if the muted layer did not exist, which means a composition 
/// error will be generated.
/// 
/// A canonical identifier for each layer in \p layersToMute will be
/// computed using ArResolver::CreateIdentifier using the stage's root
/// layer as the anchoring asset. Any layer encountered during composition
/// with the same identifier will be considered muted and ignored.
/// 
/// Note that muting a layer will cause this stage to release all
/// references to that layer.  If no other client is holding on to
/// references to that layer, it will be unloaded.  In this case, if 
/// there are unsaved edits to the muted layer, those edits are lost.  
/// Since anonymous layers are not serialized, muting an anonymous
/// layer will cause that layer and its contents to be lost in this
/// case.
/// 
/// Muting a layer that has not been used by this stage is not an error.
/// If that layer is encountered later, muting will take effect and that
/// layer will be ignored.  
/// 
/// The root layer of this stage may not be muted; attempting to do so
/// will generate a coding error.
int usd_Stage_MuteLayer(usd_Stage_t* _this, std_String_t const* layerIdentifier);

/// Unmute the layer identified by \p layerIdentifier if it had
/// previously been muted.
int usd_Stage_UnmuteLayer(usd_Stage_t* _this, std_String_t const* layerIdentifier);

/// Mute and unmute the layers identified in \p muteLayers and
/// \p unmuteLayers.  
/// 
/// This is equivalent to calling UsdStage::UnmuteLayer for each layer 
/// in \p unmuteLayers followed by UsdStage::MuteLayer for each layer 
/// in \p muteLayers, however this method is more efficient as all
/// operations are committed in a single batch.
int usd_Stage_MuteAndUnmuteLayers(usd_Stage_t* _this, std_StringVector_t const* muteLayers, std_StringVector_t const* unmuteLayers);

/// Returns a vector of all layers that have been muted on this stage.
int usd_Stage_GetMutedLayers(usd_Stage_t const* _this, std_StringVector_t const** _result);

/// Returns true if the layer specified by \p layerIdentifier is
/// muted in this cache, false otherwise.  See documentation on
/// MuteLayer for details on how \p layerIdentifier is compared to the 
/// layers that have been muted.
int usd_Stage_IsLayerMuted(usd_Stage_t const* _this, std_String_t const* layerIdentifier, bool* _result);

/// Writes out the composite scene as a single flattened layer into
/// \a filename.
/// 
/// If addSourceFileComment is true, a comment in the output layer
/// will mention the input layer it was generated from.
/// 
/// See UsdStage::Flatten for details of the flattening transformation.
int usd_Stage_Export(usd_Stage_t const* _this, std_String_t const* filename, bool addSourceFileComment, sdf_LayerFileFormatArguments_t const* args, bool* _result);

/// Writes the composite scene as a flattened Usd text
/// representation into the given \a string.
/// 
/// If addSourceFileComment is true, a comment in the output layer
/// will mention the input layer it was generated from.
/// 
/// See UsdStage::Flatten for details of the flattening transformation.
int usd_Stage_ExportToString(usd_Stage_t const* _this, std_String_t* result, bool addSourceFileComment, bool* _result);

/// Returns a single, anonymous, merged layer for this composite
/// scene.
/// 
/// Specifically, this function removes **most** composition metadata and
/// authors the resolved values for each object directly into the flattened
/// layer.
/// 
/// All VariantSets are removed and only the currently selected variants
/// will be present in the resulting layer.
/// 
/// Class prims will still exist, however all inherits arcs will have
/// been removed and the inherited data will be copied onto each child
/// object. Composition arcs authored on the class itself will be flattened
/// into the class.
/// 
/// Flatten preserves 
/// \ref Usd_Page_ScenegraphInstancing "scenegraph instancing" by creating 
/// independent roots for each prototype currently composed on this stage,
/// and adding a single internal reference arc on each instance prim to its 
/// corresponding prototype.
/// 
/// Time samples across sublayer offsets will will have the time offset and
/// scale applied to each time index.
/// 
/// Finally, any deactivated prims will be pruned from the result.
int usd_Stage_Flatten(usd_Stage_t const* _this, bool addSourceFileComment, sdf_LayerRefPtr_t* _result);

/// \overload
int usd_Stage_GetMetadata(usd_Stage_t const* _this, tf_Token_t const* key, vt_Value_t* value, bool* _result);

/// Returns true if the \a key has a meaningful value, that is, if
/// GetMetadata() will provide a value, either because it was authored
/// or because the Stage metadata was defined with a meaningful fallback 
/// value.
/// 
/// Returns false if \p key is not allowed as layer metadata.
int usd_Stage_HasMetadata(usd_Stage_t const* _this, tf_Token_t const* key, bool* _result);

/// Returns \c true if the \a key has an authored value, \c false if no
/// value was authored or the only value available is the SdfSchema's
/// metadata fallback.
/// 
/// \note If a value for a metadatum \em not legal to author on layers 
/// is present in the root or session layer (which could happen through
/// hand-editing or use of certain low-level API's), this method will
/// still return \c false.
int usd_Stage_HasAuthoredMetadata(usd_Stage_t const* _this, tf_Token_t const* key, bool* _result);

/// \overload
int usd_Stage_SetMetadata(usd_Stage_t const* _this, tf_Token_t const* key, vt_Value_t const* value, bool* _result);

/// Clear the value of stage metadatum \p key, if the stage's
/// current UsdEditTarget is the root or session layer.
/// 
/// If the current EditTarget is any other layer, raise a coding error.
/// \return true if authoring was successful, false otherwise.
/// Generates a coding error if \p key is not allowed as layer metadata.
/// 
/// \sa \ref Usd_OM_Metadata
int usd_Stage_ClearMetadata(usd_Stage_t const* _this, tf_Token_t const* key, bool* _result);

/// overload
int usd_Stage_GetMetadataByDictKey(usd_Stage_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t* value, bool* _result);

/// Return true if there exists any authored or fallback opinion for
/// \p key and \p keyPath.
/// 
/// The \p keyPath is a ':'-separated path identifying a value in
/// subdictionaries stored in the metadata field at \p key.  If
/// \p keyPath is empty, returns \c false.
/// 
/// Returns false if \p key is not allowed as layer metadata.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Stage_HasMetadataDictKey(usd_Stage_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Return true if there exists any authored opinion (excluding
/// fallbacks) for \p key and \p keyPath.  
/// 
/// The \p keyPath is a ':'-separated path identifying a value in
/// subdictionaries stored in the metadata field at \p key.  If 
/// \p keyPath is empty, returns \c false.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Stage_HasAuthoredMetadataDictKey(usd_Stage_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// \overload
int usd_Stage_SetMetadataByDictKey(usd_Stage_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, vt_Value_t const* value, bool* _result);

/// Clear any authored value identified by \p key and \p keyPath
/// at the current EditTarget.
/// 
/// The \p keyPath is a ':'-separated path identifying a path in
/// subdictionaries stored in the metadata field at \p key.  If
/// \p keyPath is empty, no action is taken.
/// 
/// \return true if the value is cleared successfully, false otherwise.
/// Generates a coding error if \p key is not allowed as layer metadata.
/// 
/// \sa \ref Usd_Dictionary_Type
int usd_Stage_ClearMetadataByDictKey(usd_Stage_t const* _this, tf_Token_t const* key, tf_Token_t const* keyPath, bool* _result);

/// Writes the fallback prim types defined in the schema registry to the 
/// stage as dictionary valued fallback prim type metadata. If the stage 
/// already has fallback prim type metadata, the fallback types from the 
/// schema registry will be added to the existing metadata, only for types 
/// that are already present in the dictionary, i.e. this won't overwrite 
/// existing fallback entries.
/// 
/// The current edit target determines whether the metadata is written to 
/// the root layer or the session layer. If the edit target specifies 
/// another layer besides these, this will produce an error.
/// 
/// This function can be used at any point before calling Save or Export on 
/// a stage to record the fallback types for the current schemas. This 
/// allows another version of Usd to open this stage and treat prim types it
/// doesn't recognize as a type it does recognize defined for it in this 
/// metadata.
/// 
/// \sa \ref Usd_OM_FallbackPrimTypes UsdSchemaRegistry::GetFallbackPrimTypes
int usd_Stage_WriteFallbackPrimTypes(usd_Stage_t* _this);

/// Returns the stage's start timeCode. If the stage has an associated
/// session layer with a start timeCode opinion, this value is returned. 
/// Otherwise, the start timeCode opinion from the root layer is returned.
int usd_Stage_GetStartTimeCode(usd_Stage_t const* _this, double* _result);

/// Sets the stage's start timeCode. 
/// 
/// The start timeCode is set in the current EditTarget, if it is the root 
/// layer of the stage or the session layer associated with the stage. If 
/// the current EditTarget is neither, a warning is issued and the start 
/// timeCode is not set.
int usd_Stage_SetStartTimeCode(usd_Stage_t* _this, double param00);

/// Returns the stage's end timeCode. If the stage has an associated
/// session layer with an end timeCode opinion, this value is returned. 
/// Otherwise, the end timeCode opinion from the root layer is returned.
int usd_Stage_GetEndTimeCode(usd_Stage_t const* _this, double* _result);

/// Sets the stage's end timeCode. 
/// 
/// The end timeCode is set in the current EditTarget, if it is the root 
/// layer of the stage or the session layer associated with the stage. If 
/// the current EditTarget is neither, a warning is issued and the end 
/// timeCode is not set.
int usd_Stage_SetEndTimeCode(usd_Stage_t* _this, double param00);

/// Returns true if the stage has both start and end timeCodes 
/// authored in the session layer or the root layer of the stage.
int usd_Stage_HasAuthoredTimeCodeRange(usd_Stage_t const* _this, bool* _result);

/// Returns the stage's timeCodesPerSecond value.
/// 
/// The timeCodesPerSecond value scales the time ordinate for the samples
/// contained in the stage to seconds. If timeCodesPerSecond is 24, then a 
/// sample at time ordinate 24 should be viewed exactly one second after the 
/// sample at time ordinate 0.
/// 
/// Like SdfLayer::GetTimeCodesPerSecond, this accessor uses a dynamic
/// fallback to framesPerSecond.  The order of precedence is:
/// 
/// \li timeCodesPerSecond from session layer
/// \li timeCodesPerSecond from root layer
/// \li framesPerSecond from session layer
/// \li framesPerSecond from root layer
/// \li fallback value of 24
int usd_Stage_GetTimeCodesPerSecond(usd_Stage_t const* _this, double* _result);

/// Sets the stage's timeCodesPerSecond value.
/// 
/// The timeCodesPerSecond value is set in the current EditTarget, if it 
/// is the root layer of the stage or the session layer associated with the 
/// stage. If the current EditTarget is neither, a warning is issued and no 
/// value is set.
/// 
/// \sa GetTimeCodesPerSecond()
int usd_Stage_SetTimeCodesPerSecond(usd_Stage_t const* _this, double timeCodesPerSecond);

/// Returns the stage's framesPerSecond value.
/// 
/// This makes an advisory statement about how the contained data can be 
/// most usefully consumed and presented.  It's primarily an indication of 
/// the expected playback rate for the data, but a timeline editing tool 
/// might also want to use this to decide how to scale and label its 
/// timeline.  
/// 
/// The default value of framesPerSecond is 24.
int usd_Stage_GetFramesPerSecond(usd_Stage_t const* _this, double* _result);

/// Sets the stage's framesPerSecond value.
/// 
/// The framesPerSecond value is set in the current EditTarget, if it 
/// is the root layer of the stage or the session layer associated with the 
/// stage. If the current EditTarget is neither, a warning is issued and no 
/// value is set.
/// 
/// \sa GetFramesPerSecond()
int usd_Stage_SetFramesPerSecond(usd_Stage_t const* _this, double framesPerSecond);

/// Sets the interpolation type used during value resolution
/// for all attributes on this stage.  Changing this will cause a
/// UsdNotice::StageContentsChanged notice to be sent, as values at
/// times where no samples are authored may have changed.
int usd_Stage_SetInterpolationType(usd_Stage_t* _this, int interpolationType);

/// Returns the interpolation type used during value resolution
/// for all attributes on this stage.
int usd_Stage_GetInterpolationType(usd_Stage_t const* _this, int* _result);

/// Returns all native instancing prototype prims.
int usd_Stage_GetPrototypes(usd_Stage_t const* _this, usd_PrimVector_t* _result);

/// Get the global variant fallback preferences used in new UsdStages.
int usd_Stage_GetGlobalVariantFallbacks(pcp_VariantFallbackMap_t* _result);

/// Set the global variant fallback preferences used in new
/// UsdStages. This overrides any fallbacks configured in plugin
/// metadata, and only affects stages created after this call.
/// 
/// \note This does not affect existing UsdStages.
int usd_Stage_SetGlobalVariantFallbacks(pcp_VariantFallbackMap_t const* fallbacks);

/// The initial set of prims to load on the stage can be specified
/// using the \p load parameter. \sa UsdStage::InitialLoadSet.
/// 
/// If \p pathResolverContext is provided it will be bound when creating the
/// root layer at \p identifier and whenever asset path resolution is done
/// for this stage, regardless of what other context may be bound at that
/// time. Otherwise Usd will create the root layer with no context bound,
/// then create a context for all future asset path resolution for the stage
/// by calling ArResolver::CreateDefaultContextForAsset with the root
/// layer's repository path if the layer has one, otherwise its resolved
/// path.
int usd_Stage_CreateNew(std_String_t const* identifier, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_CreateNew_with_session_layer(std_String_t const* identifier, sdf_LayerHandle_t const* sessionLayer, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_CreateNew_with_session_layer_and_resolver_context(std_String_t const* identifier, sdf_LayerHandle_t const* sessionLayer, ar_ResolverContext_t const* pathResolverContext, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_CreateNew_with_resolver_context(std_String_t const* identifier, ar_ResolverContext_t const* pathResolverContext, int load, usd_StageRefPtr_t* _result);

/// Creates a new stage only in memory, analogous to creating an
/// anonymous SdfLayer.
/// 
/// If \p pathResolverContext is provided it will be bound when creating the
/// root layer at \p identifier and whenever asset path resolution is done
/// for this stage, regardless of what other context may be bound at that
/// time. Otherwise Usd will create the root layer with no context bound,
/// then create a context for all future asset path resolution for the stage
/// by calling ArResolver::CreateDefaultContext.
/// 
/// The initial set of prims to load on the stage can be specified
/// using the \p load parameter. \sa UsdStage::InitialLoadSet.
/// 
/// Invoking an overload that does not take a \p sessionLayer argument will
/// create a stage with an anonymous in-memory session layer.  To create a
/// stage without a session layer, pass TfNullPtr (or None in python) as the
/// \p sessionLayer argument.
int usd_Stage_CreateInMemory(int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_CreateInMemory_with_identifier(std_String_t const* identifier, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_CreateInMemory_with_resolver_context(std_String_t const* identifier, ar_ResolverContext_t const* pathResolverContext, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_CreateInMemory_with_session_layer(std_String_t const* identifier, sdf_LayerHandle_t const* sessionLayer, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_CreateInMemory_with_session_layer_and_resolver_context(std_String_t const* identifier, sdf_LayerHandle_t const* sessionLayer, ar_ResolverContext_t const* pathResolverContext, int load, usd_StageRefPtr_t* _result);

/// Attempt to find a matching existing stage in a cache if
/// UsdStageCacheContext objects exist on the stack. Failing that, create a
/// new stage and recursively compose prims defined within and referenced by
/// the layer at \p filePath, which must already exist.
/// 
/// The initial set of prims to load on the stage can be specified
/// using the \p load parameter. \sa UsdStage::InitialLoadSet.
/// 
/// If \p pathResolverContext is provided it will be bound when opening the
/// root layer at \p filePath and whenever asset path resolution is done for
/// this stage, regardless of what other context may be bound at that
/// time. Otherwise Usd will open the root layer with no context bound, then
/// create a context for all future asset path resolution for the stage by
/// calling ArResolver::CreateDefaultContextForAsset with the layer's
/// repository path if the layer has one, otherwise its resolved path.
int usd_Stage_Open(std_String_t const* filePath, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_Open_with_resolver_context(std_String_t const* filePath, ar_ResolverContext_t const* pathResolverContext, int load, usd_StageRefPtr_t* _result);

/// Open a stage rooted at \p rootLayer.
/// 
/// Attempt to find a stage that matches the passed arguments in a
/// UsdStageCache if UsdStageCacheContext objects exist on the calling
/// stack.  If a matching stage is found, return that stage.  Otherwise,
/// create a new stage rooted at \p rootLayer.
/// 
/// Invoking an overload that does not take a \p sessionLayer argument will
/// create a stage with an anonymous in-memory session layer.  To create a
/// stage without a session layer, pass TfNullPtr (or None in python) as the
/// \p sessionLayer argument.
/// 
/// The initial set of prims to load on the stage can be specified
/// using the \p load parameter. \sa UsdStage::InitialLoadSet.
/// 
/// If \p pathResolverContext is provided it will be bound when whenever
/// asset path resolution is done for this stage, regardless of what other
/// context may be bound at that time. Otherwise Usd will create a context
/// for all future asset path resolution for the stage by calling
/// ArResolver::CreateDefaultContextForAsset with the layer's repository
/// path if the layer has one, otherwise its resolved path.
/// 
/// When searching for a matching stage in bound UsdStageCache s, only the
/// provided arguments matter for cache lookup.  For example, if only a root
/// layer (or a root layer file path) is provided, the first stage found in
/// any cache that has that root layer is returned.  So, for example if you
/// require that the stage have no session layer, you must explicitly
/// specify TfNullPtr (or None in python) for the sessionLayer argument.
int usd_Stage_Open_at_root(sdf_LayerHandle_t const* rootLayer, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_Open_at_root_with_resolver_context(sdf_LayerHandle_t const* rootLayer, ar_ResolverContext_t const* pathResolverContext, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_Open_at_root_with_session_layer_and_resolver_context(sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, ar_ResolverContext_t const* pathResolverContext, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_Open_at_root_with_session_layer(sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, int load, usd_StageRefPtr_t* _result);

/// Create a new stage and recursively compose prims defined within and
/// referenced by the layer at \p filePath which must already exist, subject
/// to \p mask.
/// 
/// These OpenMasked() methods do not automatically consult or populate
/// UsdStageCache s.
/// 
/// The initial set of prims to load on the stage can be specified
/// using the \p load parameter. \sa UsdStage::InitialLoadSet.
/// 
/// If \p pathResolverContext is provided it will be bound when opening the
/// root layer at \p filePath and whenever asset path resolution is done for
/// this stage, regardless of what other context may be bound at that
/// time. Otherwise Usd will open the root layer with no context bound, then
/// create a context for all future asset path resolution for the stage by
/// calling ArResolver::CreateDefaultContextForAsset with the layer's
/// repository path if the layer has one, otherwise its resolved path.
int usd_Stage_OpenMasked(std_String_t const* filePath, usd_StagePopulationMask_t const* mask, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_OpenMasked_with_resolver_context(std_String_t const* filePath, ar_ResolverContext_t const* pathResolverContext, usd_StagePopulationMask_t const* mask, int load, usd_StageRefPtr_t* _result);

/// Open a stage rooted at \p rootLayer and with limited population subject
/// to \p mask.
/// 
/// These OpenMasked() methods do not automatically consult or populate
/// UsdStageCache s.
/// 
/// Invoking an overload that does not take a \p sessionLayer argument will
/// create a stage with an anonymous in-memory session layer.  To create a
/// stage without a session layer, pass TfNullPtr (or None in python) as the
/// \p sessionLayer argument.
/// 
/// The initial set of prims to load on the stage can be specified
/// using the \p load parameter. \sa UsdStage::InitialLoadSet.
/// 
/// If \p pathResolverContext is provided it will be bound when whenever
/// asset path resolution is done for this stage, regardless of what other
/// context may be bound at that time. Otherwise Usd will create a context
/// for all future asset path resolution for the stage by calling
/// ArResolver::CreateDefaultContextForAsset with the layer's repository
/// path if the layer has one, otherwise its resolved path.
int usd_Stage_OpenMasked_at_root(sdf_LayerHandle_t const* rootLayer, usd_StagePopulationMask_t const* mask, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_OpenMasked_at_root_with_resolver_context(sdf_LayerHandle_t const* rootLayer, ar_ResolverContext_t const* pathResolverContext, usd_StagePopulationMask_t const* mask, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_OpenMasked_at_root_with_session_layer_and_resolver_context(sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, ar_ResolverContext_t const* pathResolverContext, usd_StagePopulationMask_t const* mask, int load, usd_StageRefPtr_t* _result);

/// \overload
int usd_Stage_OpenMasked_at_root_with_session_layer(sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, usd_StagePopulationMask_t const* mask, int load, usd_StageRefPtr_t* _result);

/// Indicates whether the specified file is supported by UsdStage.
/// 
/// This function is a cheap way to determine whether a
/// file might be open-able with UsdStage::Open. It is
/// purely based on the given \p filePath and does not
/// open the file or perform analysis on the contents.
/// As such, UsdStage::Open may still fail even if this
/// function returns true.
int usd_Stage_IsSupportedFile(std_String_t const* filePath, bool* _result);

/// Calls SdfLayer::Reload on all layers contributing to this stage,
/// except session layers and sublayers of session layers.
/// 
/// This includes non-session sublayers, references and payloads.
/// Note that reloading anonymous layers clears their content, so
/// invoking Reload() on a stage constructed via CreateInMemory()
/// will clear its root layer.
/// 
/// \note This method is considered a mutation, which has potentially
/// global effect!  Unlike the various Load() methods whose actions
/// affect only **this stage**, Reload() may cause layers to change their
/// contents, and because layers are global resources shared by
/// potentially many Stages, calling Reload() on one stage may result in
/// a mutation to any number of stages.  In general, unless you are
/// highly confident your stage is the only consumer of its layers, you
/// should only call Reload() when you are assured no other threads may
/// be reading from any Stages.
int usd_Stage_Reload(usd_Stage_t* _this);

/// Returns the global fallback values of 'colorConfiguration' and 
/// 'colorManagementSystem'. These are set in the plugInfo.json file 
/// of a plugin, but can be overridden by calling the static method 
/// SetColorConfigFallbacks().
/// 
/// The python wrapping of this method returns a tuple containing 
/// (colorConfiguration, colorManagementSystem).
/// 
/// 
/// \sa SetColorConfigFallbacks,
/// \ref Usd_ColorConfigurationAPI "Color Configuration API"
int usd_Stage_GetColorConfigFallbacks(sdf_AssetPath_t* colorConfiguration, tf_Token_t* colorManagementSystem);

/// Sets the global fallback values of color configuration metadata which 
/// includes the 'colorConfiguration' asset path and the name of the 
/// color management system. This overrides any fallback values authored 
/// in plugInfo files.
/// 
/// If the specified value of \p colorConfiguration or 
/// \p colorManagementSystem is empty, then the corresponding fallback 
/// value isn't set. In other words, for this call to have an effect, 
/// at least one value must be non-empty. Additionally, these can't be
/// reset to empty values.
/// 
/// \sa GetColorConfigFallbacks()
/// \ref Usd_ColorConfigurationAPI "Color Configuration API"
int usd_Stage_SetColorConfigFallbacks(sdf_AssetPath_t const* colorConfiguration, tf_Token_t const* colorManagementSystem);

/// Sets the default color configuration to be used to interpret the 
/// per-attribute color-spaces in the composed USD stage. This is specified
/// as asset path which can be resolved to the color spec file.
/// 
/// \ref Usd_ColorConfigurationAPI "Color Configuration API"
int usd_Stage_SetColorConfiguration(usd_Stage_t const* _this, sdf_AssetPath_t const* colorConfig);

/// Returns the default color configuration used to interpret the per-
/// attribute color-spaces in the composed USD stage.
/// 
/// \ref Usd_ColorConfigurationAPI "Color Configuration API"
int usd_Stage_GetColorConfiguration(usd_Stage_t const* _this, sdf_AssetPath_t* _result);

/// Sets the name of the color management system used to interpret the 
/// color configuration file pointed at by the colorConfiguration metadata.
/// 
/// \ref Usd_ColorConfigurationAPI "Color Configuration API"
int usd_Stage_SetColorManagementSystem(usd_Stage_t const* _this, tf_Token_t const* cms);

/// Sets the name of the color management system to be used for loading 
/// and interpreting the color configuration file.
/// 
/// \ref Usd_ColorConfigurationAPI "Color Configuration API"
int usd_Stage_GetColorManagementSystem(usd_Stage_t const* _this, tf_Token_t* _result);

/// Return the stage's "pseudo-root" prim, whose name is defined by Usd.
/// 
/// The stage's named root prims are namespace children of this prim,
/// which exists to make the namespace hierarchy a tree instead of a
/// forest.  This simplifies algorithms that want to traverse all prims.
/// 
/// A UsdStage always has a pseudo-root prim, unless there was an error
/// opening or creating the stage, in which case this method returns
/// an invalid UsdPrim.
int usd_Stage_GetPseudoRoot(usd_Stage_t const* _this, usd_Prim_t* _result);

/// Return the root UsdPrim on this stage whose name is the root layer's
/// defaultPrim metadata's value.  Return an invalid prim if there is no
/// such prim or if the root layer's defaultPrim metadata is unset or is not
/// a valid prim name.  Note that this function only examines this stage's
/// rootLayer.  It does not consider sublayers of the rootLayer.  See also
/// SdfLayer::GetDefaultPrim().
int usd_Stage_GetDefaultPrim(usd_Stage_t const* _this, usd_Prim_t* _result);

/// Set the default prim layer metadata in this stage's root layer.  This is
/// shorthand for:
/// \code
/// stage->GetRootLayer()->SetDefaultPrim(prim.GetName());
/// \endcode
/// Note that this function always authors to the stage's root layer.  To
/// author to a different layer, use the SdfLayer::SetDefaultPrim() API.
int usd_Stage_SetDefaultPrim(usd_Stage_t* _this, usd_Prim_t const* prim);

/// Clear the default prim layer metadata in this stage's root layer.  This
/// is shorthand for:
/// \code
/// stage->GetRootLayer()->ClearDefaultPrim();
/// \endcode
/// Note that this function always authors to the stage's root layer.  To
/// author to a different layer, use the SdfLayer::SetDefaultPrim() API.
int usd_Stage_ClearDefaultPrim(usd_Stage_t* _this);

/// Return true if this stage's root layer has an authored opinion for the
/// default prim layer metadata.  This is shorthand for:
/// \code
/// stage->GetRootLayer()->HasDefaultPrim();
/// \endcode
/// Note that this function only consults the stage's root layer.  To
/// consult a different layer, use the SdfLayer::HasDefaultPrim() API.
int usd_Stage_HasDefaultPrim(usd_Stage_t const* _this, bool* _result);

/// Return the UsdPrim at \p path, or an invalid UsdPrim if none exists.
/// 
/// If \p path indicates a prim beneath an instance, returns an instance
/// proxy prim if a prim exists at the corresponding path in that instance's
/// prototype.
/// 
/// Unlike OverridePrim() and DefinePrim(), this method will never author
/// scene description, and therefore is safe to use as a "reader" in the Usd
/// multi-threading model.
int usd_Stage_GetPrimAtPath(usd_Stage_t const* _this, sdf_Path_t const* path, usd_Prim_t* _result);

/// Return the UsdObject at \p path, or an invalid UsdObject if none exists.
/// 
/// If \p path indicates a prim beneath an instance, returns an instance
/// proxy prim if a prim exists at the corresponding path in that instance's
/// prototype. If \p path indicates a property beneath a child of an
/// instance, returns a property whose parent prim is an instance proxy
/// prim.
/// 
/// Example:
/// 
/// \code
/// if (UsdObject obj = stage->GetObjectAtPath(path)) {
///    if (UsdPrim prim = obj.As<UsdPrim>()) {
///        // Do things with prim
///    }
///    else if (UsdProperty prop = obj.As<UsdProperty>()) {
///        // Do things with property. We can also cast to
///        // UsdRelationship or UsdAttribute using this same pattern.
///    }
/// }
/// else {
///    // No object at specified path
/// }
/// \endcode
int usd_Stage_GetObjectAtPath(usd_Stage_t const* _this, sdf_Path_t const* path, usd_Object_t* _result);

/// Return the UsdProperty at \p path, or an invalid UsdProperty
/// if none exists.
/// 
/// This is equivalent to 
/// \code{.cpp}
/// stage.GetObjectAtPath(path).As<UsdProperty>();
/// \endcode
/// \sa GetObjectAtPath(const SdfPath&) const
int usd_Stage_GetPropertyAtPath(usd_Stage_t const* _this, sdf_Path_t const* path, usd_Property_t* _result);

/// Return the UsdAttribute at \p path, or an invalid UsdAttribute
/// if none exists.
/// 
/// This is equivalent to 
/// \code{.cpp}
/// stage.GetObjectAtPath(path).As<UsdAttribute>();
/// \endcode
/// \sa GetObjectAtPath(const SdfPath&) const
int usd_Stage_GetAttributeAtPath(usd_Stage_t const* _this, sdf_Path_t const* path, usd_Attribute_t* _result);

/// Return the UsdAttribute at \p path, or an invalid UsdAttribute
/// if none exists.
/// 
/// This is equivalent to 
/// \code{.cpp}
/// stage.GetObjectAtPath(path).As<UsdRelationship>();
/// \endcode
/// \sa GetObjectAtPath(const SdfPath&) const
int usd_Stage_GetRelationshipAtPath(usd_Stage_t const* _this, sdf_Path_t const* path, usd_Relationship_t* _result);

/// Attempt to ensure a \a UsdPrim at \p path exists on this stage.
/// 
/// If a prim already exists at \p path, return it.  Otherwise author
/// \a SdfPrimSpecs with \a specifier == \a SdfSpecifierOver and empty
/// \a typeName at the current EditTarget to create this prim and any
/// nonexistent ancestors, then return it.
/// 
/// The given \a path must be an absolute prim path that does not contain
/// any variant selections.
/// 
/// If it is impossible to author any of the necessary PrimSpecs, (for
/// example, in case \a path cannot map to the current UsdEditTarget's
/// namespace) issue an error and return an invalid \a UsdPrim.
/// 
/// If an ancestor of \p path identifies an \a inactive prim, author scene
/// description as described above but return an invalid prim, since the
/// resulting prim is descendant to an inactive prim.
int usd_Stage_OverridePrim(usd_Stage_t* _this, sdf_Path_t const* path, usd_Prim_t* _result);

/// Attempt to ensure a \a UsdPrim at \p path is defined (according to
/// UsdPrim::IsDefined()) on this stage.
/// 
/// If a prim at \p path is already defined on this stage and \p typeName is
/// empty or equal to the existing prim's typeName, return that prim.
/// Otherwise author an \a SdfPrimSpec with \a specifier ==
/// \a SdfSpecifierDef and \p typeName for the prim at \p path at the
/// current EditTarget.  Author \a SdfPrimSpec s with \p specifier ==
/// \a SdfSpecifierDef and empty typeName at the current EditTarget for any
/// nonexistent, or existing but not \a Defined ancestors.
/// 
/// The given \a path must be an absolute prim path that does not contain
/// any variant selections.
/// 
/// If it is impossible to author any of the necessary PrimSpecs (for
/// example, in case \a path cannot map to the current UsdEditTarget's
/// namespace or one of the ancestors of \p path is inactive on the 
/// UsdStage), issue an error and return an invalid \a UsdPrim.
/// 
/// Note that this method may return a defined prim whose typeName does not
/// match the supplied \p typeName, in case a stronger typeName opinion
/// overrides the opinion at the current EditTarget.
int usd_Stage_DefinePrim(usd_Stage_t* _this, sdf_Path_t const* path, tf_Token_t const* typeName, usd_Prim_t* _result);

/// Author an \a SdfPrimSpec with \a specifier == \a SdfSpecifierClass for
/// the class at root prim path \p path at the current EditTarget.  The
/// current EditTarget must have UsdEditTarget::IsLocalLayer() == true.
/// 
/// The given \a path must be an absolute, root prim path that does not
/// contain any variant selections.
/// 
/// If a defined (UsdPrim::IsDefined()) non-class prim already exists at
/// \p path, issue an error and return an invalid UsdPrim.
/// 
/// If it is impossible to author the necessary PrimSpec, issue an error
/// and return an invalid \a UsdPrim.
int usd_Stage_CreateClassPrim(usd_Stage_t* _this, sdf_Path_t const* rootPrimPath, usd_Prim_t* _result);

/// Remove all scene description for the given \p path and its subtree
/// <em>in the current UsdEditTarget</em>.
/// 
/// This method does not do what you might initially think!  Calling this
/// function will not necessarily cause the UsdPrim at \p path on this
/// stage to disappear.  Completely eradicating a prim from a composition
/// can be an involved process, involving edits to many contributing layers,
/// some of which (in many circumstances) will not be editable by a client.
/// This method is a surgical instrument that \em can be used iteratively
/// to effect complete removal of a prim and its subtree from namespace,
/// assuming the proper permissions are acquired, but more commonly it
/// is used to perform layer-level operations; e.g.: ensuring that a given
/// layer (as expressed by a UsdEditTarget) provides no opinions for a
/// prim and its subtree.
/// 
/// Generally, if your eye is attracted to this method, you probably want
/// to instead use UsdPrim::SetActive(false) , which will provide the
/// \ref Usd_ActiveInactive "composed effect" of removing the prim and
/// its subtree from the composition, without actually removing any
/// scene description, which as a bonus, means that the effect is 
/// reversible at a later time!
int usd_Stage_RemovePrim(usd_Stage_t* _this, sdf_Path_t const* path, bool* _result);

int usd_Stage_dtor(usd_Stage_t* _this);

/// Return a vector containing the stages present in this cache.
int usd_StageCache_GetAllStages(usd_StageCache_t const* _this, usd_StageRefPtrVector_t* _result);

/// Return the number of stages present in this cache.
int usd_StageCache_Size(usd_StageCache_t const* _this, size_t* _result);

/// Return true if this cache holds no stages, false otherwise.
int usd_StageCache_IsEmpty(usd_StageCache_t const* _this, bool* _result);

/// Find the stage in this cache corresponding to \p id in this cache.  If
/// \p id is not valid (see Id::IsValid()) or if this cache does not have a
/// stage corresponding to \p id, return null.
int usd_StageCache_Find(usd_StageCache_t const* _this, usd_StageCacheId_t id, usd_StageRefPtr_t* _result);

/// Find a stage in this cache with \p rootLayer.  If there is no matching
/// stage in this cache, return null.  If there is more than one matching
/// stage in this cache, return an arbitrary matching one.  See also
/// FindAllMatching().
int usd_StageCache_FindOneMatching_with_root_layer(usd_StageCache_t const* _this, sdf_LayerHandle_t const* rootLayer, usd_StageRefPtr_t* _result);

/// Find a stage in this cache with \p rootLayer and \p sessionLayer.  If
/// there is no matching stage in this cache, return null.  If there is more
/// than one matching stage in this cache, return an arbitrary matching one.
/// See also FindAllMatching().
int usd_StageCache_FindOneMatching_with_root_and_session_layer(usd_StageCache_t const* _this, sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, usd_StageRefPtr_t* _result);

/// Find a stage in this cache with \p rootLayer and \p pathResolverContext.
/// If there is no matching stage in this cache, return null.  If there is
/// more than one matching stage in this cache, return an arbitrary matching
/// one.
/// \sa FindAllMatching()
int usd_StageCache_FindOneMatching_with_root_layer_and_resolver(usd_StageCache_t const* _this, sdf_LayerHandle_t const* rootLayer, ar_ResolverContext_t const* pathResolverContext, usd_StageRefPtr_t* _result);

/// Find a stage in this cache with \p rootLayer, \p sessionLayer, and
/// \p pathResolverContext.  If there is no matching stage in this cache,
/// return null.  If there is more than one matching stage in this cache,
/// return an arbitrary matching one.
/// \sa FindAllMatching()
int usd_StageCache_FindOneMatching_with_root_and_session_layer_and_resolver(usd_StageCache_t const* _this, sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, ar_ResolverContext_t const* pathResolverContext, usd_StageRefPtr_t* _result);

/// Find all stages in this cache with \p rootLayer.  If there is no
/// matching stage in this cache, return an empty vector.
int usd_StageCache_FindAllMatching_with_root_layer(usd_StageCache_t const* _this, sdf_LayerHandle_t const* rootLayer, usd_StageRefPtrVector_t* _result);

/// Find all stages in this cache with \p rootLayer and \p sessionLayer.
/// If there is no matching stage in this cache, return an empty vector.
int usd_StageCache_FindAllMatching_with_root_and_session_layer(usd_StageCache_t const* _this, sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, usd_StageRefPtrVector_t* _result);

/// Find all stages in this cache with \p rootLayer and
/// \p pathResolverContext.  If there is no matching stage in this cache,
/// return an empty vector.
int usd_StageCache_FindAllMatching_with_root_layer_and_resolver(usd_StageCache_t const* _this, sdf_LayerHandle_t const* rootLayer, ar_ResolverContext_t const* pathResolverContext, usd_StageRefPtrVector_t* _result);

/// Find all stages in this cache with \p rootLayer, \p sessionLayer, and
/// \p pathResolverContext.  If there is no matching stage in this cache,
/// return an empty vector.  If there is more than one matching stage in
/// this cache, return an arbitrary matching one. 
int usd_StageCache_FindAllMatching_with_root_and_session_layer_and_resolver(usd_StageCache_t const* _this, sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, ar_ResolverContext_t const* pathResolverContext, usd_StageRefPtrVector_t* _result);

/// Return the Id associated with \p stage in this cache.  If \p stage is
/// not present in this cache, return an invalid Id.
int usd_StageCache_GetId(usd_StageCache_t const* _this, usd_StageRefPtr_t const* stage, usd_StageCacheId_t* _result);

/// Return true if \p stage is present in this cache, false otherwise.
int usd_StageCache_Contains(usd_StageCache_t const* _this, usd_StageRefPtr_t const* stage, bool* _result);

/// Return true if \p id is present in this cache, false otherwise.
int usd_StageCache_Contains_id(usd_StageCache_t const* _this, usd_StageCacheId_t id, bool* _result);

/// Insert \p stage into this cache and return its associated Id.  If the
/// given \p stage is already present in this cache, simply return its
/// associated Id.
int usd_StageCache_Insert(usd_StageCache_t* _this, usd_StageRefPtr_t const* stage, usd_StageCacheId_t* _result);

/// Erase \p stage from this cache and return true.  If \p stage is not
/// present in this cache, do nothing and return false.  Since the cache
/// contains UsdStageRefPtr, erasing a stage from the cache will only
/// destroy the stage if no other UsdStageRefPtrs exist referring to it.
int usd_StageCache_Erase(usd_StageCache_t* _this, usd_StageRefPtr_t const* stage, bool* _result);

/// Erase the stage identified by \p id from this cache and return true.  If
/// \p id is invalid or there is no associated stage in this cache, do
/// nothing and return false.  Since the cache contains UsdStageRefPtr,
/// erasing a stage from the cache will only destroy the stage if no other
/// UsdStageRefPtrs exist referring to it.
int usd_StageCache_Erase_id(usd_StageCache_t* _this, usd_StageCacheId_t id, bool* _result);

/// Erase all stages present in the cache with \p rootLayer and return the
/// number erased.  Since the cache contains UsdStageRefPtr, erasing a stage
/// from the cache will only destroy the stage if no other UsdStageRefPtrs
/// exist referring to it.
int usd_StageCache_EraseAll_with_root_layer(usd_StageCache_t* _this, sdf_LayerHandle_t const* rootLayer, size_t* _result);

/// Erase all stages present in the cache with \p rootLayer and
/// \p sessionLayer and return the number erased.  Since the cache contains
/// UsdStageRefPtr, erasing a stage from the cache will only destroy the
/// stage if no other UsdStageRefPtrs exist referring to it.
int usd_StageCache_EraseAll_with_root_and_session_layer(usd_StageCache_t* _this, sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, size_t* _result);

/// Erase all stages present in the cache with \p rootLayer,
/// \p sessionLayer, and \p pathResolverContext and return the number
/// erased.  Since the cache contains UsdStageRefPtr, erasing a stage from
/// the cache will only destroy the stage if no other UsdStageRefPtrs
/// exist referring to it.
int usd_StageCache_EraseAll_with_root_and_session_layer_and_resolver(usd_StageCache_t* _this, sdf_LayerHandle_t const* rootLayer, sdf_LayerHandle_t const* sessionLayer, ar_ResolverContext_t const* pathResolverContext, size_t* _result);

/// Remove all entries from this cache, leaving it empty and equivalent to a
/// default-constructed cache.  Since the cache contains UsdStageRefPtr,
/// erasing a stage from the cache will only destroy the stage if no other
/// UsdStageRefPtrs exist referring to it.
int usd_StageCache_Clear(usd_StageCache_t* _this);

/// Assign a debug name to this cache.  This will be emitted in debug output
/// messages when the USD_STAGE_CACHES debug flag is enabled.  If set to the
/// empty string, the cache's address will be used instead.
int usd_StageCache_SetDebugName(usd_StageCache_t* _this, std_String_t const* debugName);

/// Retrieve this cache's debug name, set with SetDebugName().  If no debug
/// name has been assigned, return the empty string.
int usd_StageCache_GetDebugName(usd_StageCache_t const* _this, std_String_t* _result);

int usd_StageCache_default(usd_StageCache_t** _result);

int usd_StageCache_dtor(usd_StageCache_t* _this);

/// Convert this Id to an integral representation.
int usd_StageCacheId_ToLongInt(usd_StageCacheId_t const* _this, long* _result);

/// Convert this Id to a string representation.
int usd_StageCacheId_ToString(usd_StageCacheId_t const* _this, std_String_t* _result);

/// Return true if this Id is valid.
int usd_StageCacheId_IsValid(usd_StageCacheId_t const* _this, bool* _result);

/// Create an Id from an integral value.  The supplied \p val must have
/// been obtained by calling ToLongInt() previously.
int usd_StageCacheId_FromLongInt(long val, usd_StageCacheId_t* _result);

/// Create an Id from a string value.  The supplied \p val must have
/// been obtained by calling ToString() previously.
int usd_StageCacheId_FromString(std_String_t const* s, usd_StageCacheId_t* _result);

/// Add a rule indicating that \p path, all its ancestors, and all its
/// descendants shall be loaded.
/// 
/// Any previous rules created by calling LoadWithoutDescendants() or
/// Unload() on this path or descendant paths are replaced by this rule.
/// For example, calling LoadWithoutDescendants('/World/sets/kitchen')
/// followed by LoadWithDescendants('/World/sets') will effectively remove
/// the rule created in the first call.  See AddRule() for more direct
/// manipulation.
int usd_StageLoadRules_LoadWithDescendants(usd_StageLoadRules_t* _this, sdf_Path_t const* path);

/// Add a rule indicating that \p path and all its ancestors but none of its
/// descendants shall be loaded.
/// 
/// Any previous rules created by calling LoadWithDescendants() or Unload()
/// on this path or descendant paths are replaced or restricted by this
/// rule.  For example, calling LoadWithDescendants('/World/sets') followed
/// by LoadWithoutDescendants('/World/sets/kitchen') will cause everything
/// under '/World/sets' to load except for those things under
/// '/World/sets/kitchen'.  See AddRule() for more direct manipulation.
int usd_StageLoadRules_LoadWithoutDescendants(usd_StageLoadRules_t* _this, sdf_Path_t const* path);

/// Add a rule indicating that \p path and all its descendants shall be
/// unloaded.
/// 
/// Any previous rules created by calling LoadWithDescendants() or
/// LoadWithoutDescendants() on this path or descendant paths are replaced
/// or restricted by this rule.  For example, calling
/// LoadWithDescendants('/World/sets') followed by
/// Unload('/World/sets/kitchen') will cause everything under '/World/sets'
/// to load, except for '/World/sets/kitchen' and everything under it.
int usd_StageLoadRules_Unload(usd_StageLoadRules_t* _this, sdf_Path_t const* path);

/// Add rules as if Unload() was called for each element of \p unloadSet
/// followed by calls to either LoadWithDescendants() (if \p policy is
/// UsdLoadPolicy::LoadWithDescendants) or LoadWithoutDescendants() (if
/// \p policy is UsdLoadPolicy::LoadWithoutDescendants) for each element of
/// \p loadSet.
int usd_StageLoadRules_LoadAndUnload(usd_StageLoadRules_t* _this, sdf_PathSet_t const* loadSet, sdf_PathSet_t const* unloadSet, int policy);

/// Add a literal rule.  If there's already a rule for \p path, replace it.
int usd_StageLoadRules_AddRule(usd_StageLoadRules_t* _this, sdf_Path_t const* path, int rule);

/// Remove any redundant rules to make the set of rules as small as possible
/// without changing behavior.
int usd_StageLoadRules_Minimize(usd_StageLoadRules_t* _this);

/// Return true if the given \p path is considered loaded by these rules, or
/// false if it is considered unloaded.  This is equivalent to
/// GetEffectiveRuleForPath(path) != NoneRule.
int usd_StageLoadRules_IsLoaded(usd_StageLoadRules_t const* _this, sdf_Path_t const* path, bool* _result);

/// Return true if the given \p path and all descendants are considered
/// loaded by these rules; false otherwise.
int usd_StageLoadRules_IsLoadedWithAllDescendants(usd_StageLoadRules_t const* _this, sdf_Path_t const* path, bool* _result);

/// Return true if the given \p path and is considered loaded, but none of
/// its descendants are considered loaded by these rules; false otherwise.
int usd_StageLoadRules_IsLoadedWithNoDescendants(usd_StageLoadRules_t const* _this, sdf_Path_t const* path, bool* _result);

/// Return the "effective" rule for the given \p path.  For example, if the
/// closest ancestral rule of \p path is an \p AllRule, return \p AllRule.
/// If the closest ancestral rule of \p path is for \p path itself and it is
/// an \p OnlyRule, return \p OnlyRule.  Otherwise if there is a closest
/// descendant rule to \p path this is an \p OnlyRule or an \p AllRule,
/// return \p OnlyRule.  Otherwise return \p NoneRule.
int usd_StageLoadRules_GetEffectiveRuleForPath(usd_StageLoadRules_t const* _this, sdf_Path_t const* path, int* _result);

/// Return all the rules as a vector.
int usd_StageLoadRules_GetRules(usd_StageLoadRules_t const* _this, usd_PathStageLoadRulesRulePairVector_t const** _result);

/// Return rules that load all payloads.  This is equivalent to
/// default-constructed UsdStageLoadRules.
int usd_StageLoadRules_LoadAll(usd_StageLoadRules_t* _result);

/// Return rules that load no payloads.
int usd_StageLoadRules_LoadNone(usd_StageLoadRules_t* _result);

int usd_StageLoadRules_default(usd_StageLoadRules_t** _result);

int usd_StageLoadRules_dtor(usd_StageLoadRules_t* _this);

int usd_PathStageLoadRulesRulePair_dtor(usd_PathStageLoadRulesRulePair_t* _this);

int usd_PathStageLoadRulesRulePairVector_data(usd_PathStageLoadRulesRulePairVector_t* _this, usd_PathStageLoadRulesRulePair_t** _result);

int usd_PathStageLoadRulesRulePairVector_data_const(usd_PathStageLoadRulesRulePairVector_t const* _this, usd_PathStageLoadRulesRulePair_t const** _result);

int usd_PathStageLoadRulesRulePairVector_empty(usd_PathStageLoadRulesRulePairVector_t const* _this, bool* _result);

int usd_PathStageLoadRulesRulePairVector_size(usd_PathStageLoadRulesRulePairVector_t const* _this, size_t* _result);

int usd_PathStageLoadRulesRulePairVector_max_size(usd_PathStageLoadRulesRulePairVector_t const* _this, size_t* _result);

int usd_PathStageLoadRulesRulePairVector_reserve(usd_PathStageLoadRulesRulePairVector_t* _this, size_t const _Newcapacity);

int usd_PathStageLoadRulesRulePairVector_capacity(usd_PathStageLoadRulesRulePairVector_t const* _this, size_t* _result);

int usd_PathStageLoadRulesRulePairVector_clear(usd_PathStageLoadRulesRulePairVector_t* _this);

int usd_PathStageLoadRulesRulePairVector_push_back(usd_PathStageLoadRulesRulePairVector_t* _this, usd_PathStageLoadRulesRulePair_t const* _Val);

int usd_PathStageLoadRulesRulePairVector_pop_back(usd_PathStageLoadRulesRulePairVector_t* _this);

int usd_PathStageLoadRulesRulePairVector_resize(usd_PathStageLoadRulesRulePairVector_t* _this, size_t const _Newsize);

int usd_PathStageLoadRulesRulePairVector_resize_with(usd_PathStageLoadRulesRulePairVector_t* _this, size_t const _Newsize, usd_PathStageLoadRulesRulePair_t const* _Val);

int usd_PathStageLoadRulesRulePairVector_op_index(usd_PathStageLoadRulesRulePairVector_t const* _this, size_t const _Pos, usd_PathStageLoadRulesRulePair_t const** _result);

int usd_PathStageLoadRulesRulePairVector_default(usd_PathStageLoadRulesRulePairVector_t** _result);

int usd_PathStageLoadRulesRulePairVector_dtor(usd_PathStageLoadRulesRulePairVector_t* _this);

int usd_StagePopulationMask_from_path_vector(usd_StagePopulationMask_t** _result);

int usd_StagePopulationMask_default(usd_StagePopulationMask_t** _result);

int usd_StagePopulationMask_dtor(usd_StagePopulationMask_t* _this);

int usd_StageRefPtr_get(usd_StageRefPtr_t const* _this, usd_Stage_t** _result);

int usd_StageRefPtr_ctor(usd_StageRefPtr_t** _result);

int usd_StageRefPtr_dtor(usd_StageRefPtr_t* _this);

int usd_StageRefPtrVector_data(usd_StageRefPtrVector_t* _this, usd_StageRefPtr_t** _result);

int usd_StageRefPtrVector_data_const(usd_StageRefPtrVector_t const* _this, usd_StageRefPtr_t const** _result);

int usd_StageRefPtrVector_empty(usd_StageRefPtrVector_t const* _this, bool* _result);

int usd_StageRefPtrVector_size(usd_StageRefPtrVector_t const* _this, size_t* _result);

int usd_StageRefPtrVector_max_size(usd_StageRefPtrVector_t const* _this, size_t* _result);

int usd_StageRefPtrVector_reserve(usd_StageRefPtrVector_t* _this, size_t const _Newcapacity);

int usd_StageRefPtrVector_capacity(usd_StageRefPtrVector_t const* _this, size_t* _result);

int usd_StageRefPtrVector_clear(usd_StageRefPtrVector_t* _this);

int usd_StageRefPtrVector_push_back(usd_StageRefPtrVector_t* _this, usd_StageRefPtr_t const* _Val);

int usd_StageRefPtrVector_pop_back(usd_StageRefPtrVector_t* _this);

int usd_StageRefPtrVector_resize(usd_StageRefPtrVector_t* _this, size_t const _Newsize);

int usd_StageRefPtrVector_resize_with(usd_StageRefPtrVector_t* _this, size_t const _Newsize, usd_StageRefPtr_t const* _Val);

int usd_StageRefPtrVector_op_index(usd_StageRefPtrVector_t const* _this, size_t const _Pos, usd_StageRefPtr_t const** _result);

int usd_StageRefPtrVector_default(usd_StageRefPtrVector_t** _result);

int usd_StageRefPtrVector_dtor(usd_StageRefPtrVector_t* _this);

int usd_StageWeakPtr_get(usd_StageWeakPtr_t const* _this, usd_Stage_t** _result);

int usd_StageWeakPtr_ctor(usd_StageWeakPtr_t** _result);

int usd_StageWeakPtr_dtor(usd_StageWeakPtr_t* _this);

/// Return true if this time represents the lowest/earliest possible
/// timeCode, false otherwise.
int usd_TimeCode_IsEarliestTime(usd_TimeCode_t const* _this, bool* _result);

/// Return true if this time represents the 'default' sentinel value, false
/// otherwise.  This is equivalent to !IsNumeric().
int usd_TimeCode_IsDefault(usd_TimeCode_t const* _this, bool* _result);

/// Return true if this time represents a numeric value, false otherwise.
/// This is equivalent to !IsDefault().
int usd_TimeCode_IsNumeric(usd_TimeCode_t const* _this, bool* _result);

/// Return the numeric value for this time.  If this time \a IsDefault(),
/// return a quiet NaN value.
int usd_TimeCode_GetValue(usd_TimeCode_t const* _this, double* _result);

/// Produce a UsdTimeCode representing the lowest/earliest possible
/// timeCode.  Thus, for any given timeSample \em s, its time ordinate 
/// \em t will obey: t >= UsdTimeCode::EarliestTime()
/// 
/// This is useful for clients that wish to retrieve the first authored 
/// timeSample for an attribute, as they can use UsdTimeCode::EarliestTime()
/// as the \em time argument to UsdAttribute::Get() and 
/// UsdAttribute::GetBracketingTimeSamples()
int usd_TimeCode_EarliestTime(usd_TimeCode_t* _result);

/// Produce a UsdTimeCode representing the sentinel value for 'default'.
/// 
/// \note In inequality comparisons, Default() is considered less than any
/// numeric TimeCode, including EarliestTime(), indicative of the fact that
/// in UsdAttribute value resolution, the sample at Default() (if any) is
/// always weaker than any numeric timeSample in the same layer.  For
/// more information, see \ref Usd_ValueResolution
int usd_TimeCode_Default(usd_TimeCode_t* _result);

/// Produce a safe step value such that for any numeric UsdTimeCode t in
/// [-maxValue, maxValue], t +/- (step / maxCompression) != t with a safety
/// factor of 2.  This is shorthand for
/// std::numeric_limits<double>::epsilon() * maxValue * maxCompression *
/// 2.0.  Such a step value is recommended for simulating jump
/// discontinuities in time samples.  For example, author value x at time t,
/// and value y at time t + SafeStep().  This ensures that as the sample
/// times are shifted and scaled, t and t + SafeStep() remain distinct so
/// long as they adhere to the \p maxValue and \p maxCompression limits.
int usd_TimeCode_SafeStep(double maxValue, double maxCompression, double* _result);

int usd_TimeCode_from_sdf_timecode(double param00, usd_TimeCode_t* _result);

int usd_TimeCode_from_time(double param00, usd_TimeCode_t* _result);

int usd_TimeCodeVector_data(usd_TimeCodeVector_t* _this, usd_TimeCode_t** _result);

int usd_TimeCodeVector_data_const(usd_TimeCodeVector_t const* _this, usd_TimeCode_t const** _result);

int usd_TimeCodeVector_empty(usd_TimeCodeVector_t const* _this, bool* _result);

int usd_TimeCodeVector_size(usd_TimeCodeVector_t const* _this, size_t* _result);

int usd_TimeCodeVector_max_size(usd_TimeCodeVector_t const* _this, size_t* _result);

int usd_TimeCodeVector_reserve(usd_TimeCodeVector_t* _this, size_t const _Newcapacity);

int usd_TimeCodeVector_capacity(usd_TimeCodeVector_t const* _this, size_t* _result);

int usd_TimeCodeVector_clear(usd_TimeCodeVector_t* _this);

int usd_TimeCodeVector_push_back(usd_TimeCodeVector_t* _this, usd_TimeCode_t const* _Val);

int usd_TimeCodeVector_pop_back(usd_TimeCodeVector_t* _this);

int usd_TimeCodeVector_resize(usd_TimeCodeVector_t* _this, size_t const _Newsize);

int usd_TimeCodeVector_resize_with(usd_TimeCodeVector_t* _this, size_t const _Newsize, usd_TimeCode_t const* _Val);

int usd_TimeCodeVector_op_index(usd_TimeCodeVector_t const* _this, size_t const _Pos, usd_TimeCode_t* _result);

int usd_TimeCodeVector_default(usd_TimeCodeVector_t** _result);

int usd_TimeCodeVector_dtor(usd_TimeCodeVector_t* _this);

int usd_Prim_GetProperties(usd_Prim_t* prim, usd_PropertyVector_t* _result);

/// Returns true iff this is holding an array type (see VtIsArray<>).
int vt_Value_IsArrayValued(vt_Value_t const* _this, bool* _result);

/// Returns true iff this value is empty.
int vt_Value_IsEmpty(vt_Value_t const* _this, bool* _result);

/// Return the number of elements in the held value if IsArrayValued(),
/// return 0 otherwise.
int vt_Value_GetArraySize(vt_Value_t const* _this, size_t* _result);

/// Returns the TfType of the type held by this value.
int vt_Value_GetType(vt_Value_t const* _this, tf_Type_t* _result);

/// Return the type name of the held typeid.
int vt_Value_GetTypeName(vt_Value_t const* _this, std_String_t* _result);

int vt_Value_IsHolding_bool(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_bool(vt_Value_t const* _this, bool* _result);

int vt_Value_IsHolding_int(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_int(vt_Value_t const* _this, int* _result);

int vt_Value_IsHolding_float(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_float(vt_Value_t const* _this, float* _result);

int vt_Value_IsHolding_double(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_double(vt_Value_t const* _this, double* _result);

int vt_Value_IsHolding_TfToken(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_TfToken(vt_Value_t const* _this, tf_Token_t const** _result);

int vt_Value_IsHolding_SdfAssetPath(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_SdfAssetPath(vt_Value_t const* _this, sdf_AssetPath_t const** _result);

int vt_Value_IsHolding_string(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_string(vt_Value_t const* _this, std_String_t const** _result);

int vt_Value_IsHolding_GfVec2d(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec2d(vt_Value_t const* _this, gf_Vec2d_t* _result);

int vt_Value_IsHolding_GfVec2h(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec2h(vt_Value_t const* _this, gf_Vec2h_t* _result);

int vt_Value_IsHolding_GfVec2f(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec2f(vt_Value_t const* _this, gf_Vec2f_t* _result);

int vt_Value_IsHolding_GfVec2i(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec2i(vt_Value_t const* _this, gf_Vec2i_t* _result);

int vt_Value_IsHolding_GfVec3d(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec3d(vt_Value_t const* _this, gf_Vec3d_t* _result);

int vt_Value_IsHolding_GfVec3h(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec3h(vt_Value_t const* _this, gf_Vec3h_t* _result);

int vt_Value_IsHolding_GfVec3f(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec3f(vt_Value_t const* _this, gf_Vec3f_t* _result);

int vt_Value_IsHolding_GfVec3i(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec3i(vt_Value_t const* _this, gf_Vec3i_t* _result);

int vt_Value_IsHolding_GfVec4d(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec4d(vt_Value_t const* _this, gf_Vec4d_t* _result);

int vt_Value_IsHolding_GfVec4h(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec4h(vt_Value_t const* _this, gf_Vec4h_t* _result);

int vt_Value_IsHolding_GfVec4f(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec4f(vt_Value_t const* _this, gf_Vec4f_t* _result);

int vt_Value_IsHolding_GfVec4i(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfVec4i(vt_Value_t const* _this, gf_Vec4i_t* _result);

int vt_Value_IsHolding_GfQuatd(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfQuatd(vt_Value_t const* _this, gf_Quatd_t* _result);

int vt_Value_IsHolding_GfQuatf(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfQuatf(vt_Value_t const* _this, gf_Quatf_t* _result);

int vt_Value_IsHolding_GfQuath(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfQuath(vt_Value_t const* _this, gf_Quath_t* _result);

int vt_Value_IsHolding_GfMatrix2d(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfMatrix2d(vt_Value_t const* _this, gf_Matrix2d_t* _result);

int vt_Value_IsHolding_GfMatrix2f(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfMatrix2f(vt_Value_t const* _this, gf_Matrix2f_t* _result);

int vt_Value_IsHolding_GfMatrix3d(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfMatrix3d(vt_Value_t const* _this, gf_Matrix3d_t* _result);

int vt_Value_IsHolding_GfMatrix3f(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfMatrix3f(vt_Value_t const* _this, gf_Matrix3f_t* _result);

int vt_Value_IsHolding_GfMatrix4d(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfMatrix4d(vt_Value_t const* _this, gf_Matrix4d_t* _result);

int vt_Value_IsHolding_GfMatrix4f(vt_Value_t const* _this, bool* _result);

int vt_Value_Get_GfMatrix4f(vt_Value_t const* _this, gf_Matrix4f_t* _result);

int vt_Value_from_GfMatrix4f(vt_Value_t** _result);

int vt_Value_from_GfMatrix4d(vt_Value_t** _result);

int vt_Value_from_GfMatrix3f(vt_Value_t** _result);

int vt_Value_from_GfMatrix3d(vt_Value_t** _result);

int vt_Value_from_GfMatrix2f(vt_Value_t** _result);

int vt_Value_from_GfMatrix2d(vt_Value_t** _result);

int vt_Value_from_GfQuath(vt_Value_t** _result);

int vt_Value_from_GfQuatf(vt_Value_t** _result);

int vt_Value_from_GfQuatd(vt_Value_t** _result);

int vt_Value_from_GfVec4i(vt_Value_t** _result);

int vt_Value_from_GfVec4f(vt_Value_t** _result);

int vt_Value_from_GfVec4h(vt_Value_t** _result);

int vt_Value_from_GfVec4d(vt_Value_t** _result);

int vt_Value_from_GfVec3i(vt_Value_t** _result);

int vt_Value_from_GfVec3f(vt_Value_t** _result);

int vt_Value_from_GfVec3h(vt_Value_t** _result);

int vt_Value_from_GfVec3d(vt_Value_t** _result);

int vt_Value_from_GfVec2i(vt_Value_t** _result);

int vt_Value_from_GfVec2f(vt_Value_t** _result);

int vt_Value_from_GfVec2h(vt_Value_t** _result);

int vt_Value_from_GfVec2d(vt_Value_t** _result);

int vt_Value_from_string(vt_Value_t** _result);

int vt_Value_from_SdfAssetPath(vt_Value_t** _result);

int vt_Value_from_TfToken(vt_Value_t** _result);

int vt_Value_from_double(vt_Value_t** _result);

int vt_Value_from_float(vt_Value_t** _result);

int vt_Value_from_int(vt_Value_t** _result);

int vt_Value_from_bool(vt_Value_t** _result);

int vt_Value_ctor(vt_Value_t** _result);

int vt_Value_new(vt_Value_t** _result);

int vt_Value_dtor(vt_Value_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int vt_TokenArray_data(vt_TokenArray_t* _this, tf_Token_t** _result);

/// Return a const pointer to this array's data.
int vt_TokenArray_data_const(vt_TokenArray_t const* _this, tf_Token_t const** _result);

/// Return the total number of elements in this array.
int vt_TokenArray_size(vt_TokenArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int vt_TokenArray_op_index(vt_TokenArray_t* _this, size_t index, tf_Token_t** _result);

/// Allows usage of [i].
int vt_TokenArray_op_index_const(vt_TokenArray_t const* _this, size_t index, tf_Token_t const** _result);

int vt_TokenArray_new(vt_TokenArray_t** _result);

int vt_TokenArray_dtor(vt_TokenArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int vt_BoolArray_data(vt_BoolArray_t* _this, bool** _result);

/// Return a const pointer to this array's data.
int vt_BoolArray_data_const(vt_BoolArray_t const* _this, bool const** _result);

/// Return the total number of elements in this array.
int vt_BoolArray_size(vt_BoolArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int vt_BoolArray_op_index(vt_BoolArray_t* _this, size_t index, bool* _result);

/// Allows usage of [i].
int vt_BoolArray_op_index_const(vt_BoolArray_t const* _this, size_t index, bool* _result);

int vt_BoolArray_new(vt_BoolArray_t** _result);

int vt_BoolArray_dtor(vt_BoolArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int vt_IntArray_data(vt_IntArray_t* _this, int** _result);

/// Return a const pointer to this array's data.
int vt_IntArray_data_const(vt_IntArray_t const* _this, int const** _result);

/// Return the total number of elements in this array.
int vt_IntArray_size(vt_IntArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int vt_IntArray_op_index(vt_IntArray_t* _this, size_t index, int* _result);

/// Allows usage of [i].
int vt_IntArray_op_index_const(vt_IntArray_t const* _this, size_t index, int* _result);

int vt_IntArray_new(vt_IntArray_t** _result);

int vt_IntArray_dtor(vt_IntArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int vt_FloatArray_data(vt_FloatArray_t* _this, float** _result);

/// Return a const pointer to this array's data.
int vt_FloatArray_data_const(vt_FloatArray_t const* _this, float const** _result);

/// Return the total number of elements in this array.
int vt_FloatArray_size(vt_FloatArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int vt_FloatArray_op_index(vt_FloatArray_t* _this, size_t index, float* _result);

/// Allows usage of [i].
int vt_FloatArray_op_index_const(vt_FloatArray_t const* _this, size_t index, float* _result);

int vt_FloatArray_new(vt_FloatArray_t** _result);

int vt_FloatArray_dtor(vt_FloatArray_t* _this);

/// Return a non-const pointer to this array's data.  The underlying data is
/// copied if it is not uniquely owned.
int vt_DoubleArray_data(vt_DoubleArray_t* _this, double** _result);

/// Return a const pointer to this array's data.
int vt_DoubleArray_data_const(vt_DoubleArray_t const* _this, double const** _result);

/// Return the total number of elements in this array.
int vt_DoubleArray_size(vt_DoubleArray_t const* _this, size_t* _result);

/// Allows usage of [i].
int vt_DoubleArray_op_index(vt_DoubleArray_t* _this, size_t index, double* _result);

/// Allows usage of [i].
int vt_DoubleArray_op_index_const(vt_DoubleArray_t const* _this, size_t index, double* _result);

int vt_DoubleArray_new(vt_DoubleArray_t** _result);

int vt_DoubleArray_dtor(vt_DoubleArray_t* _this);

int vt_Dictionary_dtor(vt_Dictionary_t* _this);



#ifdef __cplusplus
}
#endif

#undef BBL_ALIGN


#endif
